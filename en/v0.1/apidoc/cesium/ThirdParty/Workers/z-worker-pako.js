/*! For license information please see z-worker-pako.js.LICENSE.txt */
!function(){"use strict";const{Array:e,Object:t,Math:r,Error:a,Uint8Array:i,Uint16Array:c,Uint32Array:l,Int32Array:h,DataView:u,Promise:p,TextEncoder:f,crypto:d,postMessage:g,TransformStream:w,ReadableStream:y,WritableStream:_,CompressionStream:m,DecompressionStream:b}=globalThis,v=[];for(let e=0;256>e;e++){let t=e;for(let e=0;8>e;e++)1&t?t=t>>>1^3988292384:t>>>=1;v[e]=t}class S{constructor(e){this.crc=e||-1}append(e){let t=0|this.crc;for(let r=0,a=0|e.length;a>r;r++)t=t>>>8^v[255&(t^e[r])];this.crc=t}get(){return~this.crc}}class z extends w{constructor(){super({start(){this.crc32=new S},transform(e){this.crc32.append(e)},flush(e){const t=new i(4);new u(t.buffer).setUint32(0,this.crc32.get()),e.enqueue(t)}})}}const T={concat(e,t){if(0===e.length||0===t.length)return e.concat(t);const r=e[e.length-1],a=T.getPartial(r);return 32===a?e.concat(t):T._shiftRight(t,a,0|r,e.slice(0,e.length-1))},bitLength(e){const t=e.length;if(0===t)return 0;const r=e[t-1];return 32*(t-1)+T.getPartial(r)},clamp(e,t){if(32*e.length<t)return e;const a=(e=e.slice(0,r.ceil(t/32))).length;return t&=31,a>0&&t&&(e[a-1]=T.partial(t,e[a-1]&2147483648>>t-1,1)),e},partial:(e,t,r)=>32===e?t:(r?0|t:t<<32-e)+1099511627776*e,getPartial:e=>r.round(e/1099511627776)||32,_shiftRight(e,t,r,a){for(void 0===a&&(a=[]);t>=32;t-=32)a.push(r),r=0;if(0===t)return a.concat(e);for(let i=0;i<e.length;i++)a.push(r|e[i]>>>t),r=e[i]<<32-t;const i=e.length?e[e.length-1]:0,c=T.getPartial(i);return a.push(T.partial(t+c&31,t+c>32?r:a.pop(),1)),a}},C={bytes:{fromBits(e){const t=T.bitLength(e)/8,r=new i(t);let a;for(let i=0;t>i;i++)0==(3&i)&&(a=e[i/4]),r[i]=a>>>24,a<<=8;return r},toBits(e){const t=[];let r,a=0;for(r=0;r<e.length;r++)a=a<<8|e[r],3==(3&r)&&(t.push(a),a=0);return 3&r&&t.push(T.partial(8*(3&r),a)),t}}},D={sha1:function(e){e?(this._h=e._h.slice(0),this._buffer=e._buffer.slice(0),this._length=e._length):this.reset()}};D.sha1.prototype={blockSize:512,reset(){const e=this;return e._h=this._init.slice(0),e._buffer=[],e._length=0,e},update(e){const t=this;"string"==typeof e&&(e=C.utf8String.toBits(e));const r=t._buffer=T.concat(t._buffer,e),i=t._length,c=t._length=i+T.bitLength(e);if(c>9007199254740991)throw new a("Cannot hash more than 2^53 - 1 bits");const h=new l(r);let u=0;for(let e=t.blockSize+i-(t.blockSize+i&t.blockSize-1);c>=e;e+=t.blockSize)t._block(h.subarray(16*u,16*(u+1))),u+=1;return r.splice(0,16*u),t},finalize(){const e=this;let t=e._buffer;const a=e._h;t=T.concat(t,[T.partial(1,1)]);for(let e=t.length+2;15&e;e++)t.push(0);for(t.push(r.floor(e._length/4294967296)),t.push(0|e._length);t.length;)e._block(t.splice(0,16));return e.reset(),a},_init:[1732584193,4023233417,2562383102,271733878,3285377520],_key:[1518500249,1859775393,2400959708,3395469782],_f:(e,t,r,a)=>e>19?e>39?e>59?e>79?void 0:t^r^a:t&r|t&a|r&a:t^r^a:t&r|~t&a,_S:(e,t)=>t<<e|t>>>32-e,_block(t){const a=this,i=a._h,c=e(80);for(let e=0;16>e;e++)c[e]=t[e];let l=i[0],h=i[1],u=i[2],p=i[3],f=i[4];for(let e=0;79>=e;e++){16>e||(c[e]=a._S(1,c[e-3]^c[e-8]^c[e-14]^c[e-16]));const t=a._S(5,l)+a._f(e,h,u,p)+f+c[e]+a._key[r.floor(e/20)]|0;f=p,p=u,u=a._S(30,h),h=l,l=t}i[0]=i[0]+l|0,i[1]=i[1]+h|0,i[2]=i[2]+u|0,i[3]=i[3]+p|0,i[4]=i[4]+f|0}};const R={getRandomValues(e){const t=new l(e.buffer),n=e=>{let t=987654321;const a=4294967295;return()=>(t=36969*(65535&t)+(t>>16)&a,(((t<<16)+(e=18e3*(65535&e)+(e>>16)&a)&a)/4294967296+.5)*(r.random()>.5?1:-1))};for(let a,i=0;i<e.length;i+=4){const e=n(4294967296*(a||r.random()));a=987654071*e(),t[i/4]=4294967296*e()|0}return e}},q={importKey:e=>new q.hmacSha1(C.bytes.toBits(e)),pbkdf2(e,t,r,i){if(r=r||1e4,0>i||0>r)throw new a("invalid params to pbkdf2");const c=1+(i>>5)<<2;let l,h,p,f,d;const g=new ArrayBuffer(c),w=new u(g);let y=0;const _=T;for(t=C.bytes.toBits(t),d=1;(c||1)>y;d++){for(l=h=e.encrypt(_.concat(t,[d])),p=1;r>p;p++)for(h=e.encrypt(h),f=0;f<h.length;f++)l[f]^=h[f];for(p=0;(c||1)>y&&p<l.length;p++)w.setInt32(y,l[p]),y+=4}return g.slice(0,i/8)},hmacSha1:class{constructor(e){const t=this,r=t._hash=D.sha1,a=[[],[]],i=r.prototype.blockSize/32;t._baseHash=[new r,new r],e.length>i&&(e=r.hash(e));for(let t=0;i>t;t++)a[0][t]=909522486^e[t],a[1][t]=1549556828^e[t];t._baseHash[0].update(a[0]),t._baseHash[1].update(a[1]),t._resultHash=new r(t._baseHash[0])}reset(){const e=this;e._resultHash=new e._hash(e._baseHash[0]),e._updated=!1}update(e){this._updated=!0,this._resultHash.update(e)}digest(){const e=this,t=e._resultHash.finalize(),r=new e._hash(e._baseHash[1]).update(t).finalize();return e.reset(),r}encrypt(e){if(this._updated)throw new a("encrypt on already updated hmac called!");return this.update(e),this.digest(e)}}},I="Invalid password",V=16,A={name:"PBKDF2"},B=t.assign({hash:{name:"HMAC"}},A),x=t.assign({iterations:1e3,hash:{name:"SHA-1"}},A),W=["deriveBits"],P=[8,12,16],U=[16,24,32],M=10,L=[0,0,0,0],j="undefined",F="function",N=typeof d!=j,Q=N&&typeof d.subtle!=j,X=N&&typeof d.getRandomValues==F,Y=N&&Q&&typeof d.subtle.importKey==F,Z=N&&Q&&typeof d.subtle.deriveBits==F,$=C.bytes,ee=class{constructor(e){const t=this;t._tables=[[[],[],[],[],[]],[[],[],[],[],[]]],t._tables[0][0][0]||t._precompute();const r=t._tables[0][4],i=t._tables[1],c=e.length;let l,h,u,p=1;if(4!==c&&6!==c&&8!==c)throw new a("invalid aes key size");for(t._key=[h=e.slice(0),u=[]],l=c;4*c+28>l;l++){let e=h[l-1];(l%c==0||8===c&&l%c==4)&&(e=r[e>>>24]<<24^r[e>>16&255]<<16^r[e>>8&255]<<8^r[255&e],l%c==0&&(e=e<<8^e>>>24^p<<24,p=p<<1^283*(p>>7))),h[l]=h[l-c]^e}for(let e=0;l;e++,l--){const t=h[3&e?l:l-4];u[e]=4>=l||4>e?t:i[0][r[t>>>24]]^i[1][r[t>>16&255]]^i[2][r[t>>8&255]]^i[3][r[255&t]]}}encrypt(e){return this._crypt(e,0)}decrypt(e){return this._crypt(e,1)}_precompute(){const e=this._tables[0],t=this._tables[1],r=e[4],a=t[4],i=[],c=[];let l,h,u,p;for(let e=0;256>e;e++)c[(i[e]=e<<1^283*(e>>7))^e]=e;for(let f=l=0;!r[f];f^=h||1,l=c[l]||1){let c=l^l<<1^l<<2^l<<3^l<<4;c=c>>8^255&c^99,r[f]=c,a[c]=f,p=i[u=i[h=i[f]]];let d=16843009*p^65537*u^257*h^16843008*f,g=257*i[c]^16843008*c;for(let r=0;4>r;r++)e[r][f]=g=g<<24^g>>>8,t[r][c]=d=d<<24^d>>>8}for(let r=0;5>r;r++)e[r]=e[r].slice(0),t[r]=t[r].slice(0)}_crypt(e,t){if(4!==e.length)throw new a("invalid aes block size");const r=this._key[t],i=r.length/4-2,c=[0,0,0,0],l=this._tables[t],h=l[0],u=l[1],p=l[2],f=l[3],d=l[4];let g,w,y,_=e[0]^r[0],m=e[t?3:1]^r[1],b=e[2]^r[2],v=e[t?1:3]^r[3],S=4;for(let e=0;i>e;e++)g=h[_>>>24]^u[m>>16&255]^p[b>>8&255]^f[255&v]^r[S],w=h[m>>>24]^u[b>>16&255]^p[v>>8&255]^f[255&_]^r[S+1],y=h[b>>>24]^u[v>>16&255]^p[_>>8&255]^f[255&m]^r[S+2],v=h[v>>>24]^u[_>>16&255]^p[m>>8&255]^f[255&b]^r[S+3],S+=4,_=g,m=w,b=y;for(let e=0;4>e;e++)c[t?3&-e:e]=d[_>>>24]<<24^d[m>>16&255]<<16^d[b>>8&255]<<8^d[255&v]^r[S++],g=_,_=m,m=b,b=v,v=g;return c}},te=class{constructor(e,t){this._prf=e,this._initIv=t,this._iv=t}reset(){this._iv=this._initIv}update(e){return this.calculate(this._prf,e,this._iv)}incWord(e){if(255==(e>>24&255)){let t=e>>16&255,r=e>>8&255,a=255&e;255===t?(t=0,255===r?(r=0,255===a?a=0:++a):++r):++t,e=0,e+=t<<16,e+=r<<8,e+=a}else e+=1<<24;return e}incCounter(e){0===(e[0]=this.incWord(e[0]))&&(e[1]=this.incWord(e[1]))}calculate(e,t,r){let a;if(!(a=t.length))return[];const i=T.bitLength(t);for(let i=0;a>i;i+=4){this.incCounter(r);const a=e.encrypt(r);t[i]^=a[0],t[i+1]^=a[1],t[i+2]^=a[2],t[i+3]^=a[3]}return T.clamp(t,i)}},ne=q.hmacSha1;class se extends w{constructor(r,c,l){let h;super({start(){t.assign(this,{ready:new p((e=>this.resolveReady=e)),password:r,signed:c,strength:l-1,pending:new i})},async transform(t,r){const c=this;if(c.password){const r=c.password;c.password=null;const i=k(t,0,P[c.strength]+2);await(async(e,t,r)=>{await ft(e,r,k(t,0,P[e.strength]));const i=k(t,P[e.strength]),c=e.keys.passwordVerification;if(c[0]!=i[0]||c[1]!=i[1])throw new a(I)})(c,i,r),c.ctr=new te(new ee(c.keys.key),e.from(L)),c.hmac=new ne(c.keys.authentication),t=k(t,P[c.strength]+2),c.resolveReady()}else await c.ready;const l=new i(t.length-M-(t.length-M)%V);r.enqueue(pt(c,t,l,0,M,!0))},async flush(e){const t=this;await t.ready;const r=t.pending,a=k(r,0,r.length-M),c=k(r,r.length-M);let l=new i;if(a.length){const e=K($,a);t.hmac.update(e);const r=t.ctr.update(e);l=H($,r)}if(h.valid=!0,t.signed){const e=k(H($,t.hmac.digest()),0,M);for(let t=0;M>t;t++)e[t]!=c[t]&&(h.valid=!1)}e.enqueue(l)}}),h=this}}class re extends w{constructor(r,a){let c;super({start(){t.assign(this,{ready:new p((e=>this.resolveReady=e)),password:r,strength:a-1,pending:new i})},async transform(t,r){const a=this;let c=new i;if(a.password){const t=a.password;a.password=null,c=await(async(e,t)=>{const r=(a=new i(P[e.strength]),X?d.getRandomValues(a):R.getRandomValues(a));var a;return await ft(e,t,r),O(r,e.keys.passwordVerification)})(a,t),a.ctr=new te(new ee(a.keys.key),e.from(L)),a.hmac=new ne(a.keys.authentication),a.resolveReady()}else await a.ready;const l=new i(c.length+t.length-t.length%V);l.set(c,0),r.enqueue(pt(a,t,l,c.length,0))},async flush(e){const t=this;await t.ready;let r=new i;if(t.pending.length){const e=t.ctr.update(K($,t.pending));t.hmac.update(e),r=H($,e)}c.signature=H($,t.hmac.digest()).slice(0,M),e.enqueue(O(r,c.signature))}}),c=this}}function pt(e,t,r,a,c,l){const h=t.length-c;let u;for(e.pending.length&&(t=O(e.pending,t),r=((e,t)=>{if(t&&t>e.length){const r=e;(e=new i(t)).set(r,0)}return e})(r,h-h%V)),u=0;h-V>=u;u+=V){const i=K($,k(t,u,u+V));l&&e.hmac.update(i);const c=e.ctr.update(i);l||e.hmac.update(c),r.set(H($,c),u+a)}return e.pending=k(t,u),r}async function ft(e,r,a){const c=(e=>{if(void 0===f){const t=new i((e=unescape(encodeURIComponent(e))).length);for(let r=0;r<t.length;r++)t[r]=e.charCodeAt(r);return t}return(new f).encode(e)})(r),l=await(p=c,g=B,w=W,Y?d.subtle.importKey("raw",p,g,!1,w):q.importKey(p)),h=await(async(e,t,r)=>Z?await d.subtle.deriveBits(e,t,r):q.pbkdf2(t,e.salt,x.iterations,r))(t.assign({salt:a},x),l,8*(2*U[e.strength]+2)),u=new i(h);var p,g,w;e.keys={key:K($,k(u,0,U[e.strength])),authentication:K($,k(u,U[e.strength],2*U[e.strength])),passwordVerification:k(u,2*U[e.strength])}}function O(e,t){let r=e;return e.length+t.length&&(r=new i(e.length+t.length),r.set(e,0),r.set(t,e.length)),r}function k(e,t,r){return e.subarray(t,r)}function H(e,t){return e.fromBits(t)}function K(e,t){return e.toBits(t)}class ae extends w{constructor(e,r){let i;super({start(){t.assign(this,{password:e,passwordVerification:r}),wt(this,e)},transform(e,t){const r=this;if(r.password){const t=dt(r,e.subarray(0,12));if(r.password=null,t[11]!=r.passwordVerification)throw new a(I);e=e.subarray(12)}t.enqueue(dt(r,e))},flush(){i.valid=!0}}),i=this}}class ie extends w{constructor(e,r){super({start(){t.assign(this,{password:e,passwordVerification:r}),wt(this,e)},transform(e,t){const r=this;let a,c;if(r.password){r.password=null;const t=d.getRandomValues(new i(12));t[11]=r.passwordVerification,a=new i(e.length+t.length),a.set(gt(r,t),0),c=12}else a=new i(e.length),c=0;a.set(gt(r,e),c),t.enqueue(a)},flush(){}})}}function dt(e,t){const r=new i(t.length);for(let a=0;a<t.length;a++)r[a]=yt(e)^t[a],G(e,r[a]);return r}function gt(e,t){const r=new i(t.length);for(let a=0;a<t.length;a++)r[a]=yt(e)^t[a],G(e,t[a]);return r}function wt(e,t){e.keys=[305419896,591751049,878082192],e.crcKey0=new S(e.keys[0]),e.crcKey2=new S(e.keys[2]);for(let r=0;r<t.length;r++)G(e,t.charCodeAt(r))}function G(e,t){e.crcKey0.append([t]),e.keys[0]=~e.crcKey0.get(),e.keys[1]=mt(e.keys[1]+_t(e.keys[0])),e.keys[1]=mt(r.imul(e.keys[1],134775813)+1),e.crcKey2.append([e.keys[1]>>>24]),e.keys[2]=~e.crcKey2.get()}function yt(e){const t=2|e.keys[2];return _t(r.imul(t,1^t)>>>8)}function _t(e){return 255&e}function mt(e){return 4294967295&e}class oe extends w{constructor(e,t){let r;super({start(){r=new e(t)},transform(e,t){e=r.append(e),t.enqueue(e)},flush(e){const t=r.flush();t&&e.enqueue(t)}})}}const ce="Invalid signature",le="deflate-raw",he="undefined",ue=typeof m==he,pe=typeof b==he;let fe=!0,de=!0;class ge extends w{constructor(e,t,{chunkSize:r},...a){super({},...a);const{compressed:i,encrypted:c,useCompressionStream:l,password:h,passwordVerification:p,encryptionStrength:f,zipCrypto:d,signed:g,level:w}=t,y=this;let _,b,v=Tt(super.readable);if(c&&!d||!g||([v,_]=v.tee(),_=_.pipeThrough(new z)),i)if(void 0!==l&&!l||ue&&!de)v=E(e,v,{chunkSize:r,level:w});else try{v=v.pipeThrough(new m(le))}catch{de=!1,v=E(e,v,{chunkSize:r,level:w})}c&&(d?v=v.pipeThrough(new ie(h,p)):(b=new re(h,f),v=v.pipeThrough(b))),Ct(y,v,(async()=>{let e;c&&!d&&(e=b.signature),c&&!d||!g||(e=await _.getReader().read(),e=new u(e.value.buffer).getUint32(0)),y.signature=e}))}}class we extends w{constructor(e,t,{chunkSize:r},...i){super({},...i);const{zipCrypto:c,encrypted:l,password:h,passwordVerification:p,signed:f,encryptionStrength:d,compressed:g,useCompressionStream:w}=t;let y,_,m=Tt(super.readable);if(l&&(c?m=m.pipeThrough(new ae(h,p)):(_=new se(h,f,d),m=m.pipeThrough(_))),g)if(void 0!==w&&!w||pe&&!fe)m=E(e,m,{chunkSize:r});else try{m=m.pipeThrough(new b(le))}catch{fe=!1,m=E(e,m,{chunkSize:r})}l&&!c||!f||([m,y]=m.tee(),y=y.pipeThrough(new z)),Ct(this,m,(async()=>{if(l&&!c&&!_.valid)throw new a(ce);if((!l||c)&&f){const e=await y.getReader().read(),r=new u(e.value.buffer);if(t.signature!=r.getUint32(0,!1))throw new a(ce)}}))}}function E(e,t,r){return t.pipeThrough(new oe(e,r))}function Tt(e){return e.pipeThrough(new w({transform(e,t){e&&e.length&&t.enqueue(e)}}))}function Ct(e,r,a){e.size=0,r=r.pipeThrough(new w({transform(t,r){t&&t.length&&(e.size+=t.length,r.enqueue(t))},flush:a})),t.defineProperty(e,"readable",{get:()=>r})}const ye="deflate",_e="inflate",me="data";class ke{constructor(e,t,r,a,i){const{codecType:c}=a;async function o(c){const l=new c(e,a,i);await t.pipeThrough(l).pipeTo(r,{preventClose:!0});const{size:h,signature:u}=l;return{size:h,signature:u}}c.startsWith(ye)?this.run=()=>o(ge):c.startsWith(_e)&&(this.run=()=>o(we))}}const be=new Map;let ve,Se=0;async function Qt(e){try{const{options:t,scripts:r,config:a}=e,{codecType:i}=t;let c;r&&r.length&&importScripts.apply(void 0,r),self.initCodec&&self.initCodec(),i.startsWith(ye)?c=self.Deflate:i.startsWith(_e)&&(c=self.Inflate);const l={highWaterMark:1,size:()=>a.chunkSize},h=new y({async pull(e){let t=new p(((e,t)=>be.set(Se,{resolve:e,reject:t})));J({type:"pull",messageId:Se}),Se=(Se+1)%Number.MAX_SAFE_INTEGER;const{value:r,done:a}=await t;e.enqueue(r),a&&e.close()}},l),u=new _({write(e){J({type:me,data:e})}},l);ve=new ke(c,h,u,t,a),J({type:"close",result:await ve.run()})}catch(e){const{message:t,stack:r}=e;g({error:{message:t,stack:r}})}}function J(e){if(e.data){let{data:t}=e;if(t&&t.length)try{t=new i(t),e.data=t.buffer,g(e,[e.data])}catch{g(e)}else g(e)}else g(e)}function qt(e,r,a){return class{constructor(c){const l=this;t.hasOwn(c,"level")&&void 0===c.level&&delete c.level,l.codec=new e(t.assign({},r,c)),a(l.codec,(e=>{if(l.pendingData){const{pendingData:t}=l;l.pendingData=new i(t.length+e.length),t.set(t,0),t.set(e,t.length)}else l.pendingData=new i(e)}))}append(e){return this.codec.push(e),s(this)}flush(){return this.codec.push(new i,!0),s(this)}};function s(e){if(e.pendingData){const t=e.pendingData;return e.pendingData=null,t}return new i}}addEventListener("message",(async e=>{const t=e.data,{type:r,messageId:a,data:c,done:l}=t;try{if("start"==r&&Qt(t),r==me){const{resolve:e}=be.get(a);be.delete(a),e({value:new i(c),done:l})}}catch(e){g({error:{message:e.message,stack:e.stack}})}})),self.initCodec=()=>{const{Deflate:e,Inflate:t}=((e,t={},r)=>({Deflate:qt(e.Deflate,t.deflate,r),Inflate:qt(e.Inflate,t.inflate,r)}))(pako,{deflate:{raw:!0},inflate:{raw:!0}},((e,t)=>e.onData=t));self.Deflate=e,self.Inflate=t}}();