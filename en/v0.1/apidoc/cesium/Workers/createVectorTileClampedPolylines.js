define(["./AttributeCompression-48e336db","./Matrix3-81054f0f","./combine-0c102d93","./IndexDatatype-d3db4e7d","./Math-2ce22ee9","./Matrix2-413c4048","./createTaskProcessorWorker","./ComponentDatatype-ab629b88","./defaultValue-f6d5e6da","./WebGLConstants-7f557f93","./RuntimeError-9b4ce3fb"],(function(t,e,a,s,n,r,i,o,d,c,l){"use strict";const f=32767,u=Math.cos(n.CesiumMath.toRadians(150)),h=new e.Cartographic,C=new e.Cartesian3,p=new e.Cartographic,m=new e.Cartographic;function A(t){const e=8*t,a=3*e,n=4*e;this.startEllipsoidNormals=new Float32Array(a),this.endEllipsoidNormals=new Float32Array(a),this.startPositionAndHeights=new Float32Array(n),this.startFaceNormalAndVertexCornerIds=new Float32Array(n),this.endPositionAndHeights=new Float32Array(n),this.endFaceNormalAndHalfWidths=new Float32Array(n),this.vertexBatchIds=new Uint16Array(e),this.indices=s.IndexDatatype.createTypedArray(e,36*t),this.vec3Offset=0,this.vec4Offset=0,this.batchIdOffset=0,this.indexOffset=0,this.volumeStartIndex=0}const b=new e.Cartesian3,w=new e.Cartesian3;function g(t,a,s,n,r){const i=e.Cartesian3.subtract(s,a,w);let o=e.Cartesian3.subtract(a,t,b);return e.Cartesian3.normalize(i,i),e.Cartesian3.normalize(o,o),e.Cartesian3.dot(i,o)<u&&(o=e.Cartesian3.multiplyByScalar(o,-1,b)),e.Cartesian3.add(i,o,r),e.Cartesian3.equals(r,e.Cartesian3.ZERO)&&(r=e.Cartesian3.subtract(t,a)),e.Cartesian3.cross(r,n,r),e.Cartesian3.cross(n,r,r),e.Cartesian3.normalize(r,r),r}const y=[0,2,6,0,6,4,0,1,3,0,3,2,0,4,5,0,5,1,5,3,1,5,7,3,7,5,4,7,4,6,7,6,2,7,2,3],N=y.length,k=new e.Cartesian3,x=new e.Cartesian3,I=new e.Cartesian3,E=new e.Cartesian3,F=new e.Cartesian3;A.prototype.addVolume=function(t,a,s,n,r,i,o,d,c,l){let f=e.Cartesian3.add(a,c,k);const u=l.geodeticSurfaceNormal(f,x);f=e.Cartesian3.add(s,c,k);const h=l.geodeticSurfaceNormal(f,E),C=g(t,a,s,u,I),p=g(n,s,a,h,F),m=this.startEllipsoidNormals,b=this.endEllipsoidNormals,w=this.startPositionAndHeights,H=this.startFaceNormalAndVertexCornerIds,O=this.endPositionAndHeights,P=this.endFaceNormalAndHalfWidths,v=this.vertexBatchIds;let D,M=this.batchIdOffset,S=this.vec3Offset,R=this.vec4Offset;for(D=0;D<8;D++)e.Cartesian3.pack(u,m,S),e.Cartesian3.pack(h,b,S),e.Cartesian3.pack(a,w,R),w[R+3]=r,e.Cartesian3.pack(s,O,R),O[R+3]=i,e.Cartesian3.pack(C,H,R),H[R+3]=D,e.Cartesian3.pack(p,P,R),P[R+3]=o,v[M++]=d,S+=3,R+=4;this.batchIdOffset=M,this.vec3Offset=S,this.vec4Offset=R;const U=this.indices,B=this.volumeStartIndex,V=this.indexOffset;for(D=0;D<N;D++)U[V+D]=y[D]+B;this.volumeStartIndex+=8,this.indexOffset+=N};const H=new r.Rectangle,O=new e.Ellipsoid,P=new e.Cartesian3,v=new e.Cartesian3,D=new e.Cartesian3,M=new e.Cartesian3,S=new e.Cartesian3;return i((function(i,o){const d=new Uint16Array(i.positions),c=new Uint16Array(i.widths),l=new Uint32Array(i.counts),u=new Uint16Array(i.batchIds),b=H,w=O,y=P,N=new Float64Array(i.packedBuffer);let k=0;const x=N[k++],I=N[k++];let E;r.Rectangle.unpack(N,k,b),k+=r.Rectangle.packedLength,e.Ellipsoid.unpack(N,k,w),k+=e.Ellipsoid.packedLength,e.Cartesian3.unpack(N,k,y);let F=d.length/3;const R=d.subarray(0,F),U=d.subarray(F,2*F),B=d.subarray(2*F,3*F);t.AttributeCompression.zigZagDeltaDecode(R,U,B),function(t,a,s,n){const r=n.length,i=t.length,o=new Uint8Array(i),d=p,c=m;let l=0;for(let s=0;s<r;s++){const r=n[s];let i=r;for(let s=1;s<r;s++){const n=l+s,r=n-1;c.longitude=t[n],c.latitude=a[n],d.longitude=t[r],d.latitude=a[r],e.Cartographic.equals(c,d)&&(i--,o[r]=1)}n[s]=i,l+=r}let f=0;for(let e=0;e<i;e++)1!==o[e]&&(t[f]=t[e],a[f]=a[e],s[f]=s[e],f++)}(R,U,B,l);const V=l.length;let T=0;for(E=0;E<V;E++)T+=l[E]-1;const W=new A(T),z=function(t,a,s,r,i,o,d){const c=t.length,l=new Float64Array(3*c);for(let u=0;u<c;++u){const c=t[u],p=a[u],m=s[u],b=n.CesiumMath.lerp(r.west,r.east,c/f),w=n.CesiumMath.lerp(r.south,r.north,p/f),y=n.CesiumMath.lerp(i,o,m/f),N=e.Cartographic.fromRadians(b,w,y,h),k=d.cartographicToCartesian(N,C);e.Cartesian3.pack(k,l,3*u)}return l}(R,U,B,b,x,I,w);F=R.length;const q=new Float32Array(3*F);for(E=0;E<F;++E)q[3*E]=z[3*E]-y.x,q[3*E+1]=z[3*E+1]-y.y,q[3*E+2]=z[3*E+2]-y.z;let L=0,_=0;for(E=0;E<V;E++){const t=l[E]-1,a=.5*c[E],s=u[E],r=L;for(let i=0;i<t;i++){const o=e.Cartesian3.unpack(q,L,D),d=e.Cartesian3.unpack(q,L+3,M);let c=B[_],l=B[_+1];c=n.CesiumMath.lerp(x,I,c/f),l=n.CesiumMath.lerp(x,I,l/f),_++;let u=v,h=S;if(0===i){const a=r+3*t,s=e.Cartesian3.unpack(q,a,v);if(e.Cartesian3.equals(s,o))e.Cartesian3.unpack(q,a-3,u);else{const t=e.Cartesian3.subtract(o,d,v);u=e.Cartesian3.add(t,o,v)}}else e.Cartesian3.unpack(q,L-3,u);if(i===t-1){const t=e.Cartesian3.unpack(q,r,S);if(e.Cartesian3.equals(t,d))e.Cartesian3.unpack(q,r+3,h);else{const t=e.Cartesian3.subtract(d,o,S);h=e.Cartesian3.add(t,d,S)}}else e.Cartesian3.unpack(q,L+6,h);W.addVolume(u,o,d,h,c,l,a,s,y,w),L+=3}L+=3,_++}const G=W.indices;o.push(W.startEllipsoidNormals.buffer),o.push(W.endEllipsoidNormals.buffer),o.push(W.startPositionAndHeights.buffer),o.push(W.startFaceNormalAndVertexCornerIds.buffer),o.push(W.endPositionAndHeights.buffer),o.push(W.endFaceNormalAndHalfWidths.buffer),o.push(W.vertexBatchIds.buffer),o.push(G.buffer);let Z={indexDatatype:2===G.BYTES_PER_ELEMENT?s.IndexDatatype.UNSIGNED_SHORT:s.IndexDatatype.UNSIGNED_INT,startEllipsoidNormals:W.startEllipsoidNormals.buffer,endEllipsoidNormals:W.endEllipsoidNormals.buffer,startPositionAndHeights:W.startPositionAndHeights.buffer,startFaceNormalAndVertexCornerIds:W.startFaceNormalAndVertexCornerIds.buffer,endPositionAndHeights:W.endPositionAndHeights.buffer,endFaceNormalAndHalfWidths:W.endFaceNormalAndHalfWidths.buffer,vertexBatchIds:W.vertexBatchIds.buffer,indices:G.buffer};if(i.keepDecodedPositions){const t=function(t){const e=t.length,a=new Uint32Array(e+1);let s=0;for(let n=0;n<e;++n)a[n]=s,s+=t[n];return a[e]=s,a}(l);o.push(z.buffer,t.buffer),Z=a.combine(Z,{decodedPositions:z.buffer,decodedPositionOffsets:t.buffer})}return Z}))}));