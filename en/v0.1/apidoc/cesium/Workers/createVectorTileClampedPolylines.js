/*! For license information please see createVectorTileClampedPolylines.js.LICENSE.txt */
define(["./AttributeCompression-b8c8fcdc","./Matrix2-21f90abf","./combine-fc59ba59","./IndexDatatype-20e78e57","./ComponentDatatype-4028c72d","./createTaskProcessorWorker","./RuntimeError-cef79f54","./defaultValue-4607806f","./WebGLConstants-f100e3dd"],(function(t,e,a,s,n,r,i,o,c){"use strict";const d=32767,l=Math.cos(n.CesiumMath.toRadians(150)),f=new e.Cartographic,u=new e.Cartesian3,h=new e.Cartographic,C=new e.Cartographic;function p(t){const e=8*t,a=3*e,n=4*e;this.startEllipsoidNormals=new Float32Array(a),this.endEllipsoidNormals=new Float32Array(a),this.startPositionAndHeights=new Float32Array(n),this.startFaceNormalAndVertexCornerIds=new Float32Array(n),this.endPositionAndHeights=new Float32Array(n),this.endFaceNormalAndHalfWidths=new Float32Array(n),this.vertexBatchIds=new Uint16Array(e),this.indices=s.IndexDatatype.createTypedArray(e,36*t),this.vec3Offset=0,this.vec4Offset=0,this.batchIdOffset=0,this.indexOffset=0,this.volumeStartIndex=0}const m=new e.Cartesian3,b=new e.Cartesian3;function A(t,a,s,n,r){const i=e.Cartesian3.subtract(s,a,b);let o=e.Cartesian3.subtract(a,t,m);return e.Cartesian3.normalize(i,i),e.Cartesian3.normalize(o,o),e.Cartesian3.dot(i,o)<l&&(o=e.Cartesian3.multiplyByScalar(o,-1,m)),e.Cartesian3.add(i,o,r),e.Cartesian3.equals(r,e.Cartesian3.ZERO)&&(r=e.Cartesian3.subtract(t,a)),e.Cartesian3.cross(r,n,r),e.Cartesian3.cross(n,r,r),e.Cartesian3.normalize(r,r),r}const w=[0,2,6,0,6,4,0,1,3,0,3,2,0,4,5,0,5,1,5,3,1,5,7,3,7,5,4,7,4,6,7,6,2,7,2,3],g=w.length,y=new e.Cartesian3,N=new e.Cartesian3,k=new e.Cartesian3,I=new e.Cartesian3,x=new e.Cartesian3;p.prototype.addVolume=function(t,a,s,n,r,i,o,c,d,l){let f=e.Cartesian3.add(a,d,y);const u=l.geodeticSurfaceNormal(f,N);f=e.Cartesian3.add(s,d,y);const h=l.geodeticSurfaceNormal(f,I),C=A(t,a,s,u,k),m=A(n,s,a,h,x),b=this.startEllipsoidNormals,E=this.endEllipsoidNormals,F=this.startPositionAndHeights,H=this.startFaceNormalAndVertexCornerIds,O=this.endPositionAndHeights,P=this.endFaceNormalAndHalfWidths,v=this.vertexBatchIds;let D,S=this.batchIdOffset,M=this.vec3Offset,R=this.vec4Offset;for(D=0;D<8;D++)e.Cartesian3.pack(u,b,M),e.Cartesian3.pack(h,E,M),e.Cartesian3.pack(a,F,R),F[R+3]=r,e.Cartesian3.pack(s,O,R),O[R+3]=i,e.Cartesian3.pack(C,H,R),H[R+3]=D,e.Cartesian3.pack(m,P,R),P[R+3]=o,v[S++]=c,M+=3,R+=4;this.batchIdOffset=S,this.vec3Offset=M,this.vec4Offset=R;const U=this.indices,B=this.volumeStartIndex,V=this.indexOffset;for(D=0;D<g;D++)U[V+D]=w[D]+B;this.volumeStartIndex+=8,this.indexOffset+=g};const E=new e.Rectangle,F=new e.Ellipsoid,H=new e.Cartesian3,O=new e.Cartesian3,P=new e.Cartesian3,v=new e.Cartesian3,D=new e.Cartesian3;return r((function(r,i){const o=new Uint16Array(r.positions),c=new Uint16Array(r.widths),l=new Uint32Array(r.counts),m=new Uint16Array(r.batchIds),b=E,w=F,g=H,y=new Float64Array(r.packedBuffer);let N=0;const k=y[N++],I=y[N++];let x;e.Rectangle.unpack(y,N,b),N+=e.Rectangle.packedLength,e.Ellipsoid.unpack(y,N,w),N+=e.Ellipsoid.packedLength,e.Cartesian3.unpack(y,N,g);let S=o.length/3;const M=o.subarray(0,S),R=o.subarray(S,2*S),U=o.subarray(2*S,3*S);t.AttributeCompression.zigZagDeltaDecode(M,R,U),function(t,a,s,n){const r=n.length,i=t.length,o=new Uint8Array(i),c=h,d=C;let l=0;for(let s=0;s<r;s++){const r=n[s];let i=r;for(let s=1;s<r;s++){const n=l+s,r=n-1;d.longitude=t[n],d.latitude=a[n],c.longitude=t[r],c.latitude=a[r],e.Cartographic.equals(d,c)&&(i--,o[r]=1)}n[s]=i,l+=r}let f=0;for(let e=0;e<i;e++)1!==o[e]&&(t[f]=t[e],a[f]=a[e],s[f]=s[e],f++)}(M,R,U,l);const B=l.length;let V=0;for(x=0;x<B;x++)V+=l[x]-1;const T=new p(V),W=function(t,a,s,r,i,o,c){const l=t.length,h=new Float64Array(3*l);for(let C=0;C<l;++C){const l=t[C],m=a[C],b=s[C],w=n.CesiumMath.lerp(r.west,r.east,l/d),g=n.CesiumMath.lerp(r.south,r.north,m/d),y=n.CesiumMath.lerp(i,o,b/d),N=e.Cartographic.fromRadians(w,g,y,f),k=c.cartographicToCartesian(N,u);e.Cartesian3.pack(k,h,3*C)}return h}(M,R,U,b,k,I,w);S=M.length;const z=new Float32Array(3*S);for(x=0;x<S;++x)z[3*x]=W[3*x]-g.x,z[3*x+1]=W[3*x+1]-g.y,z[3*x+2]=W[3*x+2]-g.z;let q=0,L=0;for(x=0;x<B;x++){const t=l[x]-1,a=.5*c[x],s=m[x],r=q;for(let i=0;i<t;i++){const o=e.Cartesian3.unpack(z,q,P),c=e.Cartesian3.unpack(z,q+3,v);let l=U[L],f=U[L+1];l=n.CesiumMath.lerp(k,I,l/d),f=n.CesiumMath.lerp(k,I,f/d),L++;let u=O,h=D;if(0===i){const a=r+3*t,s=e.Cartesian3.unpack(z,a,O);if(e.Cartesian3.equals(s,o))e.Cartesian3.unpack(z,a-3,u);else{const t=e.Cartesian3.subtract(o,c,O);u=e.Cartesian3.add(t,o,O)}}else e.Cartesian3.unpack(z,q-3,u);if(i===t-1){const t=e.Cartesian3.unpack(z,r,D);if(e.Cartesian3.equals(t,c))e.Cartesian3.unpack(z,r+3,h);else{const t=e.Cartesian3.subtract(c,o,D);h=e.Cartesian3.add(t,c,D)}}else e.Cartesian3.unpack(z,q+6,h);T.addVolume(u,o,c,h,l,f,a,s,g,w),q+=3}q+=3,L++}const _=T.indices;i.push(T.startEllipsoidNormals.buffer),i.push(T.endEllipsoidNormals.buffer),i.push(T.startPositionAndHeights.buffer),i.push(T.startFaceNormalAndVertexCornerIds.buffer),i.push(T.endPositionAndHeights.buffer),i.push(T.endFaceNormalAndHalfWidths.buffer),i.push(T.vertexBatchIds.buffer),i.push(_.buffer);let G={indexDatatype:2===_.BYTES_PER_ELEMENT?s.IndexDatatype.UNSIGNED_SHORT:s.IndexDatatype.UNSIGNED_INT,startEllipsoidNormals:T.startEllipsoidNormals.buffer,endEllipsoidNormals:T.endEllipsoidNormals.buffer,startPositionAndHeights:T.startPositionAndHeights.buffer,startFaceNormalAndVertexCornerIds:T.startFaceNormalAndVertexCornerIds.buffer,endPositionAndHeights:T.endPositionAndHeights.buffer,endFaceNormalAndHalfWidths:T.endFaceNormalAndHalfWidths.buffer,vertexBatchIds:T.vertexBatchIds.buffer,indices:_.buffer};if(r.keepDecodedPositions){const t=function(t){const e=t.length,a=new Uint32Array(e+1);let s=0;for(let n=0;n<e;++n)a[n]=s,s+=t[n];return a[e]=s,a}(l);i.push(W.buffer,t.buffer),G=a.combine(G,{decodedPositions:W.buffer,decodedPositionOffsets:t.buffer})}return G}))}));