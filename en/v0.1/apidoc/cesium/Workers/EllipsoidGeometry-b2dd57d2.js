/*! For license information please see EllipsoidGeometry-b2dd57d2.js.LICENSE.txt */
define(["exports","./Transforms-c450597e","./Matrix2-21f90abf","./ComponentDatatype-4028c72d","./defaultValue-4607806f","./RuntimeError-cef79f54","./GeometryAttribute-3c090c07","./GeometryAttributes-acac33d2","./GeometryOffsetAttribute-3e5f3e97","./IndexDatatype-20e78e57","./VertexFormat-75e8069c"],(function(t,e,a,n,i,r,o,s,m,u,c){"use strict";const l=new a.Cartesian3,f=new a.Cartesian3,d=new a.Cartesian3,C=new a.Cartesian3,p=new a.Cartesian3,y=new a.Cartesian3(1,1,1),_=Math.cos,h=Math.sin;function x(t){t=i.defaultValue(t,i.defaultValue.EMPTY_OBJECT);const e=i.defaultValue(t.radii,y),r=i.defaultValue(t.innerRadii,e),o=i.defaultValue(t.minimumClock,0),s=i.defaultValue(t.maximumClock,n.CesiumMath.TWO_PI),m=i.defaultValue(t.minimumCone,0),u=i.defaultValue(t.maximumCone,n.CesiumMath.PI),l=Math.round(i.defaultValue(t.stackPartitions,64)),f=Math.round(i.defaultValue(t.slicePartitions,64)),d=i.defaultValue(t.vertexFormat,c.VertexFormat.DEFAULT);this._radii=a.Cartesian3.clone(e),this._innerRadii=a.Cartesian3.clone(r),this._minimumClock=o,this._maximumClock=s,this._minimumCone=m,this._maximumCone=u,this._stackPartitions=l,this._slicePartitions=f,this._vertexFormat=c.VertexFormat.clone(d),this._offsetAttribute=t.offsetAttribute,this._workerName="createEllipsoidGeometry"}x.packedLength=2*a.Cartesian3.packedLength+c.VertexFormat.packedLength+7,x.pack=function(t,e,n){return n=i.defaultValue(n,0),a.Cartesian3.pack(t._radii,e,n),n+=a.Cartesian3.packedLength,a.Cartesian3.pack(t._innerRadii,e,n),n+=a.Cartesian3.packedLength,c.VertexFormat.pack(t._vertexFormat,e,n),n+=c.VertexFormat.packedLength,e[n++]=t._minimumClock,e[n++]=t._maximumClock,e[n++]=t._minimumCone,e[n++]=t._maximumCone,e[n++]=t._stackPartitions,e[n++]=t._slicePartitions,e[n]=i.defaultValue(t._offsetAttribute,-1),e};const A=new a.Cartesian3,k=new a.Cartesian3,b=new c.VertexFormat,w={radii:A,innerRadii:k,vertexFormat:b,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,offsetAttribute:void 0};let P;x.unpack=function(t,e,n){e=i.defaultValue(e,0);const r=a.Cartesian3.unpack(t,e,A);e+=a.Cartesian3.packedLength;const o=a.Cartesian3.unpack(t,e,k);e+=a.Cartesian3.packedLength;const s=c.VertexFormat.unpack(t,e,b);e+=c.VertexFormat.packedLength;const m=t[e++],u=t[e++],l=t[e++],f=t[e++],d=t[e++],C=t[e++],p=t[e];return i.defined(n)?(n._radii=a.Cartesian3.clone(r,n._radii),n._innerRadii=a.Cartesian3.clone(o,n._innerRadii),n._vertexFormat=c.VertexFormat.clone(s,n._vertexFormat),n._minimumClock=m,n._maximumClock=u,n._minimumCone=l,n._maximumCone=f,n._stackPartitions=d,n._slicePartitions=C,n._offsetAttribute=-1===p?void 0:p,n):(w.minimumClock=m,w.maximumClock=u,w.minimumCone=l,w.maximumCone=f,w.stackPartitions=d,w.slicePartitions=C,w.offsetAttribute=-1===p?void 0:p,new x(w))},x.createGeometry=function(t){const r=t._radii;if(r.x<=0||r.y<=0||r.z<=0)return;const c=t._innerRadii;if(c.x<=0||c.y<=0||c.z<=0)return;const y=t._minimumClock,A=t._maximumClock,k=t._minimumCone,b=t._maximumCone,w=t._vertexFormat;let P,g,v=t._slicePartitions+1,F=t._stackPartitions+1;v=Math.round(v*Math.abs(A-y)/n.CesiumMath.TWO_PI),F=Math.round(F*Math.abs(b-k)/n.CesiumMath.PI),v<2&&(v=2),F<2&&(F=2);let V=0;const M=[k],T=[y];for(P=0;P<F;P++)M.push(k+P*(b-k)/(F-1));for(M.push(b),g=0;g<v;g++)T.push(y+g*(A-y)/(v-1));T.push(A);const D=M.length,G=T.length;let L=0,O=1;const I=c.x!==r.x||c.y!==r.y||c.z!==r.z;let E=!1,z=!1,N=!1;I&&(O=2,k>0&&(E=!0,L+=v-1),b<Math.PI&&(z=!0,L+=v-1),(A-y)%n.CesiumMath.TWO_PI?(N=!0,L+=2*(F-1)+1):L+=1);const R=G*D*O,U=new Float64Array(3*R),S=new Array(R).fill(!1),B=new Array(R).fill(!1),W=v*F*O,Y=6*(W+L+1-(v+F)*O),J=u.IndexDatatype.createTypedArray(W,Y),X=w.normal?new Float32Array(3*R):void 0,Z=w.tangent?new Float32Array(3*R):void 0,j=w.bitangent?new Float32Array(3*R):void 0,q=w.st?new Float32Array(2*R):void 0,H=new Array(D),K=new Array(D);for(P=0;P<D;P++)H[P]=h(M[P]),K[P]=_(M[P]);const Q=new Array(G),$=new Array(G);for(g=0;g<G;g++)$[g]=_(T[g]),Q[g]=h(T[g]);for(P=0;P<D;P++)for(g=0;g<G;g++)U[V++]=r.x*H[P]*$[g],U[V++]=r.y*H[P]*Q[g],U[V++]=r.z*K[P];let tt,et,at,nt,it=R/2;if(I)for(P=0;P<D;P++)for(g=0;g<G;g++)U[V++]=c.x*H[P]*$[g],U[V++]=c.y*H[P]*Q[g],U[V++]=c.z*K[P],S[it]=!0,P>0&&P!==D-1&&0!==g&&g!==G-1&&(B[it]=!0),it++;for(V=0,P=1;P<D-2;P++)for(tt=P*G,et=(P+1)*G,g=1;g<G-2;g++)J[V++]=et+g,J[V++]=et+g+1,J[V++]=tt+g+1,J[V++]=et+g,J[V++]=tt+g+1,J[V++]=tt+g;if(I){const t=D*G;for(P=1;P<D-2;P++)for(tt=t+P*G,et=t+(P+1)*G,g=1;g<G-2;g++)J[V++]=et+g,J[V++]=tt+g,J[V++]=tt+g+1,J[V++]=et+g,J[V++]=tt+g+1,J[V++]=et+g+1}if(I){if(E)for(nt=D*G,P=1;P<G-2;P++)J[V++]=P,J[V++]=P+1,J[V++]=nt+P+1,J[V++]=P,J[V++]=nt+P+1,J[V++]=nt+P;if(z)for(at=D*G-G,nt=D*G*O-G,P=1;P<G-2;P++)J[V++]=at+P+1,J[V++]=at+P,J[V++]=nt+P,J[V++]=at+P+1,J[V++]=nt+P,J[V++]=nt+P+1}if(N){for(P=1;P<D-2;P++)nt=G*D+G*P,at=G*P,J[V++]=nt,J[V++]=at+G,J[V++]=at,J[V++]=nt,J[V++]=nt+G,J[V++]=at+G;for(P=1;P<D-2;P++)nt=G*D+G*(P+1)-1,at=G*(P+1)-1,J[V++]=at+G,J[V++]=nt,J[V++]=at,J[V++]=at+G,J[V++]=nt+G,J[V++]=nt}const rt=new s.GeometryAttributes;w.position&&(rt.position=new o.GeometryAttribute({componentDatatype:n.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:U}));let ot=0,st=0,mt=0,ut=0;const ct=R/2;let lt;const ft=a.Ellipsoid.fromCartesian3(r),dt=a.Ellipsoid.fromCartesian3(c);if(w.st||w.normal||w.tangent||w.bitangent){for(P=0;P<R;P++){lt=S[P]?dt:ft;const t=a.Cartesian3.fromArray(U,3*P,l),e=lt.geodeticSurfaceNormal(t,f);if(B[P]&&a.Cartesian3.negate(e,e),w.st){const t=a.Cartesian2.negate(e,p);q[ot++]=Math.atan2(t.y,t.x)/n.CesiumMath.TWO_PI+.5,q[ot++]=Math.asin(e.z)/Math.PI+.5}if(w.normal&&(X[st++]=e.x,X[st++]=e.y,X[st++]=e.z),w.tangent||w.bitangent){const t=d;let n,i=0;if(S[P]&&(i=ct),n=!E&&P>=i&&P<i+2*G?a.Cartesian3.UNIT_X:a.Cartesian3.UNIT_Z,a.Cartesian3.cross(n,e,t),a.Cartesian3.normalize(t,t),w.tangent&&(Z[mt++]=t.x,Z[mt++]=t.y,Z[mt++]=t.z),w.bitangent){const n=a.Cartesian3.cross(e,t,C);a.Cartesian3.normalize(n,n),j[ut++]=n.x,j[ut++]=n.y,j[ut++]=n.z}}}w.st&&(rt.st=new o.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:q})),w.normal&&(rt.normal=new o.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:X})),w.tangent&&(rt.tangent=new o.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:Z})),w.bitangent&&(rt.bitangent=new o.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:j}))}if(i.defined(t._offsetAttribute)){const e=U.length,a=t._offsetAttribute===m.GeometryOffsetAttribute.NONE?0:1,i=new Uint8Array(e/3).fill(a);rt.applyOffset=new o.GeometryAttribute({componentDatatype:n.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}return new o.Geometry({attributes:rt,indices:J,primitiveType:o.PrimitiveType.TRIANGLES,boundingSphere:e.BoundingSphere.fromEllipsoid(ft),offsetAttribute:t._offsetAttribute})},x.getUnitEllipsoid=function(){return i.defined(P)||(P=x.createGeometry(new x({radii:new a.Cartesian3(1,1,1),vertexFormat:c.VertexFormat.POSITION_ONLY}))),P},t.EllipsoidGeometry=x}));