define(["exports","./ArcType-26a3f38d","./arrayRemoveDuplicates-9b636830","./Matrix2-413c4048","./Matrix3-81054f0f","./ComponentDatatype-ab629b88","./defaultValue-f6d5e6da","./EllipsoidRhumbLine-77eff028","./GeometryAttribute-b8117bde","./GeometryAttributes-1e4ddcd2","./GeometryPipeline-fcaf4d4d","./IndexDatatype-d3db4e7d","./Math-2ce22ee9","./PolygonPipeline-621b1cb0","./Transforms-20461479"],(function(e,t,n,i,o,r,a,s,c,l,u,h,d,p,f){"use strict";function y(){this._array=[],this._offset=0,this._length=0}Object.defineProperties(y.prototype,{length:{get:function(){return this._length}}}),y.prototype.enqueue=function(e){this._array.push(e),this._length++},y.prototype.dequeue=function(){if(0===this._length)return;const e=this._array;let t=this._offset;const n=e[t];return e[t]=void 0,t++,t>10&&2*t>e.length&&(this._array=e.slice(t),t=0),this._offset=t,this._length--,n},y.prototype.peek=function(){if(0!==this._length)return this._array[this._offset]},y.prototype.contains=function(e){return-1!==this._array.indexOf(e)},y.prototype.clear=function(){this._array.length=this._offset=this._length=0},y.prototype.sort=function(e){this._offset>0&&(this._array=this._array.slice(this._offset),this._offset=0),this._array.sort(e)};const g={computeHierarchyPackedLength:function(e,t){let n=0;const i=[e];for(;i.length>0;){const e=i.pop();if(!a.defined(e))continue;n+=2;const o=e.positions,r=e.holes;if(a.defined(o)&&o.length>0&&(n+=o.length*t.packedLength),a.defined(r)){const e=r.length;for(let t=0;t<e;++t)i.push(r[t])}}return n},packPolygonHierarchy:function(e,t,n,i){const o=[e];for(;o.length>0;){const e=o.pop();if(!a.defined(e))continue;const r=e.positions,s=e.holes;if(t[n++]=a.defined(r)?r.length:0,t[n++]=a.defined(s)?s.length:0,a.defined(r)){const e=r.length;for(let o=0;o<e;++o,n+=i.packedLength)i.pack(r[o],t,n)}if(a.defined(s)){const e=s.length;for(let t=0;t<e;++t)o.push(s[t])}}return n},unpackPolygonHierarchy:function(e,t,n){const i=e[t++],o=e[t++],r=new Array(i),a=o>0?new Array(o):void 0;for(let o=0;o<i;++o,t+=n.packedLength)r[o]=n.unpack(e,t);for(let i=0;i<o;++i)a[i]=g.unpackPolygonHierarchy(e,t,n),t=a[i].startingIndex,delete a[i].startingIndex;return{positions:r,holes:a,startingIndex:t}}},m=new i.Cartesian2;function C(e,t,n,o){return i.Cartesian2.subtract(t,e,m),i.Cartesian2.multiplyByScalar(m,n/o,m),i.Cartesian2.add(e,m,m),[m.x,m.y]}const b=new o.Cartesian3;function x(e,t,n,i){return o.Cartesian3.subtract(t,e,b),o.Cartesian3.multiplyByScalar(b,n/i,b),o.Cartesian3.add(e,b,b),[b.x,b.y,b.z]}g.subdivideLineCount=function(e,t,n){const i=o.Cartesian3.distance(e,t)/n,r=Math.max(0,Math.ceil(d.CesiumMath.log2(i)));return Math.pow(2,r)};const T=new o.Cartographic,v=new o.Cartographic,w=new o.Cartographic,A=new o.Cartesian3,L=new s.EllipsoidRhumbLine;g.subdivideRhumbLineCount=function(e,t,n,i){const o=e.cartesianToCartographic(t,T),r=e.cartesianToCartographic(n,v),a=new s.EllipsoidRhumbLine(o,r,e).surfaceDistance/i,c=Math.max(0,Math.ceil(d.CesiumMath.log2(a)));return Math.pow(2,c)},g.subdivideTexcoordLine=function(e,t,n,o,r,a){const s=g.subdivideLineCount(n,o,r),c=i.Cartesian2.distance(e,t),l=c/s,u=a;u.length=2*s;let h=0;for(let n=0;n<s;n++){const i=C(e,t,n*l,c);u[h++]=i[0],u[h++]=i[1]}return u},g.subdivideLine=function(e,t,n,i){const r=g.subdivideLineCount(e,t,n),s=o.Cartesian3.distance(e,t),c=s/r;a.defined(i)||(i=[]);const l=i;l.length=3*r;let u=0;for(let n=0;n<r;n++){const i=x(e,t,n*c,s);l[u++]=i[0],l[u++]=i[1],l[u++]=i[2]}return l},g.subdivideTexcoordRhumbLine=function(e,t,n,o,r,a,s){const c=n.cartesianToCartographic(o,T),l=n.cartesianToCartographic(r,v);L.setEndPoints(c,l);const u=L.surfaceDistance/a,h=Math.max(0,Math.ceil(d.CesiumMath.log2(u))),p=Math.pow(2,h),f=i.Cartesian2.distance(e,t),g=f/p,m=s;m.length=2*p;let b=0;for(let n=0;n<p;n++){const i=C(e,t,n*g,f);m[b++]=i[0],m[b++]=i[1]}return m},g.subdivideRhumbLine=function(e,t,n,i,o){const r=e.cartesianToCartographic(t,T),c=e.cartesianToCartographic(n,v),l=new s.EllipsoidRhumbLine(r,c,e),u=l.surfaceDistance/i,h=Math.max(0,Math.ceil(d.CesiumMath.log2(u))),p=Math.pow(2,h),f=l.surfaceDistance/p;a.defined(o)||(o=[]);const g=o;g.length=3*p;let m=0;for(let t=0;t<p;t++){const n=l.interpolateUsingSurfaceDistance(t*f,w),i=e.cartographicToCartesian(n,A);g[m++]=i.x,g[m++]=i.y,g[m++]=i.z}return g};const E=new o.Cartesian3,I=new o.Cartesian3,M=new o.Cartesian3,P=new o.Cartesian3;g.scaleToGeodeticHeightExtruded=function(e,t,n,i,r){i=a.defaultValue(i,o.Ellipsoid.WGS84);const s=E;let c=I;const l=M;let u=P;if(a.defined(e)&&a.defined(e.attributes)&&a.defined(e.attributes.position)){const a=e.attributes.position.values,h=a.length/2;for(let e=0;e<h;e+=3)o.Cartesian3.fromArray(a,e,l),i.geodeticSurfaceNormal(l,s),u=i.scaleToGeodeticSurface(l,u),c=o.Cartesian3.multiplyByScalar(s,n,c),c=o.Cartesian3.add(u,c,c),a[e+h]=c.x,a[e+1+h]=c.y,a[e+2+h]=c.z,r&&(u=o.Cartesian3.clone(l,u)),c=o.Cartesian3.multiplyByScalar(s,t,c),c=o.Cartesian3.add(u,c,c),a[e]=c.x,a[e+1]=c.y,a[e+2]=c.z}return e},g.polygonOutlinesFromHierarchy=function(e,t,i){const r=[],s=new y;let c,l,u;for(s.enqueue(e);0!==s.length;){const e=s.dequeue();let h=e.positions;if(t)for(u=h.length,c=0;c<u;c++)i.scaleToGeodeticSurface(h[c],h[c]);if(h=n.arrayRemoveDuplicates(h,o.Cartesian3.equalsEpsilon,!0),h.length<3)continue;const d=e.holes?e.holes.length:0;for(c=0;c<d;c++){const h=e.holes[c];let d=h.positions;if(t)for(u=d.length,l=0;l<u;++l)i.scaleToGeodeticSurface(d[l],d[l]);if(d=n.arrayRemoveDuplicates(d,o.Cartesian3.equalsEpsilon,!0),d.length<3)continue;r.push(d);let p=0;for(a.defined(h.holes)&&(p=h.holes.length),l=0;l<p;l++)s.enqueue(h.holes[l])}r.push(h)}return r},g.polygonsFromHierarchy=function(e,t,i,r,s){const c=[],l=[],u=new y;for(u.enqueue(e);0!==u.length;){const e=u.dequeue();let h=e.positions;const d=e.holes;let f,g;if(r)for(g=h.length,f=0;f<g;f++)s.scaleToGeodeticSurface(h[f],h[f]);if(t||(h=n.arrayRemoveDuplicates(h,o.Cartesian3.equalsEpsilon,!0)),h.length<3)continue;let m=i(h);if(!a.defined(m))continue;const b=[];let T=p.PolygonPipeline.computeWindingOrder2D(m);T===p.WindingOrder.CLOCKWISE&&(m.reverse(),h=h.slice().reverse());let v=h.slice();const w=a.defined(d)?d.length:0,A=[];let L;for(f=0;f<w;f++){const e=d[f];let c=e.positions;if(r)for(g=c.length,L=0;L<g;++L)s.scaleToGeodeticSurface(c[L],c[L]);if(t||(c=n.arrayRemoveDuplicates(c,o.Cartesian3.equalsEpsilon,!0)),c.length<3)continue;const l=i(c);if(!a.defined(l))continue;T=p.PolygonPipeline.computeWindingOrder2D(l),T===p.WindingOrder.CLOCKWISE&&(l.reverse(),c=c.slice().reverse()),A.push(c),b.push(v.length),v=v.concat(c),m=m.concat(l);let h=0;for(a.defined(e.holes)&&(h=e.holes.length),L=0;L<h;L++)u.enqueue(e.holes[L])}c.push({outerRing:h,holes:A}),l.push({positions:v,positions2D:m,holes:b})}return{hierarchy:c,polygons:l}};const D=new i.Cartesian2,_=new o.Cartesian3,G=new f.Quaternion,S=new o.Matrix3;g.computeBoundingRectangle=function(e,t,n,i,r){const s=f.Quaternion.fromAxisAngle(e,i,G),c=o.Matrix3.fromQuaternion(s,S);let l=Number.POSITIVE_INFINITY,u=Number.NEGATIVE_INFINITY,h=Number.POSITIVE_INFINITY,d=Number.NEGATIVE_INFINITY;const p=n.length;for(let e=0;e<p;++e){const i=o.Cartesian3.clone(n[e],_);o.Matrix3.multiplyByVector(c,i,i);const r=t(i,D);a.defined(r)&&(l=Math.min(l,r.x),u=Math.max(u,r.x),h=Math.min(h,r.y),d=Math.max(d,r.y))}return r.x=l,r.y=h,r.width=u-l,r.height=d-h,r},g.createGeometryFromPositions=function(e,n,o,s,l,h,d){let f=p.PolygonPipeline.triangulate(n.positions2D,n.holes);f.length<3&&(f=[0,1,2]);const g=n.positions,m=a.defined(o),b=m?o.positions:void 0;if(l){const e=g.length,t=new Array(3*e);let n=0;for(let i=0;i<e;i++){const e=g[i];t[n++]=e.x,t[n++]=e.y,t[n++]=e.z}const o={attributes:{position:new c.GeometryAttribute({componentDatatype:r.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:t})},indices:f,primitiveType:c.PrimitiveType.TRIANGLES};m&&(o.attributes.st=new c.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:i.Cartesian2.packArray(b)}));const a=new c.Geometry(o);return h.normal?u.GeometryPipeline.computeNormal(a):a}return d===t.ArcType.GEODESIC?p.PolygonPipeline.computeSubdivision(e,g,f,b,s):d===t.ArcType.RHUMB?p.PolygonPipeline.computeRhumbLineSubdivision(e,g,f,b,s):void 0};const R=[],N=[],O=new o.Cartesian3,q=new o.Cartesian3;g.computeWallGeometry=function(e,n,i,s,u,p){let f,m,b,T,v,w,A,L,E,I=e.length,M=0,P=0;const D=a.defined(n),_=D?n.positions:void 0;if(u)for(m=3*I*2,f=new Array(2*m),D&&(E=2*I*2,L=new Array(2*E)),b=0;b<I;b++)T=e[b],v=e[(b+1)%I],f[M]=f[M+m]=T.x,++M,f[M]=f[M+m]=T.y,++M,f[M]=f[M+m]=T.z,++M,f[M]=f[M+m]=v.x,++M,f[M]=f[M+m]=v.y,++M,f[M]=f[M+m]=v.z,++M,D&&(w=_[b],A=_[(b+1)%I],L[P]=L[P+E]=w.x,++P,L[P]=L[P+E]=w.y,++P,L[P]=L[P+E]=A.x,++P,L[P]=L[P+E]=A.y,++P);else{const n=d.CesiumMath.chordLength(s,i.maximumRadius);let o=0;if(p===t.ArcType.GEODESIC)for(b=0;b<I;b++)o+=g.subdivideLineCount(e[b],e[(b+1)%I],n);else if(p===t.ArcType.RHUMB)for(b=0;b<I;b++)o+=g.subdivideRhumbLineCount(i,e[b],e[(b+1)%I],n);for(m=3*(o+I),f=new Array(2*m),D&&(E=2*(o+I),L=new Array(2*E)),b=0;b<I;b++){let o,r;T=e[b],v=e[(b+1)%I],D&&(w=_[b],A=_[(b+1)%I]),p===t.ArcType.GEODESIC?(o=g.subdivideLine(T,v,n,N),D&&(r=g.subdivideTexcoordLine(w,A,T,v,n,R))):p===t.ArcType.RHUMB&&(o=g.subdivideRhumbLine(i,T,v,n,N),D&&(r=g.subdivideTexcoordRhumbLine(w,A,i,T,v,n,R)));const a=o.length;for(let e=0;e<a;++e,++M)f[M]=o[e],f[M+m]=o[e];if(f[M]=v.x,f[M+m]=v.x,++M,f[M]=v.y,f[M+m]=v.y,++M,f[M]=v.z,f[M+m]=v.z,++M,D){const e=r.length;for(let t=0;t<e;++t,++P)L[P]=r[t],L[P+E]=r[t];L[P]=A.x,L[P+E]=A.x,++P,L[P]=A.y,L[P+E]=A.y,++P}}}I=f.length;const G=h.IndexDatatype.createTypedArray(I/3,I-6*e.length);let S=0;for(I/=6,b=0;b<I;b++){const e=b,t=e+1,n=e+I,i=n+1;T=o.Cartesian3.fromArray(f,3*e,O),v=o.Cartesian3.fromArray(f,3*t,q),o.Cartesian3.equalsEpsilon(T,v,d.CesiumMath.EPSILON10,d.CesiumMath.EPSILON10)||(G[S++]=e,G[S++]=n,G[S++]=t,G[S++]=t,G[S++]=n,G[S++]=i)}const k={attributes:new l.GeometryAttributes({position:new c.GeometryAttribute({componentDatatype:r.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:f})}),indices:G,primitiveType:c.PrimitiveType.TRIANGLES};return D&&(k.attributes.st=new c.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:L})),new c.Geometry(k)};var k=g;e.PolygonGeometryLibrary=k}));