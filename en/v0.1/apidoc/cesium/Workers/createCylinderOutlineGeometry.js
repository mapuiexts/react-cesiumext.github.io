define(["./Transforms-f17097e5","./Matrix2-7a8e9daf","./Matrix3-b2351961","./ComponentDatatype-ab629b88","./CylinderGeometryLibrary-4d7f606d","./defaultValue-f6d5e6da","./GeometryAttribute-9c1a6bab","./GeometryAttributes-1e4ddcd2","./GeometryOffsetAttribute-2579b8d2","./IndexDatatype-a9b1bc18","./Math-355606c6","./combine-0c102d93","./RuntimeError-9b4ce3fb","./WebGLConstants-7f557f93"],(function(t,e,i,n,o,r,a,s,u,f,d,c,l,b){"use strict";const m=new e.Cartesian2;function p(t){const e=(t=r.defaultValue(t,r.defaultValue.EMPTY_OBJECT)).length,i=t.topRadius,n=t.bottomRadius,o=r.defaultValue(t.slices,128),a=Math.max(r.defaultValue(t.numberOfVerticalLines,16),0);this._length=e,this._topRadius=i,this._bottomRadius=n,this._slices=o,this._numberOfVerticalLines=a,this._offsetAttribute=t.offsetAttribute,this._workerName="createCylinderOutlineGeometry"}p.packedLength=6,p.pack=function(t,e,i){return i=r.defaultValue(i,0),e[i++]=t._length,e[i++]=t._topRadius,e[i++]=t._bottomRadius,e[i++]=t._slices,e[i++]=t._numberOfVerticalLines,e[i]=r.defaultValue(t._offsetAttribute,-1),e};const y={length:void 0,topRadius:void 0,bottomRadius:void 0,slices:void 0,numberOfVerticalLines:void 0,offsetAttribute:void 0};return p.unpack=function(t,e,i){e=r.defaultValue(e,0);const n=t[e++],o=t[e++],a=t[e++],s=t[e++],u=t[e++],f=t[e];return r.defined(i)?(i._length=n,i._topRadius=o,i._bottomRadius=a,i._slices=s,i._numberOfVerticalLines=u,i._offsetAttribute=-1===f?void 0:f,i):(y.length=n,y.topRadius=o,y.bottomRadius=a,y.slices=s,y.numberOfVerticalLines=u,y.offsetAttribute=-1===f?void 0:f,new p(y))},p.createGeometry=function(d){let c=d._length;const l=d._topRadius,b=d._bottomRadius,y=d._slices,_=d._numberOfVerticalLines;if(c<=0||l<0||b<0||0===l&&0===b)return;const h=2*y,A=o.CylinderGeometryLibrary.computePositions(c,l,b,y,!1);let R,G=2*y;if(_>0){const t=Math.min(_,y);R=Math.round(y/t),G+=t}const O=f.IndexDatatype.createTypedArray(h,2*G);let V,L=0;for(V=0;V<y-1;V++)O[L++]=V,O[L++]=V+1,O[L++]=V+y,O[L++]=V+1+y;if(O[L++]=y-1,O[L++]=0,O[L++]=y+y-1,O[L++]=y,_>0)for(V=0;V<y;V+=R)O[L++]=V,O[L++]=V+y;const g=new s.GeometryAttributes;g.position=new a.GeometryAttribute({componentDatatype:n.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:A}),m.x=.5*c,m.y=Math.max(b,l);const v=new t.BoundingSphere(i.Cartesian3.ZERO,e.Cartesian2.magnitude(m));if(r.defined(d._offsetAttribute)){c=A.length;const t=d._offsetAttribute===u.GeometryOffsetAttribute.NONE?0:1,e=new Uint8Array(c/3).fill(t);g.applyOffset=new a.GeometryAttribute({componentDatatype:n.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}return new a.Geometry({attributes:g,indices:O,primitiveType:a.PrimitiveType.LINES,boundingSphere:v,offsetAttribute:d._offsetAttribute})},function(t,e){return r.defined(e)&&(t=p.unpack(t,e)),p.createGeometry(t)}}));