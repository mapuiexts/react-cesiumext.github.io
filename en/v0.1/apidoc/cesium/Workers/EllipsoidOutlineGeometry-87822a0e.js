define(["exports","./Transforms-20461479","./Matrix3-81054f0f","./ComponentDatatype-ab629b88","./defaultValue-f6d5e6da","./GeometryAttribute-b8117bde","./GeometryAttributes-1e4ddcd2","./GeometryOffsetAttribute-2579b8d2","./IndexDatatype-d3db4e7d","./Math-2ce22ee9"],(function(t,i,e,n,a,o,r,s,u,m){"use strict";const f=new e.Cartesian3(1,1,1),l=Math.cos,c=Math.sin;function d(t){t=a.defaultValue(t,a.defaultValue.EMPTY_OBJECT);const i=a.defaultValue(t.radii,f),n=a.defaultValue(t.innerRadii,i),o=a.defaultValue(t.minimumClock,0),r=a.defaultValue(t.maximumClock,m.CesiumMath.TWO_PI),s=a.defaultValue(t.minimumCone,0),u=a.defaultValue(t.maximumCone,m.CesiumMath.PI),l=Math.round(a.defaultValue(t.stackPartitions,10)),c=Math.round(a.defaultValue(t.slicePartitions,8)),C=Math.round(a.defaultValue(t.subdivisions,128));this._radii=e.Cartesian3.clone(i),this._innerRadii=e.Cartesian3.clone(n),this._minimumClock=o,this._maximumClock=r,this._minimumCone=s,this._maximumCone=u,this._stackPartitions=l,this._slicePartitions=c,this._subdivisions=C,this._offsetAttribute=t.offsetAttribute,this._workerName="createEllipsoidOutlineGeometry"}d.packedLength=2*e.Cartesian3.packedLength+8,d.pack=function(t,i,n){return n=a.defaultValue(n,0),e.Cartesian3.pack(t._radii,i,n),n+=e.Cartesian3.packedLength,e.Cartesian3.pack(t._innerRadii,i,n),n+=e.Cartesian3.packedLength,i[n++]=t._minimumClock,i[n++]=t._maximumClock,i[n++]=t._minimumCone,i[n++]=t._maximumCone,i[n++]=t._stackPartitions,i[n++]=t._slicePartitions,i[n++]=t._subdivisions,i[n]=a.defaultValue(t._offsetAttribute,-1),i};const C=new e.Cartesian3,_=new e.Cartesian3,p={radii:C,innerRadii:_,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,subdivisions:void 0,offsetAttribute:void 0};d.unpack=function(t,i,n){i=a.defaultValue(i,0);const o=e.Cartesian3.unpack(t,i,C);i+=e.Cartesian3.packedLength;const r=e.Cartesian3.unpack(t,i,_);i+=e.Cartesian3.packedLength;const s=t[i++],u=t[i++],m=t[i++],f=t[i++],l=t[i++],c=t[i++],h=t[i++],y=t[i];return a.defined(n)?(n._radii=e.Cartesian3.clone(o,n._radii),n._innerRadii=e.Cartesian3.clone(r,n._innerRadii),n._minimumClock=s,n._maximumClock=u,n._minimumCone=m,n._maximumCone=f,n._stackPartitions=l,n._slicePartitions=c,n._subdivisions=h,n._offsetAttribute=-1===y?void 0:y,n):(p.minimumClock=s,p.maximumClock=u,p.minimumCone=m,p.maximumCone=f,p.stackPartitions=l,p.slicePartitions=c,p.subdivisions=h,p.offsetAttribute=-1===y?void 0:y,new d(p))},d.createGeometry=function(t){const f=t._radii;if(f.x<=0||f.y<=0||f.z<=0)return;const C=t._innerRadii;if(C.x<=0||C.y<=0||C.z<=0)return;const _=t._minimumClock,p=t._maximumClock,h=t._minimumCone,y=t._maximumCone,b=t._subdivisions,k=e.Ellipsoid.fromCartesian3(f);let x=t._slicePartitions+1,A=t._stackPartitions+1;x=Math.round(x*Math.abs(p-_)/m.CesiumMath.TWO_PI),A=Math.round(A*Math.abs(y-h)/m.CesiumMath.PI),x<2&&(x=2),A<2&&(A=2);let P=0,v=1;const M=C.x!==f.x||C.y!==f.y||C.z!==f.z;let w=!1,V=!1;M&&(v=2,h>0&&(w=!0,P+=x),y<Math.PI&&(V=!0,P+=x));const g=b*v*(A+x),G=new Float64Array(3*g),E=2*(g+P-(x+A)*v),O=u.IndexDatatype.createTypedArray(g,E);let D,I,T,z,L=0;const R=new Array(A),N=new Array(A);for(D=0;D<A;D++)z=h+D*(y-h)/(A-1),R[D]=c(z),N[D]=l(z);const B=new Array(b),S=new Array(b);for(D=0;D<b;D++)T=_+D*(p-_)/(b-1),B[D]=c(T),S[D]=l(T);for(D=0;D<A;D++)for(I=0;I<b;I++)G[L++]=f.x*R[D]*S[I],G[L++]=f.y*R[D]*B[I],G[L++]=f.z*N[D];if(M)for(D=0;D<A;D++)for(I=0;I<b;I++)G[L++]=C.x*R[D]*S[I],G[L++]=C.y*R[D]*B[I],G[L++]=C.z*N[D];for(R.length=b,N.length=b,D=0;D<b;D++)z=h+D*(y-h)/(b-1),R[D]=c(z),N[D]=l(z);for(B.length=x,S.length=x,D=0;D<x;D++)T=_+D*(p-_)/(x-1),B[D]=c(T),S[D]=l(T);for(D=0;D<b;D++)for(I=0;I<x;I++)G[L++]=f.x*R[D]*S[I],G[L++]=f.y*R[D]*B[I],G[L++]=f.z*N[D];if(M)for(D=0;D<b;D++)for(I=0;I<x;I++)G[L++]=C.x*R[D]*S[I],G[L++]=C.y*R[D]*B[I],G[L++]=C.z*N[D];for(L=0,D=0;D<A*v;D++){const t=D*b;for(I=0;I<b-1;I++)O[L++]=t+I,O[L++]=t+I+1}let U=A*b*v;for(D=0;D<x;D++)for(I=0;I<b-1;I++)O[L++]=U+D+I*x,O[L++]=U+D+(I+1)*x;if(M)for(U=A*b*v+x*b,D=0;D<x;D++)for(I=0;I<b-1;I++)O[L++]=U+D+I*x,O[L++]=U+D+(I+1)*x;if(M){let t=A*b*v,i=t+b*x;if(w)for(D=0;D<x;D++)O[L++]=t+D,O[L++]=i+D;if(V)for(t+=b*x-x,i+=b*x-x,D=0;D<x;D++)O[L++]=t+D,O[L++]=i+D}const W=new r.GeometryAttributes({position:new o.GeometryAttribute({componentDatatype:n.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:G})});if(a.defined(t._offsetAttribute)){const i=G.length,e=t._offsetAttribute===s.GeometryOffsetAttribute.NONE?0:1,a=new Uint8Array(i/3).fill(e);W.applyOffset=new o.GeometryAttribute({componentDatatype:n.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:a})}return new o.Geometry({attributes:W,indices:O,primitiveType:o.PrimitiveType.LINES,boundingSphere:i.BoundingSphere.fromEllipsoid(k),offsetAttribute:t._offsetAttribute})},t.EllipsoidOutlineGeometry=d}));