/*! For license information please see CylinderGeometry-38de8def.js.LICENSE.txt */
define(["exports","./Transforms-c450597e","./Matrix2-21f90abf","./ComponentDatatype-4028c72d","./CylinderGeometryLibrary-af834e78","./defaultValue-4607806f","./RuntimeError-cef79f54","./GeometryAttribute-3c090c07","./GeometryAttributes-acac33d2","./GeometryOffsetAttribute-3e5f3e97","./IndexDatatype-20e78e57","./VertexFormat-75e8069c"],(function(t,e,n,a,o,r,i,s,u,m,c,l){"use strict";const f=new n.Cartesian2,p=new n.Cartesian3,d=new n.Cartesian3,y=new n.Cartesian3,b=new n.Cartesian3;function A(t){const e=(t=r.defaultValue(t,r.defaultValue.EMPTY_OBJECT)).length,n=t.topRadius,a=t.bottomRadius,o=r.defaultValue(t.vertexFormat,l.VertexFormat.DEFAULT),i=r.defaultValue(t.slices,128);this._length=e,this._topRadius=n,this._bottomRadius=a,this._vertexFormat=l.VertexFormat.clone(o),this._slices=i,this._offsetAttribute=t.offsetAttribute,this._workerName="createCylinderGeometry"}A.packedLength=l.VertexFormat.packedLength+5,A.pack=function(t,e,n){return n=r.defaultValue(n,0),l.VertexFormat.pack(t._vertexFormat,e,n),n+=l.VertexFormat.packedLength,e[n++]=t._length,e[n++]=t._topRadius,e[n++]=t._bottomRadius,e[n++]=t._slices,e[n]=r.defaultValue(t._offsetAttribute,-1),e};const x=new l.VertexFormat,g={vertexFormat:x,length:void 0,topRadius:void 0,bottomRadius:void 0,slices:void 0,offsetAttribute:void 0};let _;A.unpack=function(t,e,n){e=r.defaultValue(e,0);const a=l.VertexFormat.unpack(t,e,x);e+=l.VertexFormat.packedLength;const o=t[e++],i=t[e++],s=t[e++],u=t[e++],m=t[e];return r.defined(n)?(n._vertexFormat=l.VertexFormat.clone(a,n._vertexFormat),n._length=o,n._topRadius=i,n._bottomRadius=s,n._slices=u,n._offsetAttribute=-1===m?void 0:m,n):(g.length=o,g.topRadius=i,g.bottomRadius=s,g.slices=u,g.offsetAttribute=-1===m?void 0:m,new A(g))},A.createGeometry=function(t){let i=t._length;const l=t._topRadius,x=t._bottomRadius,g=t._vertexFormat,_=t._slices;if(i<=0||l<0||x<0||0===l&&0===x)return;const h=_+_,F=_+h,v=h+h,C=o.CylinderGeometryLibrary.computePositions(i,l,x,_,!0),w=g.st?new Float32Array(2*v):void 0,G=g.normal?new Float32Array(3*v):void 0,R=g.tangent?new Float32Array(3*v):void 0,V=g.bitangent?new Float32Array(3*v):void 0;let D;const T=g.normal||g.tangent||g.bitangent;if(T){const t=g.tangent||g.bitangent;let e=0,o=0,r=0;const s=Math.atan2(x-l,i),u=p;u.z=Math.sin(s);const m=Math.cos(s);let c=y,f=d;for(D=0;D<_;D++){const i=D/_*a.CesiumMath.TWO_PI,s=m*Math.cos(i),l=m*Math.sin(i);T&&(u.x=s,u.y=l,t&&(c=n.Cartesian3.normalize(n.Cartesian3.cross(n.Cartesian3.UNIT_Z,u,c),c)),g.normal&&(G[e++]=u.x,G[e++]=u.y,G[e++]=u.z,G[e++]=u.x,G[e++]=u.y,G[e++]=u.z),g.tangent&&(R[o++]=c.x,R[o++]=c.y,R[o++]=c.z,R[o++]=c.x,R[o++]=c.y,R[o++]=c.z),g.bitangent&&(f=n.Cartesian3.normalize(n.Cartesian3.cross(u,c,f),f),V[r++]=f.x,V[r++]=f.y,V[r++]=f.z,V[r++]=f.x,V[r++]=f.y,V[r++]=f.z))}for(D=0;D<_;D++)g.normal&&(G[e++]=0,G[e++]=0,G[e++]=-1),g.tangent&&(R[o++]=1,R[o++]=0,R[o++]=0),g.bitangent&&(V[r++]=0,V[r++]=-1,V[r++]=0);for(D=0;D<_;D++)g.normal&&(G[e++]=0,G[e++]=0,G[e++]=1),g.tangent&&(R[o++]=1,R[o++]=0,R[o++]=0),g.bitangent&&(V[r++]=0,V[r++]=1,V[r++]=0)}const O=12*_-12,L=c.IndexDatatype.createTypedArray(v,O);let P=0,E=0;for(D=0;D<_-1;D++)L[P++]=E,L[P++]=E+2,L[P++]=E+3,L[P++]=E,L[P++]=E+3,L[P++]=E+1,E+=2;for(L[P++]=h-2,L[P++]=0,L[P++]=1,L[P++]=h-2,L[P++]=1,L[P++]=h-1,D=1;D<_-1;D++)L[P++]=h+D+1,L[P++]=h+D,L[P++]=h;for(D=1;D<_-1;D++)L[P++]=F,L[P++]=F+D,L[P++]=F+D+1;let M=0;if(g.st){const t=Math.max(l,x);for(D=0;D<v;D++){const e=n.Cartesian3.fromArray(C,3*D,b);w[M++]=(e.x+t)/(2*t),w[M++]=(e.y+t)/(2*t)}}const k=new u.GeometryAttributes;g.position&&(k.position=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:C})),g.normal&&(k.normal=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:G})),g.tangent&&(k.tangent=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:R})),g.bitangent&&(k.bitangent=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:V})),g.st&&(k.st=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:w})),f.x=.5*i,f.y=Math.max(x,l);const z=new e.BoundingSphere(n.Cartesian3.ZERO,n.Cartesian2.magnitude(f));if(r.defined(t._offsetAttribute)){i=C.length;const e=t._offsetAttribute===m.GeometryOffsetAttribute.NONE?0:1,n=new Uint8Array(i/3).fill(e);k.applyOffset=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}return new s.Geometry({attributes:k,indices:L,primitiveType:s.PrimitiveType.TRIANGLES,boundingSphere:z,offsetAttribute:t._offsetAttribute})},A.getUnitCylinder=function(){return r.defined(_)||(_=A.createGeometry(new A({topRadius:1,bottomRadius:1,length:1,vertexFormat:l.VertexFormat.POSITION_ONLY}))),_},t.CylinderGeometry=A}));