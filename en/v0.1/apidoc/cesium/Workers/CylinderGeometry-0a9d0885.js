define(["exports","./Transforms-20461479","./Matrix2-413c4048","./Matrix3-81054f0f","./ComponentDatatype-ab629b88","./CylinderGeometryLibrary-f49f33a8","./defaultValue-f6d5e6da","./GeometryAttribute-b8117bde","./GeometryAttributes-1e4ddcd2","./GeometryOffsetAttribute-2579b8d2","./IndexDatatype-d3db4e7d","./Math-2ce22ee9","./VertexFormat-fbdec922"],(function(t,e,n,a,o,r,i,s,u,m,d,c,l){"use strict";const f=new n.Cartesian2,p=new a.Cartesian3,y=new a.Cartesian3,b=new a.Cartesian3,A=new a.Cartesian3;function x(t){const e=(t=i.defaultValue(t,i.defaultValue.EMPTY_OBJECT)).length,n=t.topRadius,a=t.bottomRadius,o=i.defaultValue(t.vertexFormat,l.VertexFormat.DEFAULT),r=i.defaultValue(t.slices,128);this._length=e,this._topRadius=n,this._bottomRadius=a,this._vertexFormat=l.VertexFormat.clone(o),this._slices=r,this._offsetAttribute=t.offsetAttribute,this._workerName="createCylinderGeometry"}x.packedLength=l.VertexFormat.packedLength+5,x.pack=function(t,e,n){return n=i.defaultValue(n,0),l.VertexFormat.pack(t._vertexFormat,e,n),n+=l.VertexFormat.packedLength,e[n++]=t._length,e[n++]=t._topRadius,e[n++]=t._bottomRadius,e[n++]=t._slices,e[n]=i.defaultValue(t._offsetAttribute,-1),e};const g=new l.VertexFormat,_={vertexFormat:g,length:void 0,topRadius:void 0,bottomRadius:void 0,slices:void 0,offsetAttribute:void 0};let h;x.unpack=function(t,e,n){e=i.defaultValue(e,0);const a=l.VertexFormat.unpack(t,e,g);e+=l.VertexFormat.packedLength;const o=t[e++],r=t[e++],s=t[e++],u=t[e++],m=t[e];return i.defined(n)?(n._vertexFormat=l.VertexFormat.clone(a,n._vertexFormat),n._length=o,n._topRadius=r,n._bottomRadius=s,n._slices=u,n._offsetAttribute=-1===m?void 0:m,n):(_.length=o,_.topRadius=r,_.bottomRadius=s,_.slices=u,_.offsetAttribute=-1===m?void 0:m,new x(_))},x.createGeometry=function(t){let l=t._length;const g=t._topRadius,_=t._bottomRadius,h=t._vertexFormat,F=t._slices;if(l<=0||g<0||_<0||0===g&&0===_)return;const v=F+F,C=F+v,w=v+v,G=r.CylinderGeometryLibrary.computePositions(l,g,_,F,!0),V=h.st?new Float32Array(2*w):void 0,D=h.normal?new Float32Array(3*w):void 0,R=h.tangent?new Float32Array(3*w):void 0,T=h.bitangent?new Float32Array(3*w):void 0;let O;const L=h.normal||h.tangent||h.bitangent;if(L){const t=h.tangent||h.bitangent;let e=0,n=0,o=0;const r=Math.atan2(_-g,l),i=p;i.z=Math.sin(r);const s=Math.cos(r);let u=b,m=y;for(O=0;O<F;O++){const r=O/F*c.CesiumMath.TWO_PI,d=s*Math.cos(r),l=s*Math.sin(r);L&&(i.x=d,i.y=l,t&&(u=a.Cartesian3.normalize(a.Cartesian3.cross(a.Cartesian3.UNIT_Z,i,u),u)),h.normal&&(D[e++]=i.x,D[e++]=i.y,D[e++]=i.z,D[e++]=i.x,D[e++]=i.y,D[e++]=i.z),h.tangent&&(R[n++]=u.x,R[n++]=u.y,R[n++]=u.z,R[n++]=u.x,R[n++]=u.y,R[n++]=u.z),h.bitangent&&(m=a.Cartesian3.normalize(a.Cartesian3.cross(i,u,m),m),T[o++]=m.x,T[o++]=m.y,T[o++]=m.z,T[o++]=m.x,T[o++]=m.y,T[o++]=m.z))}for(O=0;O<F;O++)h.normal&&(D[e++]=0,D[e++]=0,D[e++]=-1),h.tangent&&(R[n++]=1,R[n++]=0,R[n++]=0),h.bitangent&&(T[o++]=0,T[o++]=-1,T[o++]=0);for(O=0;O<F;O++)h.normal&&(D[e++]=0,D[e++]=0,D[e++]=1),h.tangent&&(R[n++]=1,R[n++]=0,R[n++]=0),h.bitangent&&(T[o++]=0,T[o++]=1,T[o++]=0)}const M=12*F-12,P=d.IndexDatatype.createTypedArray(w,M);let k=0,z=0;for(O=0;O<F-1;O++)P[k++]=z,P[k++]=z+2,P[k++]=z+3,P[k++]=z,P[k++]=z+3,P[k++]=z+1,z+=2;for(P[k++]=v-2,P[k++]=0,P[k++]=1,P[k++]=v-2,P[k++]=1,P[k++]=v-1,O=1;O<F-1;O++)P[k++]=v+O+1,P[k++]=v+O,P[k++]=v;for(O=1;O<F-1;O++)P[k++]=C,P[k++]=C+O,P[k++]=C+O+1;let E=0;if(h.st){const t=Math.max(g,_);for(O=0;O<w;O++){const e=a.Cartesian3.fromArray(G,3*O,A);V[E++]=(e.x+t)/(2*t),V[E++]=(e.y+t)/(2*t)}}const N=new u.GeometryAttributes;h.position&&(N.position=new s.GeometryAttribute({componentDatatype:o.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:G})),h.normal&&(N.normal=new s.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:D})),h.tangent&&(N.tangent=new s.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:R})),h.bitangent&&(N.bitangent=new s.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:T})),h.st&&(N.st=new s.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:V})),f.x=.5*l,f.y=Math.max(_,g);const I=new e.BoundingSphere(a.Cartesian3.ZERO,n.Cartesian2.magnitude(f));if(i.defined(t._offsetAttribute)){l=G.length;const e=t._offsetAttribute===m.GeometryOffsetAttribute.NONE?0:1,n=new Uint8Array(l/3).fill(e);N.applyOffset=new s.GeometryAttribute({componentDatatype:o.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}return new s.Geometry({attributes:N,indices:P,primitiveType:s.PrimitiveType.TRIANGLES,boundingSphere:I,offsetAttribute:t._offsetAttribute})},x.getUnitCylinder=function(){return i.defined(h)||(h=x.createGeometry(new x({topRadius:1,bottomRadius:1,length:1,vertexFormat:l.VertexFormat.POSITION_ONLY}))),h},t.CylinderGeometry=x}));