define(["exports","./Transforms-01e95659","./Matrix3-a348023f","./ComponentDatatype-77274976","./defaultValue-0a909f67","./EllipseGeometryLibrary-e689e77b","./GeometryAttribute-f5d71750","./GeometryAttributes-f06a2792","./GeometryOffsetAttribute-04332ce7","./IndexDatatype-2149f06c","./Math-e97915da"],(function(e,t,i,r,n,a,o,s,l,u,d){"use strict";const c=new i.Cartesian3;let f=new i.Cartesian3;const p=new t.BoundingSphere,m=new t.BoundingSphere;function h(e){const t=(e=n.defaultValue(e,n.defaultValue.EMPTY_OBJECT)).center,r=n.defaultValue(e.ellipsoid,i.Ellipsoid.WGS84),a=e.semiMajorAxis,o=e.semiMinorAxis,s=n.defaultValue(e.granularity,d.CesiumMath.RADIANS_PER_DEGREE),l=n.defaultValue(e.height,0),u=n.defaultValue(e.extrudedHeight,l);this._center=i.Cartesian3.clone(t),this._semiMajorAxis=a,this._semiMinorAxis=o,this._ellipsoid=i.Ellipsoid.clone(r),this._rotation=n.defaultValue(e.rotation,0),this._height=Math.max(u,l),this._granularity=s,this._extrudedHeight=Math.min(u,l),this._numberOfVerticalLines=Math.max(n.defaultValue(e.numberOfVerticalLines,16),0),this._offsetAttribute=e.offsetAttribute,this._workerName="createEllipseOutlineGeometry"}h.packedLength=i.Cartesian3.packedLength+i.Ellipsoid.packedLength+8,h.pack=function(e,t,r){return r=n.defaultValue(r,0),i.Cartesian3.pack(e._center,t,r),r+=i.Cartesian3.packedLength,i.Ellipsoid.pack(e._ellipsoid,t,r),r+=i.Ellipsoid.packedLength,t[r++]=e._semiMajorAxis,t[r++]=e._semiMinorAxis,t[r++]=e._rotation,t[r++]=e._height,t[r++]=e._granularity,t[r++]=e._extrudedHeight,t[r++]=e._numberOfVerticalLines,t[r]=n.defaultValue(e._offsetAttribute,-1),t};const y=new i.Cartesian3,A=new i.Ellipsoid,_={center:y,ellipsoid:A,semiMajorAxis:void 0,semiMinorAxis:void 0,rotation:void 0,height:void 0,granularity:void 0,extrudedHeight:void 0,numberOfVerticalLines:void 0,offsetAttribute:void 0};h.unpack=function(e,t,r){t=n.defaultValue(t,0);const a=i.Cartesian3.unpack(e,t,y);t+=i.Cartesian3.packedLength;const o=i.Ellipsoid.unpack(e,t,A);t+=i.Ellipsoid.packedLength;const s=e[t++],l=e[t++],u=e[t++],d=e[t++],c=e[t++],f=e[t++],p=e[t++],m=e[t];return n.defined(r)?(r._center=i.Cartesian3.clone(a,r._center),r._ellipsoid=i.Ellipsoid.clone(o,r._ellipsoid),r._semiMajorAxis=s,r._semiMinorAxis=l,r._rotation=u,r._height=d,r._granularity=c,r._extrudedHeight=f,r._numberOfVerticalLines=p,r._offsetAttribute=-1===m?void 0:m,r):(_.height=d,_.extrudedHeight=f,_.granularity=c,_.rotation=u,_.semiMajorAxis=s,_.semiMinorAxis=l,_.numberOfVerticalLines=p,_.offsetAttribute=-1===m?void 0:m,new h(_))},h.createGeometry=function(e){if(e._semiMajorAxis<=0||e._semiMinorAxis<=0)return;const y=e._height,A=e._extrudedHeight,_=!d.CesiumMath.equalsEpsilon(y,A,0,d.CesiumMath.EPSILON2);e._center=e._ellipsoid.scaleToGeodeticSurface(e._center,e._center);const b={center:e._center,semiMajorAxis:e._semiMajorAxis,semiMinorAxis:e._semiMinorAxis,ellipsoid:e._ellipsoid,rotation:e._rotation,height:y,granularity:e._granularity,numberOfVerticalLines:e._numberOfVerticalLines};let g;if(_)b.extrudedHeight=A,b.offsetAttribute=e._offsetAttribute,g=function(e){const f=e.center,y=e.ellipsoid,A=e.semiMajorAxis;let _=i.Cartesian3.multiplyByScalar(y.geodeticSurfaceNormal(f,c),e.height,c);p.center=i.Cartesian3.add(f,_,p.center),p.radius=A,_=i.Cartesian3.multiplyByScalar(y.geodeticSurfaceNormal(f,_),e.extrudedHeight,_),m.center=i.Cartesian3.add(f,_,m.center),m.radius=A;let b=a.EllipseGeometryLibrary.computeEllipsePositions(e,!1,!0).outerPositions;const g=new s.GeometryAttributes({position:new o.GeometryAttribute({componentDatatype:r.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:a.EllipseGeometryLibrary.raisePositionsToHeight(b,e,!0)})});b=g.position.values;const x=t.BoundingSphere.union(p,m);let E=b.length/3;if(n.defined(e.offsetAttribute)){let t=new Uint8Array(E);if(e.offsetAttribute===l.GeometryOffsetAttribute.TOP)t=t.fill(1,0,E/2);else{const i=e.offsetAttribute===l.GeometryOffsetAttribute.NONE?0:1;t=t.fill(i)}g.applyOffset=new o.GeometryAttribute({componentDatatype:r.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}let M=n.defaultValue(e.numberOfVerticalLines,16);M=d.CesiumMath.clamp(M,0,E/2);const C=u.IndexDatatype.createTypedArray(E,2*E+2*M);E/=2;let G,L,O=0;for(G=0;G<E;++G)C[O++]=G,C[O++]=(G+1)%E,C[O++]=G+E,C[O++]=(G+1)%E+E;if(M>0){const e=Math.min(M,E);L=Math.round(E/e);const t=Math.min(L*M,E);for(G=0;G<t;G+=L)C[O++]=G,C[O++]=G+E}return{boundingSphere:x,attributes:g,indices:C}}(b);else if(g=function(e){const n=e.center;f=i.Cartesian3.multiplyByScalar(e.ellipsoid.geodeticSurfaceNormal(n,f),e.height,f),f=i.Cartesian3.add(n,f,f);const l=new t.BoundingSphere(f,e.semiMajorAxis),d=a.EllipseGeometryLibrary.computeEllipsePositions(e,!1,!0).outerPositions,c=new s.GeometryAttributes({position:new o.GeometryAttribute({componentDatatype:r.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:a.EllipseGeometryLibrary.raisePositionsToHeight(d,e,!1)})}),p=d.length/3,m=u.IndexDatatype.createTypedArray(p,2*p);let y=0;for(let e=0;e<p;++e)m[y++]=e,m[y++]=(e+1)%p;return{boundingSphere:l,attributes:c,indices:m}}(b),n.defined(e._offsetAttribute)){const t=g.attributes.position.values.length,i=e._offsetAttribute===l.GeometryOffsetAttribute.NONE?0:1,n=new Uint8Array(t/3).fill(i);g.attributes.applyOffset=new o.GeometryAttribute({componentDatatype:r.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}return new o.Geometry({attributes:g.attributes,indices:g.indices,primitiveType:o.PrimitiveType.LINES,boundingSphere:g.boundingSphere,offsetAttribute:e._offsetAttribute})},e.EllipseOutlineGeometry=h}));