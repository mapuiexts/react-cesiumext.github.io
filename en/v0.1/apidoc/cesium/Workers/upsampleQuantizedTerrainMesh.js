define(["./AttributeCompression-0b8f7b7d","./Transforms-f17097e5","./Matrix2-7a8e9daf","./Matrix3-b2351961","./defaultValue-f6d5e6da","./TerrainEncoding-c5a10c4f","./IndexDatatype-a9b1bc18","./Math-355606c6","./OrientedBoundingBox-c083edd8","./createTaskProcessorWorker","./ComponentDatatype-ab629b88","./WebGLConstants-7f557f93","./combine-0c102d93","./RuntimeError-9b4ce3fb","./EllipsoidTangentPlane-c3e9d965","./AxisAlignedBoundingBox-04c1a5e3","./IntersectionTests-f1b36d69","./Plane-5931b53e"],(function(e,t,n,i,s,r,h,o,u,d,p,l,a,f,c,g,m,x){"use strict";const w={clipTriangleAtAxisAlignedThreshold:function(e,t,n,i,r,h){let o,u,d;s.defined(h)?h.length=0:h=[],t?(o=n<e,u=i<e,d=r<e):(o=n>e,u=i>e,d=r>e);const p=o+u+d;let l,a,f,c,g,m;return 1===p?o?(l=(e-n)/(i-n),a=(e-n)/(r-n),h.push(1),h.push(2),1!==a&&(h.push(-1),h.push(0),h.push(2),h.push(a)),1!==l&&(h.push(-1),h.push(0),h.push(1),h.push(l))):u?(f=(e-i)/(r-i),c=(e-i)/(n-i),h.push(2),h.push(0),1!==c&&(h.push(-1),h.push(1),h.push(0),h.push(c)),1!==f&&(h.push(-1),h.push(1),h.push(2),h.push(f))):d&&(g=(e-r)/(n-r),m=(e-r)/(i-r),h.push(0),h.push(1),1!==m&&(h.push(-1),h.push(2),h.push(1),h.push(m)),1!==g&&(h.push(-1),h.push(2),h.push(0),h.push(g))):2===p?o||n===e?u||i===e?d||r===e||(a=(e-n)/(r-n),f=(e-i)/(r-i),h.push(2),h.push(-1),h.push(0),h.push(2),h.push(a),h.push(-1),h.push(1),h.push(2),h.push(f)):(m=(e-r)/(i-r),l=(e-n)/(i-n),h.push(1),h.push(-1),h.push(2),h.push(1),h.push(m),h.push(-1),h.push(0),h.push(1),h.push(l)):(c=(e-i)/(n-i),g=(e-r)/(n-r),h.push(0),h.push(-1),h.push(1),h.push(0),h.push(c),h.push(-1),h.push(2),h.push(0),h.push(g)):3!==p&&(h.push(0),h.push(1),h.push(2)),h},computeBarycentricCoordinates:function(e,t,n,r,h,o,u,d,p){const l=n-u,a=u-h,f=o-d,c=r-d,g=1/(f*l+a*c),m=t-d,x=e-u,w=(f*x+a*m)*g,C=(-c*x+l*m)*g,B=1-w-C;return s.defined(p)?(p.x=w,p.y=C,p.z=B,p):new i.Cartesian3(w,C,B)},computeLineSegmentLineSegmentIntersection:function(e,t,i,r,h,o,u,d,p){const l=(d-o)*(i-e)-(u-h)*(r-t);if(0===l)return;const a=((u-h)*(t-o)-(d-o)*(e-h))/l,f=((i-e)*(t-o)-(r-t)*(e-h))/l;return a>=0&&a<=1&&f>=0&&f<=1?(s.defined(p)||(p=new n.Cartesian2),p.x=e+a*(i-e),p.y=t+a*(r-t),p):void 0}};var C=w;const B=32767,y=16383,b=[],I=[],A=[],v=new i.Cartographic;let T=new i.Cartesian3;const M=[],z=[],V=[],N=[],E=[],R=new i.Cartesian3,H=new t.BoundingSphere,O=new u.OrientedBoundingBox,S=new n.Cartesian2,U=new i.Cartesian3;function F(){this.vertexBuffer=void 0,this.index=void 0,this.first=void 0,this.second=void 0,this.ratio=void 0}F.prototype.clone=function(e){return s.defined(e)||(e=new F),e.uBuffer=this.uBuffer,e.vBuffer=this.vBuffer,e.heightBuffer=this.heightBuffer,e.normalBuffer=this.normalBuffer,e.index=this.index,e.first=this.first,e.second=this.second,e.ratio=this.ratio,e},F.prototype.initializeIndexed=function(e,t,n,i,s){this.uBuffer=e,this.vBuffer=t,this.heightBuffer=n,this.normalBuffer=i,this.index=s,this.first=void 0,this.second=void 0,this.ratio=void 0},F.prototype.initializeFromClipResult=function(e,t,n){let i=t+1;return-1!==e[t]?n[e[t]].clone(this):(this.vertexBuffer=void 0,this.index=void 0,this.first=n[e[i]],++i,this.second=n[e[i]],++i,this.ratio=e[i],++i),i},F.prototype.getKey=function(){return this.isIndexed()?this.index:JSON.stringify({first:this.first.getKey(),second:this.second.getKey(),ratio:this.ratio})},F.prototype.isIndexed=function(){return s.defined(this.index)},F.prototype.getH=function(){return s.defined(this.index)?this.heightBuffer[this.index]:o.CesiumMath.lerp(this.first.getH(),this.second.getH(),this.ratio)},F.prototype.getU=function(){return s.defined(this.index)?this.uBuffer[this.index]:o.CesiumMath.lerp(this.first.getU(),this.second.getU(),this.ratio)},F.prototype.getV=function(){return s.defined(this.index)?this.vBuffer[this.index]:o.CesiumMath.lerp(this.first.getV(),this.second.getV(),this.ratio)};let P=new n.Cartesian2,D=-1;const W=[new i.Cartesian3,new i.Cartesian3],X=[new i.Cartesian3,new i.Cartesian3];function k(t,n){++D;let s=W[D],r=X[D];return s=e.AttributeCompression.octDecode(t.first.getNormalX(),t.first.getNormalY(),s),r=e.AttributeCompression.octDecode(t.second.getNormalX(),t.second.getNormalY(),r),T=i.Cartesian3.lerp(s,r,t.ratio,T),i.Cartesian3.normalize(T,T),e.AttributeCompression.octEncode(T,n),--D,n}F.prototype.getNormalX=function(){return s.defined(this.index)?this.normalBuffer[2*this.index]:(P=k(this,P),P.x)},F.prototype.getNormalY=function(){return s.defined(this.index)?this.normalBuffer[2*this.index+1]:(P=k(this,P),P.y)};const K=[];function L(e,t,n,i,r,h,o,u,d){if(0===o.length)return;let p=0,l=0;for(;l<o.length;)l=K[p++].initializeFromClipResult(o,l,u);for(let r=0;r<p;++r){const o=K[r];if(o.isIndexed())o.newIndex=h[o.index],o.uBuffer=e,o.vBuffer=t,o.heightBuffer=n,d&&(o.normalBuffer=i);else{const r=o.getKey();if(s.defined(h[r]))o.newIndex=h[r];else{const s=e.length;e.push(o.getU()),t.push(o.getV()),n.push(o.getH()),d&&(i.push(o.getNormalX()),i.push(o.getNormalY())),o.newIndex=s,h[r]=s}}}3===p?(r.push(K[0].newIndex),r.push(K[1].newIndex),r.push(K[2].newIndex)):4===p&&(r.push(K[0].newIndex),r.push(K[1].newIndex),r.push(K[2].newIndex),r.push(K[0].newIndex),r.push(K[2].newIndex),r.push(K[3].newIndex))}return K.push(new F),K.push(new F),K.push(new F),K.push(new F),d((function(e,s){const d=e.isEastChild,p=e.isNorthChild,l=d?y:0,a=d?B:y,f=p?y:0,c=p?B:y,g=M,m=z,x=V,w=E;g.length=0,m.length=0,x.length=0,w.length=0;const P=N;P.length=0;const D={},W=e.vertices;let X=e.indices;X=X.subarray(0,e.indexCountWithoutSkirts);const K=r.TerrainEncoding.clone(e.encoding),Y=K.hasVertexNormals;let _=0;const G=e.vertexCountWithoutSkirts,J=e.minimumHeight,Z=e.maximumHeight,j=new Array(G),q=new Array(G),Q=new Array(G),$=Y?new Array(2*G):void 0;let ee,te,ne,ie,se;for(te=0,ne=0;te<G;++te,ne+=2){const e=K.decodeTextureCoordinates(W,te,S);if(ee=K.decodeHeight(W,te),ie=o.CesiumMath.clamp(e.x*B|0,0,B),se=o.CesiumMath.clamp(e.y*B|0,0,B),Q[te]=o.CesiumMath.clamp((ee-J)/(Z-J)*B|0,0,B),ie<20&&(ie=0),se<20&&(se=0),B-ie<20&&(ie=B),B-se<20&&(se=B),j[te]=ie,q[te]=se,Y){const e=K.getOctEncodedNormal(W,te,U);$[ne]=e.x,$[ne+1]=e.y}(d&&ie>=y||!d&&ie<=y)&&(p&&se>=y||!p&&se<=y)&&(D[te]=_,g.push(ie),m.push(se),x.push(Q[te]),Y&&(w.push($[ne]),w.push($[ne+1])),++_)}const re=[];re.push(new F),re.push(new F),re.push(new F);const he=[];let oe,ue;for(he.push(new F),he.push(new F),he.push(new F),te=0;te<X.length;te+=3){const e=X[te],t=X[te+1],n=X[te+2],i=j[e],s=j[t],r=j[n];re[0].initializeIndexed(j,q,Q,$,e),re[1].initializeIndexed(j,q,Q,$,t),re[2].initializeIndexed(j,q,Q,$,n);const h=C.clipTriangleAtAxisAlignedThreshold(y,d,i,s,r,b);oe=0,oe>=h.length||(oe=he[0].initializeFromClipResult(h,oe,re),oe>=h.length||(oe=he[1].initializeFromClipResult(h,oe,re),oe>=h.length||(oe=he[2].initializeFromClipResult(h,oe,re),ue=C.clipTriangleAtAxisAlignedThreshold(y,p,he[0].getV(),he[1].getV(),he[2].getV(),I),L(g,m,x,w,P,D,ue,he,Y),oe<h.length&&(he[2].clone(he[1]),he[2].initializeFromClipResult(h,oe,re),ue=C.clipTriangleAtAxisAlignedThreshold(y,p,he[0].getV(),he[1].getV(),he[2].getV(),I),L(g,m,x,w,P,D,ue,he,Y)))))}const de=d?-32767:0,pe=p?-32767:0,le=[],ae=[],fe=[],ce=[];let ge=Number.MAX_VALUE,me=-ge;const xe=A;xe.length=0;const we=i.Ellipsoid.clone(e.ellipsoid),Ce=n.Rectangle.clone(e.childRectangle),Be=Ce.north,ye=Ce.south;let be=Ce.east;const Fe=Ce.west;for(be<Fe&&(be+=o.CesiumMath.TWO_PI),te=0;te<g.length;++te)ie=Math.round(g[te]),ie<=l?(le.push(te),ie=0):ie>=a?(fe.push(te),ie=B):ie=2*ie+de,g[te]=ie,se=Math.round(m[te]),se<=f?(ae.push(te),se=0):se>=c?(ce.push(te),se=B):se=2*se+pe,m[te]=se,ee=o.CesiumMath.lerp(J,Z,x[te]/B),ee<ge&&(ge=ee),ee>me&&(me=ee),x[te]=ee,v.longitude=o.CesiumMath.lerp(Fe,be,ie/B),v.latitude=o.CesiumMath.lerp(ye,Be,se/B),v.height=ee,we.cartographicToCartesian(v,T),xe.push(T.x),xe.push(T.y),xe.push(T.z);const Ie=t.BoundingSphere.fromVertices(xe,i.Cartesian3.ZERO,3,H),Ae=u.OrientedBoundingBox.fromRectangle(Ce,ge,me,we,O),ve=new r.EllipsoidalOccluder(we).computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid(Ie.center,xe,3,Ie.center,ge,R),Te=me-ge,Me=new Uint16Array(g.length+m.length+x.length);for(te=0;te<g.length;++te)Me[te]=g[te];let ze=g.length;for(te=0;te<m.length;++te)Me[ze+te]=m[te];for(ze+=m.length,te=0;te<x.length;++te)Me[ze+te]=B*(x[te]-ge)/Te;const Ve=h.IndexDatatype.createTypedArray(g.length,P);let Ne;if(Y){const e=new Uint8Array(w);s.push(Me.buffer,Ve.buffer,e.buffer),Ne=e.buffer}else s.push(Me.buffer,Ve.buffer);return{vertices:Me.buffer,encodedNormals:Ne,indices:Ve.buffer,minimumHeight:ge,maximumHeight:me,westIndices:le,southIndices:ae,eastIndices:fe,northIndices:ce,boundingSphere:Ie,orientedBoundingBox:Ae,horizonOcclusionPoint:ve}}))}));