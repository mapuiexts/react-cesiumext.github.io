/*! For license information please see upsampleQuantizedTerrainMesh.js.LICENSE.txt */
define(["./AttributeCompression-5744d52e","./Transforms-d3d3b2a9","./Matrix2-73789715","./defaultValue-97284df2","./TerrainEncoding-080f16eb","./IndexDatatype-65271ba3","./RuntimeError-4f8ec8a2","./ComponentDatatype-e7fbe225","./OrientedBoundingBox-ee3011f6","./createTaskProcessorWorker","./_commonjsHelpers-3aae1032-65601a27","./combine-d11b1f00","./WebGLConstants-6da700a2","./EllipsoidTangentPlane-7ae496b2","./AxisAlignedBoundingBox-b1c095aa","./IntersectionTests-33ace2d6","./Plane-e916220d"],(function(e,t,n,i,s,h,r,u,o,p,d,a,l,f,c,g,m){"use strict";const x_clipTriangleAtAxisAlignedThreshold=function(e,t,n,s,h,r){let u,o,p;i.defined(r)?r.length=0:r=[],t?(u=n<e,o=s<e,p=h<e):(u=n>e,o=s>e,p=h>e);const d=u+o+p;let a,l,f,c,g,m;return 1===d?u?(a=(e-n)/(s-n),l=(e-n)/(h-n),r.push(1),r.push(2),1!==l&&(r.push(-1),r.push(0),r.push(2),r.push(l)),1!==a&&(r.push(-1),r.push(0),r.push(1),r.push(a))):o?(f=(e-s)/(h-s),c=(e-s)/(n-s),r.push(2),r.push(0),1!==c&&(r.push(-1),r.push(1),r.push(0),r.push(c)),1!==f&&(r.push(-1),r.push(1),r.push(2),r.push(f))):p&&(g=(e-h)/(n-h),m=(e-h)/(s-h),r.push(0),r.push(1),1!==m&&(r.push(-1),r.push(2),r.push(1),r.push(m)),1!==g&&(r.push(-1),r.push(2),r.push(0),r.push(g))):2===d?u||n===e?o||s===e?p||h===e||(l=(e-n)/(h-n),f=(e-s)/(h-s),r.push(2),r.push(-1),r.push(0),r.push(2),r.push(l),r.push(-1),r.push(1),r.push(2),r.push(f)):(m=(e-h)/(s-h),a=(e-n)/(s-n),r.push(1),r.push(-1),r.push(2),r.push(1),r.push(m),r.push(-1),r.push(0),r.push(1),r.push(a)):(c=(e-s)/(n-s),g=(e-h)/(n-h),r.push(0),r.push(-1),r.push(1),r.push(0),r.push(c),r.push(-1),r.push(2),r.push(0),r.push(g)):3!==d&&(r.push(0),r.push(1),r.push(2)),r},x=32767,w=16383,C=[],B=[],y=[],I=new n.Cartographic;let b=new n.Cartesian3;const v=[],A=[],V=[],z=[],M=[],N=new n.Cartesian3,E=new t.BoundingSphere,H=new o.OrientedBoundingBox,R=new n.Cartesian2,T=new n.Cartesian3;function S(){this.vertexBuffer=void 0,this.index=void 0,this.first=void 0,this.second=void 0,this.ratio=void 0}S.prototype.clone=function(e){return i.defined(e)||(e=new S),e.uBuffer=this.uBuffer,e.vBuffer=this.vBuffer,e.heightBuffer=this.heightBuffer,e.normalBuffer=this.normalBuffer,e.index=this.index,e.first=this.first,e.second=this.second,e.ratio=this.ratio,e},S.prototype.initializeIndexed=function(e,t,n,i,s){this.uBuffer=e,this.vBuffer=t,this.heightBuffer=n,this.normalBuffer=i,this.index=s,this.first=void 0,this.second=void 0,this.ratio=void 0},S.prototype.initializeFromClipResult=function(e,t,n){let i=t+1;return-1!==e[t]?n[e[t]].clone(this):(this.vertexBuffer=void 0,this.index=void 0,this.first=n[e[i]],++i,this.second=n[e[i]],++i,this.ratio=e[i],++i),i},S.prototype.getKey=function(){return this.isIndexed()?this.index:JSON.stringify({first:this.first.getKey(),second:this.second.getKey(),ratio:this.ratio})},S.prototype.isIndexed=function(){return i.defined(this.index)},S.prototype.getH=function(){return i.defined(this.index)?this.heightBuffer[this.index]:u.CesiumMath.lerp(this.first.getH(),this.second.getH(),this.ratio)},S.prototype.getU=function(){return i.defined(this.index)?this.uBuffer[this.index]:u.CesiumMath.lerp(this.first.getU(),this.second.getU(),this.ratio)},S.prototype.getV=function(){return i.defined(this.index)?this.vBuffer[this.index]:u.CesiumMath.lerp(this.first.getV(),this.second.getV(),this.ratio)};let O=new n.Cartesian2,U=-1;const F=[new n.Cartesian3,new n.Cartesian3],P=[new n.Cartesian3,new n.Cartesian3];function W(t,i){++U;let s=F[U],h=P[U];return s=e.AttributeCompression.octDecode(t.first.getNormalX(),t.first.getNormalY(),s),h=e.AttributeCompression.octDecode(t.second.getNormalX(),t.second.getNormalY(),h),b=n.Cartesian3.lerp(s,h,t.ratio,b),n.Cartesian3.normalize(b,b),e.AttributeCompression.octEncode(b,i),--U,i}S.prototype.getNormalX=function(){return i.defined(this.index)?this.normalBuffer[2*this.index]:(O=W(this,O),O.x)},S.prototype.getNormalY=function(){return i.defined(this.index)?this.normalBuffer[2*this.index+1]:(O=W(this,O),O.y)};const D=[];function k(e,t,n,s,h,r,u,o,p){if(0===u.length)return;let d=0,a=0;for(;a<u.length;)a=D[d++].initializeFromClipResult(u,a,o);for(let h=0;h<d;++h){const u=D[h];if(u.isIndexed())u.newIndex=r[u.index],u.uBuffer=e,u.vBuffer=t,u.heightBuffer=n,p&&(u.normalBuffer=s);else{const h=u.getKey();if(i.defined(r[h]))u.newIndex=r[h];else{const i=e.length;e.push(u.getU()),t.push(u.getV()),n.push(u.getH()),p&&(s.push(u.getNormalX()),s.push(u.getNormalY())),u.newIndex=i,r[h]=i}}}3===d?(h.push(D[0].newIndex),h.push(D[1].newIndex),h.push(D[2].newIndex)):4===d&&(h.push(D[0].newIndex),h.push(D[1].newIndex),h.push(D[2].newIndex),h.push(D[0].newIndex),h.push(D[2].newIndex),h.push(D[3].newIndex))}return D.push(new S),D.push(new S),D.push(new S),D.push(new S),p((function(e,i){const r=e.isEastChild,p=e.isNorthChild,d=r?w:0,a=r?x:w,l=p?w:0,f=p?x:w,c=v,g=A,m=V,O=M;c.length=0,g.length=0,m.length=0,O.length=0;const U=z;U.length=0;const F={},P=e.vertices;let D=e.indices;D=D.subarray(0,e.indexCountWithoutSkirts);const X=s.TerrainEncoding.clone(e.encoding),K=X.hasVertexNormals;let Y=0;const _=e.vertexCountWithoutSkirts,L=e.minimumHeight,j=e.maximumHeight,G=new Array(_),J=new Array(_),Z=new Array(_),q=K?new Array(2*_):void 0;let Q,$,ee,te,ne;for($=0,ee=0;$<_;++$,ee+=2){const e=X.decodeTextureCoordinates(P,$,R);if(Q=X.decodeHeight(P,$),te=u.CesiumMath.clamp(e.x*x|0,0,x),ne=u.CesiumMath.clamp(e.y*x|0,0,x),Z[$]=u.CesiumMath.clamp((Q-L)/(j-L)*x|0,0,x),te<20&&(te=0),ne<20&&(ne=0),x-te<20&&(te=x),x-ne<20&&(ne=x),G[$]=te,J[$]=ne,K){const e=X.getOctEncodedNormal(P,$,T);q[ee]=e.x,q[ee+1]=e.y}(r&&te>=w||!r&&te<=w)&&(p&&ne>=w||!p&&ne<=w)&&(F[$]=Y,c.push(te),g.push(ne),m.push(Z[$]),K&&(O.push(q[ee]),O.push(q[ee+1])),++Y)}const ie=[];ie.push(new S),ie.push(new S),ie.push(new S);const se=[];let he,re;for(se.push(new S),se.push(new S),se.push(new S),$=0;$<D.length;$+=3){const e=D[$],t=D[$+1],n=D[$+2],i=G[e],s=G[t],h=G[n];ie[0].initializeIndexed(G,J,Z,q,e),ie[1].initializeIndexed(G,J,Z,q,t),ie[2].initializeIndexed(G,J,Z,q,n);const u=x_clipTriangleAtAxisAlignedThreshold(w,r,i,s,h,C);he=0,he>=u.length||(he=se[0].initializeFromClipResult(u,he,ie),he>=u.length||(he=se[1].initializeFromClipResult(u,he,ie),he>=u.length||(he=se[2].initializeFromClipResult(u,he,ie),re=x_clipTriangleAtAxisAlignedThreshold(w,p,se[0].getV(),se[1].getV(),se[2].getV(),B),k(c,g,m,O,U,F,re,se,K),he<u.length&&(se[2].clone(se[1]),se[2].initializeFromClipResult(u,he,ie),re=x_clipTriangleAtAxisAlignedThreshold(w,p,se[0].getV(),se[1].getV(),se[2].getV(),B),k(c,g,m,O,U,F,re,se,K)))))}const ue=r?-32767:0,oe=p?-32767:0,pe=[],de=[],ae=[],le=[];let fe=Number.MAX_VALUE,ce=-fe;const ge=y;ge.length=0;const me=n.Ellipsoid.clone(e.ellipsoid),xe=n.Rectangle.clone(e.childRectangle),we=xe.north,Ce=xe.south;let Be=xe.east;const ye=xe.west;for(Be<ye&&(Be+=u.CesiumMath.TWO_PI),$=0;$<c.length;++$)te=Math.round(c[$]),te<=d?(pe.push($),te=0):te>=a?(ae.push($),te=x):te=2*te+ue,c[$]=te,ne=Math.round(g[$]),ne<=l?(de.push($),ne=0):ne>=f?(le.push($),ne=x):ne=2*ne+oe,g[$]=ne,Q=u.CesiumMath.lerp(L,j,m[$]/x),Q<fe&&(fe=Q),Q>ce&&(ce=Q),m[$]=Q,I.longitude=u.CesiumMath.lerp(ye,Be,te/x),I.latitude=u.CesiumMath.lerp(Ce,we,ne/x),I.height=Q,me.cartographicToCartesian(I,b),ge.push(b.x),ge.push(b.y),ge.push(b.z);const Se=t.BoundingSphere.fromVertices(ge,n.Cartesian3.ZERO,3,E),Ie=o.OrientedBoundingBox.fromRectangle(xe,fe,ce,me,H),be=new s.EllipsoidalOccluder(me).computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid(Se.center,ge,3,Se.center,fe,N),ve=ce-fe,Ae=new Uint16Array(c.length+g.length+m.length);for($=0;$<c.length;++$)Ae[$]=c[$];let Ve=c.length;for($=0;$<g.length;++$)Ae[Ve+$]=g[$];for(Ve+=g.length,$=0;$<m.length;++$)Ae[Ve+$]=x*(m[$]-fe)/ve;const ze=h.IndexDatatype.createTypedArray(c.length,U);let Me;if(K){const e=new Uint8Array(O);i.push(Ae.buffer,ze.buffer,e.buffer),Me=e.buffer}else i.push(Ae.buffer,ze.buffer);return{vertices:Ae.buffer,encodedNormals:Me,indices:ze.buffer,minimumHeight:fe,maximumHeight:ce,westIndices:pe,southIndices:de,eastIndices:ae,northIndices:le,boundingSphere:Se,orientedBoundingBox:Ie,horizonOcclusionPoint:be}}))}));