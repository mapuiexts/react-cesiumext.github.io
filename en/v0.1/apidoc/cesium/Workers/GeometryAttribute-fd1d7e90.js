/*! For license information please see GeometryAttribute-fd1d7e90.js.LICENSE.txt */
define(["exports","./Matrix2-73789715","./RuntimeError-4f8ec8a2","./defaultValue-97284df2","./WebGLConstants-6da700a2","./Transforms-d3d3b2a9"],(function(t,e,n,a,r,i){"use strict";var o=Object.freeze({NONE:0,TRIANGLES:1,LINES:2,POLYLINES:3});const s={POINTS:r.WebGLConstants.POINTS,LINES:r.WebGLConstants.LINES,LINE_LOOP:r.WebGLConstants.LINE_LOOP,LINE_STRIP:r.WebGLConstants.LINE_STRIP,TRIANGLES:r.WebGLConstants.TRIANGLES,TRIANGLE_STRIP:r.WebGLConstants.TRIANGLE_STRIP,TRIANGLE_FAN:r.WebGLConstants.TRIANGLE_FAN,isLines:function(t){return t===s.LINES||t===s.LINE_LOOP||t===s.LINE_STRIP},isTriangles:function(t){return t===s.TRIANGLES||t===s.TRIANGLE_STRIP||t===s.TRIANGLE_FAN},validate:function(t){return t===s.POINTS||t===s.LINES||t===s.LINE_LOOP||t===s.LINE_STRIP||t===s.TRIANGLES||t===s.TRIANGLE_STRIP||t===s.TRIANGLE_FAN}};var u=Object.freeze(s);function I(t){t=a.defaultValue(t,a.defaultValue.EMPTY_OBJECT),this.attributes=t.attributes,this.indices=t.indices,this.primitiveType=a.defaultValue(t.primitiveType,u.TRIANGLES),this.boundingSphere=t.boundingSphere,this.geometryType=a.defaultValue(t.geometryType,o.NONE),this.boundingSphereCV=t.boundingSphereCV,this.offsetAttribute=t.offsetAttribute}I.computeNumberOfVertices=function(t){let e=-1;for(const n in t.attributes)if(t.attributes.hasOwnProperty(n)&&a.defined(t.attributes[n])&&a.defined(t.attributes[n].values)){const a=t.attributes[n];e=a.values.length/a.componentsPerAttribute}return e};const N=new e.Cartographic,T=new e.Cartesian3,c=new e.Matrix4,l=[new e.Cartographic,new e.Cartographic,new e.Cartographic],L=[new e.Cartesian2,new e.Cartesian2,new e.Cartesian2],E=[new e.Cartesian2,new e.Cartesian2,new e.Cartesian2],f=new e.Cartesian3,m=new i.Quaternion,p=new e.Matrix4,y=new e.Matrix2;I._textureCoordinateRotationPoints=function(t,n,a,r){let o;const s=e.Rectangle.center(r,N),u=e.Cartographic.toCartesian(s,a,T),b=i.Transforms.eastNorthUpToFixedFrame(u,a,c),C=e.Matrix4.inverse(b,c),d=L,h=l;h[0].longitude=r.west,h[0].latitude=r.south,h[1].longitude=r.west,h[1].latitude=r.north,h[2].longitude=r.east,h[2].latitude=r.south;let A=f;for(o=0;o<3;o++)e.Cartographic.toCartesian(h[o],a,A),A=e.Matrix4.multiplyByPointAsVector(C,A,A),d[o].x=A.x,d[o].y=A.y;const x=i.Quaternion.fromAxisAngle(e.Cartesian3.UNIT_Z,-n,m),S=e.Matrix3.fromQuaternion(x,p),P=t.length;let G=Number.POSITIVE_INFINITY,R=Number.POSITIVE_INFINITY,_=Number.NEGATIVE_INFINITY,O=Number.NEGATIVE_INFINITY;for(o=0;o<P;o++)A=e.Matrix4.multiplyByPointAsVector(C,t[o],A),A=e.Matrix3.multiplyByVector(S,A,A),G=Math.min(G,A.x),R=Math.min(R,A.y),_=Math.max(_,A.x),O=Math.max(O,A.y);const g=e.Matrix2.fromRotation(n,y),w=E;w[0].x=G,w[0].y=R,w[1].x=G,w[1].y=O,w[2].x=_,w[2].y=R;const V=d[0],M=d[2].x-V.x,v=d[1].y-V.y;for(o=0;o<3;o++){const t=w[o];e.Matrix2.multiplyByVector(g,t,t),t.x=(t.x-V.x)/M,t.y=(t.y-V.y)/v}const F=w[0],W=w[1],Y=w[2],B=new Array(6);return e.Cartesian2.pack(F,B),e.Cartesian2.pack(W,B,2),e.Cartesian2.pack(Y,B,4),B},t.Geometry=I,t.GeometryAttribute=function(t){t=a.defaultValue(t,a.defaultValue.EMPTY_OBJECT),this.componentDatatype=t.componentDatatype,this.componentsPerAttribute=t.componentsPerAttribute,this.normalize=a.defaultValue(t.normalize,!1),this.values=t.values},t.GeometryType=o,t.PrimitiveType=u}));