define(["exports","./AttributeCompression-50c9aeba","./Matrix2-7146c9ca","./Matrix3-a348023f","./defaultValue-0a909f67","./Math-e97915da","./Transforms-01e95659","./ComponentDatatype-77274976","./EncodedCartesian3-0fb84db0","./GeometryAttribute-f5d71750","./IndexDatatype-2149f06c","./IntersectionTests-0bb04fde","./Plane-8575e17c"],(function(e,t,n,i,r,a,o,u,c,l,p,d,f){"use strict";const y=new i.Cartesian3,m=new i.Cartesian3,C=new i.Cartesian3,h={calculateACMR:function(e){const t=(e=r.defaultValue(e,r.defaultValue.EMPTY_OBJECT)).indices;let n=e.maximumIndex;const i=r.defaultValue(e.cacheSize,24),a=t.length;if(!r.defined(n)){n=0;let e=0,i=t[e];for(;e<a;)i>n&&(n=i),++e,i=t[e]}const o=[];for(let e=0;e<n+1;e++)o[e]=0;let u=i+1;for(let e=0;e<a;++e)u-o[t[e]]>i&&(o[t[e]]=u,++u);return(u-i+1)/(a/3)},tipsify:function(e){const t=(e=r.defaultValue(e,r.defaultValue.EMPTY_OBJECT)).indices,n=e.maximumIndex,i=r.defaultValue(e.cacheSize,24);let a;function s(e,t,n,i,r,o,u){let c,l=-1,p=-1,d=0;for(;d<n.length;){const e=n[d];i[e].numLiveTriangles&&(c=0,r-i[e].timeStamp+2*i[e].numLiveTriangles<=t&&(c=r-i[e].timeStamp),(c>p||-1===p)&&(p=c,l=e)),++d}return-1===l?function(e,t,n,i){for(;t.length>=1;){const n=t[t.length-1];if(t.splice(t.length-1,1),e[n].numLiveTriangles>0)return n}for(;a<i;){if(e[a].numLiveTriangles>0)return++a,a-1;++a}return-1}(i,o,0,u):l}const o=t.length;let u=0,c=0,l=t[c];const p=o;if(r.defined(n))u=n+1;else{for(;c<p;)l>u&&(u=l),++c,l=t[c];if(-1===u)return 0;++u}const d=[];let f;for(f=0;f<u;f++)d[f]={numLiveTriangles:0,timeStamp:0,vertexTriangles:[]};c=0;let y=0;for(;c<p;)d[t[c]].vertexTriangles.push(y),++d[t[c]].numLiveTriangles,d[t[c+1]].vertexTriangles.push(y),++d[t[c+1]].numLiveTriangles,d[t[c+2]].vertexTriangles.push(y),++d[t[c+2]].numLiveTriangles,++y,c+=3;let m=0,C=i+1;a=1;let h=[];const v=[];let T,x,P=0;const w=[],O=o/3,E=[];for(f=0;f<O;f++)E[f]=!1;let N,M;for(;-1!==m;){h=[],x=d[m],M=x.vertexTriangles.length;for(let e=0;e<M;++e)if(y=x.vertexTriangles[e],!E[y]){E[y]=!0,c=y+y+y;for(let e=0;e<3;++e)N=t[c],h.push(N),v.push(N),w[P]=N,++P,T=d[N],--T.numLiveTriangles,C-T.timeStamp>i&&(T.timeStamp=C,++C),++c}m=s(0,i,h,d,C,v,u)}return w}};var v=h;const T={};function b(e,t,n,i,r){e[t++]=n,e[t++]=i,e[t++]=i,e[t++]=r,e[t++]=r,e[t]=n}function g(e){const t={};for(const n in e)if(e.hasOwnProperty(n)&&r.defined(e[n])&&r.defined(e[n].values)){const i=e[n];t[n]=new l.GeometryAttribute({componentDatatype:i.componentDatatype,componentsPerAttribute:i.componentsPerAttribute,normalize:i.normalize,values:[]})}return t}function A(e,t,n){for(const i in t)if(t.hasOwnProperty(i)&&r.defined(t[i])&&r.defined(t[i].values)){const r=t[i];for(let t=0;t<r.componentsPerAttribute;++t)e[i].values.push(r.values[n*r.componentsPerAttribute+t])}}T.toWireframe=function(e){const t=e.indices;if(r.defined(t)){switch(e.primitiveType){case l.PrimitiveType.TRIANGLES:e.indices=function(e){const t=e.length,n=t/3*6,i=p.IndexDatatype.createTypedArray(t,n);let r=0;for(let n=0;n<t;n+=3,r+=6)b(i,r,e[n],e[n+1],e[n+2]);return i}(t);break;case l.PrimitiveType.TRIANGLE_STRIP:e.indices=function(e){const t=e.length;if(t>=3){const n=6*(t-2),i=p.IndexDatatype.createTypedArray(t,n);b(i,0,e[0],e[1],e[2]);let r=6;for(let n=3;n<t;++n,r+=6)b(i,r,e[n-1],e[n],e[n-2]);return i}return new Uint16Array}(t);break;case l.PrimitiveType.TRIANGLE_FAN:e.indices=function(e){if(e.length>0){const t=e.length-1,n=6*(t-1),i=p.IndexDatatype.createTypedArray(t,n),r=e[0];let a=0;for(let n=1;n<t;++n,a+=6)b(i,a,r,e[n],e[n+1]);return i}return new Uint16Array}(t)}e.primitiveType=l.PrimitiveType.LINES}return e},T.createLineSegmentsForVectors=function(e,t,n){t=r.defaultValue(t,"normal"),n=r.defaultValue(n,1e4);const i=e.attributes.position.values,a=e.attributes[t].values,c=i.length,p=new Float64Array(2*c);let d,f=0;for(let e=0;e<c;e+=3)p[f++]=i[e],p[f++]=i[e+1],p[f++]=i[e+2],p[f++]=i[e]+a[e]*n,p[f++]=i[e+1]+a[e+1]*n,p[f++]=i[e+2]+a[e+2]*n;const y=e.boundingSphere;return r.defined(y)&&(d=new o.BoundingSphere(y.center,y.radius+n)),new l.Geometry({attributes:{position:new l.GeometryAttribute({componentDatatype:u.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:p})},primitiveType:l.PrimitiveType.LINES,boundingSphere:d})},T.createAttributeLocations=function(e){const t=["position","positionHigh","positionLow","position3DHigh","position3DLow","position2DHigh","position2DLow","pickColor","normal","st","tangent","bitangent","extrudeDirection","compressedAttributes"],n=e.attributes,i={};let a,o=0;const u=t.length;for(a=0;a<u;++a){const e=t[a];r.defined(n[e])&&(i[e]=o++)}for(const e in n)n.hasOwnProperty(e)&&!r.defined(i[e])&&(i[e]=o++);return i},T.reorderForPreVertexCache=function(e){const t=l.Geometry.computeNumberOfVertices(e),n=e.indices;if(r.defined(n)){const i=new Int32Array(t);for(let e=0;e<t;e++)i[e]=-1;const a=n,o=a.length,c=p.IndexDatatype.createTypedArray(t,o);let l,d=0,f=0,y=0;for(;d<o;)l=i[a[d]],-1!==l?c[f]=l:(l=a[d],i[l]=y,c[f]=y,++y),++d,++f;e.indices=c;const m=e.attributes;for(const e in m)if(m.hasOwnProperty(e)&&r.defined(m[e])&&r.defined(m[e].values)){const n=m[e],r=n.values;let a=0;const o=n.componentsPerAttribute,c=u.ComponentDatatype.createTypedArray(n.componentDatatype,y*o);for(;a<t;){const e=i[a];if(-1!==e)for(let t=0;t<o;t++)c[o*e+t]=r[o*a+t];++a}n.values=c}}return e},T.reorderForPostVertexCache=function(e,t){const n=e.indices;if(e.primitiveType===l.PrimitiveType.TRIANGLES&&r.defined(n)){const i=n.length;let r=0;for(let e=0;e<i;e++)n[e]>r&&(r=n[e]);e.indices=v.tipsify({indices:n,maximumIndex:r,cacheSize:t})}return e},T.fitToUnsignedShortIndices=function(e){const t=[],n=l.Geometry.computeNumberOfVertices(e);if(r.defined(e.indices)&&n>=a.CesiumMath.SIXTY_FOUR_KILOBYTES){let n=[],i=[],o=0,u=g(e.attributes);const c=e.indices,p=c.length;let d;e.primitiveType===l.PrimitiveType.TRIANGLES?d=3:e.primitiveType===l.PrimitiveType.LINES?d=2:e.primitiveType===l.PrimitiveType.POINTS&&(d=1);for(let f=0;f<p;f+=d){for(let t=0;t<d;++t){const a=c[f+t];let l=n[a];r.defined(l)||(l=o++,n[a]=l,A(u,e.attributes,a)),i.push(l)}o+d>=a.CesiumMath.SIXTY_FOUR_KILOBYTES&&(t.push(new l.Geometry({attributes:u,indices:i,primitiveType:e.primitiveType,boundingSphere:e.boundingSphere,boundingSphereCV:e.boundingSphereCV})),n=[],i=[],o=0,u=g(e.attributes))}0!==i.length&&t.push(new l.Geometry({attributes:u,indices:i,primitiveType:e.primitiveType,boundingSphere:e.boundingSphere,boundingSphereCV:e.boundingSphereCV}))}else t.push(e);return t};const x=new i.Cartesian3,P=new i.Cartographic;T.projectTo2D=function(e,t,n,a,c){const p=e.attributes[t],d=(c=r.defined(c)?c:new o.GeographicProjection).ellipsoid,f=p.values,y=new Float64Array(f.length);let m=0;for(let e=0;e<f.length;e+=3){const t=i.Cartesian3.fromArray(f,e,x),n=d.cartesianToCartographic(t,P),r=c.project(n,x);y[m++]=r.x,y[m++]=r.y,y[m++]=r.z}return e.attributes[n]=p,e.attributes[a]=new l.GeometryAttribute({componentDatatype:u.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:y}),delete e.attributes[t],e};const w={high:0,low:0};T.encodeAttribute=function(e,t,n,i){const r=e.attributes[t],a=r.values,o=a.length,p=new Float32Array(o),d=new Float32Array(o);for(let e=0;e<o;++e)c.EncodedCartesian3.encode(a[e],w),p[e]=w.high,d[e]=w.low;const f=r.componentsPerAttribute;return e.attributes[n]=new l.GeometryAttribute({componentDatatype:u.ComponentDatatype.FLOAT,componentsPerAttribute:f,values:p}),e.attributes[i]=new l.GeometryAttribute({componentDatatype:u.ComponentDatatype.FLOAT,componentsPerAttribute:f,values:d}),delete e.attributes[t],e};let O=new i.Cartesian3;function S(e,t){if(r.defined(t)){const r=t.values,a=r.length;for(let t=0;t<a;t+=3)i.Cartesian3.unpack(r,t,O),n.Matrix4.multiplyByPoint(e,O,O),i.Cartesian3.pack(O,r,t)}}function I(e,t){if(r.defined(t)){const n=t.values,r=n.length;for(let t=0;t<r;t+=3)i.Cartesian3.unpack(n,t,O),i.Matrix3.multiplyByVector(e,O,O),O=i.Cartesian3.normalize(O,O),i.Cartesian3.pack(O,n,t)}}const E=new n.Matrix4,N=new i.Matrix3;T.transformToWorldCoordinates=function(e){const t=e.modelMatrix;if(n.Matrix4.equals(t,n.Matrix4.IDENTITY))return e;const i=e.geometry.attributes;S(t,i.position),S(t,i.prevPosition),S(t,i.nextPosition),(r.defined(i.normal)||r.defined(i.tangent)||r.defined(i.bitangent))&&(n.Matrix4.inverse(t,E),n.Matrix4.transpose(E,E),n.Matrix4.getMatrix3(E,N),I(N,i.normal),I(N,i.tangent),I(N,i.bitangent));const a=e.geometry.boundingSphere;return r.defined(a)&&(e.geometry.boundingSphere=o.BoundingSphere.transform(a,t,a)),e.modelMatrix=n.Matrix4.clone(n.Matrix4.IDENTITY),e};const M=new i.Cartesian3;function L(e,t){const n=e.length;let a,c,d,f;e[0].modelMatrix;const y=r.defined(e[0][t].indices),m=e[0][t].primitiveType,C=function(e,t){const n=e.length,i={},a=e[0][t].attributes;let o;for(o in a)if(a.hasOwnProperty(o)&&r.defined(a[o])&&r.defined(a[o].values)){const c=a[o];let p=c.values.length,d=!0;for(let i=1;i<n;++i){const n=e[i][t].attributes[o];if(!r.defined(n)||c.componentDatatype!==n.componentDatatype||c.componentsPerAttribute!==n.componentsPerAttribute||c.normalize!==n.normalize){d=!1;break}p+=n.values.length}d&&(i[o]=new l.GeometryAttribute({componentDatatype:c.componentDatatype,componentsPerAttribute:c.componentsPerAttribute,normalize:c.normalize,values:u.ComponentDatatype.createTypedArray(c.componentDatatype,p)}))}return i}(e,t);let h,v,T,x;for(a in C)if(C.hasOwnProperty(a))for(h=C[a].values,f=0,c=0;c<n;++c)for(v=e[c][t].attributes[a].values,T=v.length,d=0;d<T;++d)h[f++]=v[d];if(y){let i=0;for(c=0;c<n;++c)i+=e[c][t].indices.length;const r=l.Geometry.computeNumberOfVertices(new l.Geometry({attributes:C,primitiveType:l.PrimitiveType.POINTS})),a=p.IndexDatatype.createTypedArray(r,i);let o=0,u=0;for(c=0;c<n;++c){const n=e[c][t].indices,i=n.length;for(f=0;f<i;++f)a[o++]=u+n[f];u+=l.Geometry.computeNumberOfVertices(e[c][t])}x=a}let P,w=new i.Cartesian3,O=0;for(c=0;c<n;++c){if(P=e[c][t].boundingSphere,!r.defined(P)){w=void 0;break}i.Cartesian3.add(P.center,w,w)}if(r.defined(w))for(i.Cartesian3.divideByScalar(w,n,w),c=0;c<n;++c){P=e[c][t].boundingSphere;const n=i.Cartesian3.magnitude(i.Cartesian3.subtract(P.center,w,M))+P.radius;n>O&&(O=n)}return new l.Geometry({attributes:C,indices:x,primitiveType:m,boundingSphere:r.defined(w)?new o.BoundingSphere(w,O):void 0})}T.combineInstances=function(e){const t=[],n=[],i=e.length;for(let a=0;a<i;++a){const i=e[a];r.defined(i.geometry)?t.push(i):r.defined(i.westHemisphereGeometry)&&r.defined(i.eastHemisphereGeometry)&&n.push(i)}const a=[];return t.length>0&&a.push(L(t,"geometry")),n.length>0&&(a.push(L(n,"westHemisphereGeometry")),a.push(L(n,"eastHemisphereGeometry"))),a};const z=new i.Cartesian3,D=new i.Cartesian3,G=new i.Cartesian3,V=new i.Cartesian3;T.computeNormal=function(e){const t=e.indices,n=e.attributes,r=n.position.values,o=n.position.values.length/3,c=t.length,p=new Array(o),d=new Array(c/3),f=new Array(c);let y;for(y=0;y<o;y++)p[y]={indexOffset:0,count:0,currentCount:0};let m=0;for(y=0;y<c;y+=3){const e=t[y],n=t[y+1],a=t[y+2],o=3*e,u=3*n,c=3*a;D.x=r[o],D.y=r[o+1],D.z=r[o+2],G.x=r[u],G.y=r[u+1],G.z=r[u+2],V.x=r[c],V.y=r[c+1],V.z=r[c+2],p[e].count++,p[n].count++,p[a].count++,i.Cartesian3.subtract(G,D,G),i.Cartesian3.subtract(V,D,V),d[m]=i.Cartesian3.cross(G,V,new i.Cartesian3),m++}let C,h=0;for(y=0;y<o;y++)p[y].indexOffset+=h,h+=p[y].count;for(m=0,y=0;y<c;y+=3){C=p[t[y]];let e=C.indexOffset+C.currentCount;f[e]=m,C.currentCount++,C=p[t[y+1]],e=C.indexOffset+C.currentCount,f[e]=m,C.currentCount++,C=p[t[y+2]],e=C.indexOffset+C.currentCount,f[e]=m,C.currentCount++,m++}const v=new Float32Array(3*o);for(y=0;y<o;y++){const e=3*y;if(C=p[y],i.Cartesian3.clone(i.Cartesian3.ZERO,z),C.count>0){for(m=0;m<C.count;m++)i.Cartesian3.add(z,d[f[C.indexOffset+m]],z);i.Cartesian3.equalsEpsilon(i.Cartesian3.ZERO,z,a.CesiumMath.EPSILON10)&&i.Cartesian3.clone(d[f[C.indexOffset]],z)}i.Cartesian3.equalsEpsilon(i.Cartesian3.ZERO,z,a.CesiumMath.EPSILON10)&&(z.z=1),i.Cartesian3.normalize(z,z),v[e]=z.x,v[e+1]=z.y,v[e+2]=z.z}return e.attributes.normal=new l.GeometryAttribute({componentDatatype:u.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:v}),e};const R=new i.Cartesian3,F=new i.Cartesian3,B=new i.Cartesian3;T.computeTangentAndBitangent=function(e){e.attributes;const t=e.indices,n=e.attributes.position.values,r=e.attributes.normal.values,a=e.attributes.st.values,o=e.attributes.position.values.length/3,c=t.length,p=new Array(3*o);let d,f,y,m;for(d=0;d<p.length;d++)p[d]=0;for(d=0;d<c;d+=3){const e=t[d],i=t[d+1],r=t[d+2];f=3*e,y=3*i,m=3*r;const o=2*e,u=2*i,c=2*r,l=n[f],C=n[f+1],h=n[f+2],v=a[o],T=a[o+1],x=a[u+1]-T,P=a[c+1]-T,w=1/((a[u]-v)*P-(a[c]-v)*x),O=(P*(n[y]-l)-x*(n[m]-l))*w,E=(P*(n[y+1]-C)-x*(n[m+1]-C))*w,N=(P*(n[y+2]-h)-x*(n[m+2]-h))*w;p[f]+=O,p[f+1]+=E,p[f+2]+=N,p[y]+=O,p[y+1]+=E,p[y+2]+=N,p[m]+=O,p[m+1]+=E,p[m+2]+=N}const C=new Float32Array(3*o),h=new Float32Array(3*o);for(d=0;d<o;d++){f=3*d,y=f+1,m=f+2;const e=i.Cartesian3.fromArray(r,f,R),t=i.Cartesian3.fromArray(p,f,B),n=i.Cartesian3.dot(e,t);i.Cartesian3.multiplyByScalar(e,n,F),i.Cartesian3.normalize(i.Cartesian3.subtract(t,F,t),t),C[f]=t.x,C[y]=t.y,C[m]=t.z,i.Cartesian3.normalize(i.Cartesian3.cross(e,t,t),t),h[f]=t.x,h[y]=t.y,h[m]=t.z}return e.attributes.tangent=new l.GeometryAttribute({componentDatatype:u.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:C}),e.attributes.bitangent=new l.GeometryAttribute({componentDatatype:u.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:h}),e};const _=new n.Cartesian2,k=new i.Cartesian3,q=new i.Cartesian3,U=new i.Cartesian3;let H=new n.Cartesian2;function Y(e){switch(e.primitiveType){case l.PrimitiveType.TRIANGLE_FAN:return function(e){const t=l.Geometry.computeNumberOfVertices(e),n=p.IndexDatatype.createTypedArray(t,3*(t-2));n[0]=1,n[1]=0,n[2]=2;let i=3;for(let e=3;e<t;++e)n[i++]=e-1,n[i++]=0,n[i++]=e;return e.indices=n,e.primitiveType=l.PrimitiveType.TRIANGLES,e}(e);case l.PrimitiveType.TRIANGLE_STRIP:return function(e){const t=l.Geometry.computeNumberOfVertices(e),n=p.IndexDatatype.createTypedArray(t,3*(t-2));n[0]=0,n[1]=1,n[2]=2,t>3&&(n[3]=0,n[4]=2,n[5]=3);let i=6;for(let e=3;e<t-1;e+=2)n[i++]=e,n[i++]=e-1,n[i++]=e+1,e+2<t&&(n[i++]=e,n[i++]=e+1,n[i++]=e+2);return e.indices=n,e.primitiveType=l.PrimitiveType.TRIANGLES,e}(e);case l.PrimitiveType.TRIANGLES:return function(e){if(r.defined(e.indices))return e;const t=l.Geometry.computeNumberOfVertices(e),n=p.IndexDatatype.createTypedArray(t,t);for(let e=0;e<t;++e)n[e]=e;return e.indices=n,e}(e);case l.PrimitiveType.LINE_STRIP:return function(e){const t=l.Geometry.computeNumberOfVertices(e),n=p.IndexDatatype.createTypedArray(t,2*(t-1));n[0]=0,n[1]=1;let i=2;for(let e=2;e<t;++e)n[i++]=e-1,n[i++]=e;return e.indices=n,e.primitiveType=l.PrimitiveType.LINES,e}(e);case l.PrimitiveType.LINE_LOOP:return function(e){const t=l.Geometry.computeNumberOfVertices(e),n=p.IndexDatatype.createTypedArray(t,2*t);n[0]=0,n[1]=1;let i=2;for(let e=2;e<t;++e)n[i++]=e-1,n[i++]=e;return n[i++]=t-1,n[i]=0,e.indices=n,e.primitiveType=l.PrimitiveType.LINES,e}(e);case l.PrimitiveType.LINES:return function(e){if(r.defined(e.indices))return e;const t=l.Geometry.computeNumberOfVertices(e),n=p.IndexDatatype.createTypedArray(t,t);for(let e=0;e<t;++e)n[e]=e;return e.indices=n,e}(e)}return e}function Z(e,t){Math.abs(e.y)<a.CesiumMath.EPSILON6&&(e.y=t?-a.CesiumMath.EPSILON6:a.CesiumMath.EPSILON6)}T.compressVertices=function(e){const a=e.attributes.extrudeDirection;let o,c;if(r.defined(a)){const n=a.values;c=n.length/3;const r=new Float32Array(2*c);let p=0;for(o=0;o<c;++o)i.Cartesian3.fromArray(n,3*o,k),i.Cartesian3.equals(k,i.Cartesian3.ZERO)?p+=2:(H=t.AttributeCompression.octEncodeInRange(k,65535,H),r[p++]=H.x,r[p++]=H.y);return e.attributes.compressedAttributes=new l.GeometryAttribute({componentDatatype:u.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:r}),delete e.attributes.extrudeDirection,e}const p=e.attributes.normal,d=e.attributes.st,f=r.defined(p),y=r.defined(d);if(!f&&!y)return e;const m=e.attributes.tangent,C=e.attributes.bitangent,h=r.defined(m),v=r.defined(C);let T,x,P,w;f&&(T=p.values),y&&(x=d.values),h&&(P=m.values),v&&(w=C.values),c=(f?T.length:x.length)/(f?3:2);let O=c,E=y&&f?2:1;E+=h||v?1:0,O*=E;const N=new Float32Array(O);let M=0;for(o=0;o<c;++o){y&&(n.Cartesian2.fromArray(x,2*o,_),N[M++]=t.AttributeCompression.compressTextureCoordinates(_));const e=3*o;f&&r.defined(P)&&r.defined(w)?(i.Cartesian3.fromArray(T,e,k),i.Cartesian3.fromArray(P,e,q),i.Cartesian3.fromArray(w,e,U),t.AttributeCompression.octPack(k,q,U,_),N[M++]=_.x,N[M++]=_.y):(f&&(i.Cartesian3.fromArray(T,e,k),N[M++]=t.AttributeCompression.octEncodeFloat(k)),h&&(i.Cartesian3.fromArray(P,e,k),N[M++]=t.AttributeCompression.octEncodeFloat(k)),v&&(i.Cartesian3.fromArray(w,e,k),N[M++]=t.AttributeCompression.octEncodeFloat(k)))}return e.attributes.compressedAttributes=new l.GeometryAttribute({componentDatatype:u.ComponentDatatype.FLOAT,componentsPerAttribute:E,values:N}),f&&delete e.attributes.normal,y&&delete e.attributes.st,v&&delete e.attributes.bitangent,h&&delete e.attributes.tangent,e};const X=new i.Cartesian3;function W(e,t,n,r){i.Cartesian3.add(e,i.Cartesian3.multiplyByScalar(i.Cartesian3.subtract(t,e,X),e.y/(e.y-t.y),X),n),i.Cartesian3.clone(n,r),Z(n,!0),Z(r,!1)}const j=new i.Cartesian3,J=new i.Cartesian3,K=new i.Cartesian3,Q=new i.Cartesian3,re={positions:new Array(7),indices:new Array(9)};function $(e,t,n){if(e.x>=0||t.x>=0||n.x>=0)return;!function(e,t,n){if(0!==e.y&&0!==t.y&&0!==n.y)return Z(e,e.y<0),Z(t,t.y<0),void Z(n,n.y<0);const i=Math.abs(e.y),r=Math.abs(t.y),o=Math.abs(n.y);let u;u=i>r?i>o?a.CesiumMath.sign(e.y):a.CesiumMath.sign(n.y):r>o?a.CesiumMath.sign(t.y):a.CesiumMath.sign(n.y);const c=u<0;Z(e,c),Z(t,c),Z(n,c)}(e,t,n);const i=e.y<0,r=t.y<0,o=n.y<0;let u=0;u+=i?1:0,u+=r?1:0,u+=o?1:0;const c=re.indices;1===u?(c[1]=3,c[2]=4,c[5]=6,c[7]=6,c[8]=5,i?(W(e,t,j,K),W(e,n,J,Q),c[0]=0,c[3]=1,c[4]=2,c[6]=1):r?(W(t,n,j,K),W(t,e,J,Q),c[0]=1,c[3]=2,c[4]=0,c[6]=2):o&&(W(n,e,j,K),W(n,t,J,Q),c[0]=2,c[3]=0,c[4]=1,c[6]=0)):2===u&&(c[2]=4,c[4]=4,c[5]=3,c[7]=5,c[8]=6,i?r?o||(W(n,e,j,K),W(n,t,J,Q),c[0]=0,c[1]=1,c[3]=0,c[6]=2):(W(t,n,j,K),W(t,e,J,Q),c[0]=2,c[1]=0,c[3]=2,c[6]=1):(W(e,t,j,K),W(e,n,J,Q),c[0]=1,c[1]=2,c[3]=1,c[6]=0));const l=re.positions;return l[0]=e,l[1]=t,l[2]=n,l.length=3,1!==u&&2!==u||(l[3]=j,l[4]=J,l[5]=K,l[6]=Q,l.length=7),re}function ee(e,t){const n=e.attributes;if(0===n.position.values.length)return;for(const e in n)if(n.hasOwnProperty(e)&&r.defined(n[e])&&r.defined(n[e].values)){const t=n[e];t.values=u.ComponentDatatype.createTypedArray(t.componentDatatype,t.values)}const i=l.Geometry.computeNumberOfVertices(e);return e.indices=p.IndexDatatype.createTypedArray(i,e.indices),t&&(e.boundingSphere=o.BoundingSphere.fromVertices(n.position.values)),e}function te(e){const t=e.attributes,n={};for(const e in t)if(t.hasOwnProperty(e)&&r.defined(t[e])&&r.defined(t[e].values)){const i=t[e];n[e]=new l.GeometryAttribute({componentDatatype:i.componentDatatype,componentsPerAttribute:i.componentsPerAttribute,normalize:i.normalize,values:[]})}return new l.Geometry({attributes:n,indices:[],primitiveType:e.primitiveType})}function ne(e,t,n){const i=r.defined(e.geometry.boundingSphere);t=ee(t,i),n=ee(n,i),r.defined(n)&&!r.defined(t)?e.geometry=n:!r.defined(n)&&r.defined(t)?e.geometry=t:(e.westHemisphereGeometry=t,e.eastHemisphereGeometry=n,e.geometry=void 0)}function ie(e,t){const n=new e,i=new e,r=new e;return function(a,o,u,c,l,p,d,f){const y=e.fromArray(l,a*t,n),m=e.fromArray(l,o*t,i),C=e.fromArray(l,u*t,r);e.multiplyByScalar(y,c.x,y),e.multiplyByScalar(m,c.y,m),e.multiplyByScalar(C,c.z,C);const h=e.add(y,m,y);e.add(h,C,h),f&&e.normalize(h,h),e.pack(h,p,d*t)}}const ae=ie(n.Cartesian4,4),se=ie(i.Cartesian3,3),oe=ie(n.Cartesian2,2),ue=new i.Cartesian3,ce=new i.Cartesian3,le=new i.Cartesian3,ye=new i.Cartesian3;function pe(e,t,o,u,c,l,p,d,f,h,v,T,x,P,w,O){if(!(r.defined(l)||r.defined(p)||r.defined(d)||r.defined(f)||r.defined(h)||0!==P))return;const E=function(e,t,o,u,c){let l,p,d,f,h,v,T,x;if(r.defined(c)||(c=new i.Cartesian3),r.defined(t.z)){if(i.Cartesian3.equalsEpsilon(e,t,a.CesiumMath.EPSILON14))return i.Cartesian3.clone(i.Cartesian3.UNIT_X,c);if(i.Cartesian3.equalsEpsilon(e,o,a.CesiumMath.EPSILON14))return i.Cartesian3.clone(i.Cartesian3.UNIT_Y,c);if(i.Cartesian3.equalsEpsilon(e,u,a.CesiumMath.EPSILON14))return i.Cartesian3.clone(i.Cartesian3.UNIT_Z,c);l=i.Cartesian3.subtract(o,t,y),p=i.Cartesian3.subtract(u,t,m),d=i.Cartesian3.subtract(e,t,C),f=i.Cartesian3.dot(l,l),h=i.Cartesian3.dot(l,p),v=i.Cartesian3.dot(l,d),T=i.Cartesian3.dot(p,p),x=i.Cartesian3.dot(p,d)}else{if(n.Cartesian2.equalsEpsilon(e,t,a.CesiumMath.EPSILON14))return i.Cartesian3.clone(i.Cartesian3.UNIT_X,c);if(n.Cartesian2.equalsEpsilon(e,o,a.CesiumMath.EPSILON14))return i.Cartesian3.clone(i.Cartesian3.UNIT_Y,c);if(n.Cartesian2.equalsEpsilon(e,u,a.CesiumMath.EPSILON14))return i.Cartesian3.clone(i.Cartesian3.UNIT_Z,c);l=n.Cartesian2.subtract(o,t,y),p=n.Cartesian2.subtract(u,t,m),d=n.Cartesian2.subtract(e,t,C),f=n.Cartesian2.dot(l,l),h=n.Cartesian2.dot(l,p),v=n.Cartesian2.dot(l,d),T=n.Cartesian2.dot(p,p),x=n.Cartesian2.dot(p,d)}c.y=T*v-h*x,c.z=f*x-h*v;const P=f*T-h*h;if(0!==P)return c.y/=P,c.z/=P,c.x=1-c.y-c.z,c}(u,i.Cartesian3.fromArray(c,3*e,ue),i.Cartesian3.fromArray(c,3*t,ce),i.Cartesian3.fromArray(c,3*o,le),ye);if(r.defined(E)){if(r.defined(l)&&se(e,t,o,E,l,T.normal.values,O,!0),r.defined(h)){const n=i.Cartesian3.fromArray(h,3*e,ue),r=i.Cartesian3.fromArray(h,3*t,ce),a=i.Cartesian3.fromArray(h,3*o,le);let u;i.Cartesian3.multiplyByScalar(n,E.x,n),i.Cartesian3.multiplyByScalar(r,E.y,r),i.Cartesian3.multiplyByScalar(a,E.z,a),i.Cartesian3.equals(n,i.Cartesian3.ZERO)&&i.Cartesian3.equals(r,i.Cartesian3.ZERO)&&i.Cartesian3.equals(a,i.Cartesian3.ZERO)?(u=ue,u.x=0,u.y=0,u.z=0):(u=i.Cartesian3.add(n,r,n),i.Cartesian3.add(u,a,u),i.Cartesian3.normalize(u,u)),i.Cartesian3.pack(u,T.extrudeDirection.values,3*O)}if(r.defined(v)&&function(e,t,n,i,r,o,u){const c=r[e]*i.x,l=r[t]*i.y,p=r[n]*i.z;o[u]=c+l+p>a.CesiumMath.EPSILON6?1:0}(e,t,o,E,v,T.applyOffset.values,O),r.defined(p)&&se(e,t,o,E,p,T.tangent.values,O,!0),r.defined(d)&&se(e,t,o,E,d,T.bitangent.values,O,!0),r.defined(f)&&oe(e,t,o,E,f,T.st.values,O),P>0)for(let n=0;n<P;n++){const i=x[n];de(e,t,o,E,O,w[i],T[i])}}}function de(e,t,n,i,r,a,o){const u=a.componentsPerAttribute,c=a.values,l=o.values;switch(u){case 4:ae(e,t,n,i,c,l,r,!1);break;case 3:se(e,t,n,i,c,l,r,!1);break;case 2:oe(e,t,n,i,c,l,r,!1);break;default:l[r]=c[e]*i.x+c[t]*i.y+c[n]*i.z}}function fe(e,t,n,i,r,a){const o=e.position.values.length/3;if(-1!==r){const u=i[r],c=n[u];return-1===c?(n[u]=o,e.position.values.push(a.x,a.y,a.z),t.push(o),o):(t.push(c),c)}return e.position.values.push(a.x,a.y,a.z),t.push(o),o}const Ce={position:!0,normal:!0,bitangent:!0,tangent:!0,st:!0,extrudeDirection:!0,applyOffset:!0};function me(e){const t=e.geometry,n=t.attributes,a=n.position.values,o=r.defined(n.normal)?n.normal.values:void 0,u=r.defined(n.bitangent)?n.bitangent.values:void 0,c=r.defined(n.tangent)?n.tangent.values:void 0,l=r.defined(n.st)?n.st.values:void 0,p=r.defined(n.extrudeDirection)?n.extrudeDirection.values:void 0,d=r.defined(n.applyOffset)?n.applyOffset.values:void 0,f=t.indices,y=[];for(const e in n)n.hasOwnProperty(e)&&!Ce[e]&&r.defined(n[e])&&y.push(e);const m=y.length,C=te(t),h=te(t);let v,T,x,P,w;const O=[];O.length=a.length/3;const E=[];for(E.length=a.length/3,w=0;w<O.length;++w)O[w]=-1,E[w]=-1;const N=f.length;for(w=0;w<N;w+=3){const e=f[w],t=f[w+1],N=f[w+2];let M=i.Cartesian3.fromArray(a,3*e),z=i.Cartesian3.fromArray(a,3*t),D=i.Cartesian3.fromArray(a,3*N);const G=$(M,z,D);if(r.defined(G)&&G.positions.length>3){const i=G.positions,r=G.indices,M=r.length;for(let z=0;z<M;++z){const M=r[z],D=i[M];D.y<0?(v=h.attributes,T=h.indices,x=O):(v=C.attributes,T=C.indices,x=E),P=fe(v,T,x,f,M<3?w+M:-1,D),pe(e,t,N,D,a,o,c,u,l,p,d,v,y,m,n,P)}}else r.defined(G)&&(M=G.positions[0],z=G.positions[1],D=G.positions[2]),M.y<0?(v=h.attributes,T=h.indices,x=O):(v=C.attributes,T=C.indices,x=E),P=fe(v,T,x,f,w,M),pe(e,t,N,M,a,o,c,u,l,p,d,v,y,m,n,P),P=fe(v,T,x,f,w+1,z),pe(e,t,N,z,a,o,c,u,l,p,d,v,y,m,n,P),P=fe(v,T,x,f,w+2,D),pe(e,t,N,D,a,o,c,u,l,p,d,v,y,m,n,P)}ne(e,h,C)}const he=f.Plane.fromPointNormal(i.Cartesian3.ZERO,i.Cartesian3.UNIT_Y),ve=new i.Cartesian3,Ae=new i.Cartesian3;function be(e,t,n,o,u,c,l){if(!r.defined(l))return;const p=i.Cartesian3.fromArray(o,3*e,ue);i.Cartesian3.equalsEpsilon(p,n,a.CesiumMath.EPSILON10)?c.applyOffset.values[u]=l[e]:c.applyOffset.values[u]=l[t]}function ge(e){const t=e.geometry,n=t.attributes,o=n.position.values,u=r.defined(n.applyOffset)?n.applyOffset.values:void 0,c=t.indices,l=te(t),p=te(t);let f;const y=c.length,m=[];m.length=o.length/3;const C=[];for(C.length=o.length/3,f=0;f<m.length;++f)m[f]=-1,C[f]=-1;for(f=0;f<y;f+=2){const e=c[f],t=c[f+1],n=i.Cartesian3.fromArray(o,3*e,ue),y=i.Cartesian3.fromArray(o,3*t,ce);let h;Math.abs(n.y)<a.CesiumMath.EPSILON6&&(n.y<0?n.y=-a.CesiumMath.EPSILON6:n.y=a.CesiumMath.EPSILON6),Math.abs(y.y)<a.CesiumMath.EPSILON6&&(y.y<0?y.y=-a.CesiumMath.EPSILON6:y.y=a.CesiumMath.EPSILON6);let v=l.attributes,T=l.indices,x=C,P=p.attributes,w=p.indices,O=m;const E=d.IntersectionTests.lineSegmentPlane(n,y,he,le);if(r.defined(E)){const r=i.Cartesian3.multiplyByScalar(i.Cartesian3.UNIT_Y,5*a.CesiumMath.EPSILON9,ve);n.y<0&&(i.Cartesian3.negate(r,r),v=p.attributes,T=p.indices,x=m,P=l.attributes,w=l.indices,O=C);const d=i.Cartesian3.add(E,r,Ae);h=fe(v,T,x,c,f,n),be(e,t,n,o,h,v,u),h=fe(v,T,x,c,-1,d),be(e,t,d,o,h,v,u),i.Cartesian3.negate(r,r),i.Cartesian3.add(E,r,d),h=fe(P,w,O,c,-1,d),be(e,t,d,o,h,P,u),h=fe(P,w,O,c,f+1,y),be(e,t,y,o,h,P,u)}else{let i,r,a;n.y<0?(i=p.attributes,r=p.indices,a=m):(i=l.attributes,r=l.indices,a=C),h=fe(i,r,a,c,f,n),be(e,t,n,o,h,i,u),h=fe(i,r,a,c,f+1,y),be(e,t,y,o,h,i,u)}}ne(e,p,l)}const Te=new n.Cartesian2,xe=new n.Cartesian2,Pe=new i.Cartesian3,we=new i.Cartesian3,Se=new i.Cartesian3,Ie=new i.Cartesian3,Oe=new i.Cartesian3,Ee=new i.Cartesian3,Le=new n.Cartesian4;function Ne(e){const t=e.attributes,n=t.position.values,r=t.prevPosition.values,a=t.nextPosition.values,o=n.length;for(let e=0;e<o;e+=3){const t=i.Cartesian3.unpack(n,e,Pe);if(t.x>0)continue;const u=i.Cartesian3.unpack(r,e,we);(t.y<0&&u.y>0||t.y>0&&u.y<0)&&(e-3>0?(r[e]=n[e-3],r[e+1]=n[e-2],r[e+2]=n[e-1]):i.Cartesian3.pack(t,r,e));const c=i.Cartesian3.unpack(a,e,Se);(t.y<0&&c.y>0||t.y>0&&c.y<0)&&(e+3<o?(a[e]=n[e+3],a[e+1]=n[e+4],a[e+2]=n[e+5]):i.Cartesian3.pack(t,a,e))}}const Me=5*a.CesiumMath.EPSILON9,ze=a.CesiumMath.EPSILON6;T.splitLongitude=function(e){const t=e.geometry,u=t.boundingSphere;if(r.defined(u)&&(u.center.x-u.radius>0||o.BoundingSphere.intersectPlane(u,f.Plane.ORIGIN_ZX_PLANE)!==o.Intersect.INTERSECTING))return e;if(t.geometryType!==l.GeometryType.NONE)switch(t.geometryType){case l.GeometryType.POLYLINES:!function(e){const t=e.geometry,o=t.attributes,u=o.position.values,c=o.prevPosition.values,l=o.nextPosition.values,p=o.expandAndWidth.values,f=r.defined(o.st)?o.st.values:void 0,y=r.defined(o.color)?o.color.values:void 0,m=te(t),C=te(t);let h,v,T,x=!1;const P=u.length/3;for(h=0;h<P;h+=4){const e=h,t=h+2,o=i.Cartesian3.fromArray(u,3*e,Pe),P=i.Cartesian3.fromArray(u,3*t,we);if(Math.abs(o.y)<ze)for(o.y=ze*(P.y<0?-1:1),u[3*h+1]=o.y,u[3*(h+1)+1]=o.y,v=3*e;v<3*e+12;v+=3)c[v]=u[3*h],c[v+1]=u[3*h+1],c[v+2]=u[3*h+2];if(Math.abs(P.y)<ze)for(P.y=ze*(o.y<0?-1:1),u[3*(h+2)+1]=P.y,u[3*(h+3)+1]=P.y,v=3*e;v<3*e+12;v+=3)l[v]=u[3*(h+2)],l[v+1]=u[3*(h+2)+1],l[v+2]=u[3*(h+2)+2];let w=m.attributes,O=m.indices,E=C.attributes,N=C.indices;const M=d.IntersectionTests.lineSegmentPlane(o,P,he,Ie);if(r.defined(M)){x=!0;const u=i.Cartesian3.multiplyByScalar(i.Cartesian3.UNIT_Y,Me,Oe);o.y<0&&(i.Cartesian3.negate(u,u),w=C.attributes,O=C.indices,E=m.attributes,N=m.indices);const d=i.Cartesian3.add(M,u,Ee);w.position.values.push(o.x,o.y,o.z,o.x,o.y,o.z),w.position.values.push(d.x,d.y,d.z),w.position.values.push(d.x,d.y,d.z),w.prevPosition.values.push(c[3*e],c[3*e+1],c[3*e+2]),w.prevPosition.values.push(c[3*e+3],c[3*e+4],c[3*e+5]),w.prevPosition.values.push(o.x,o.y,o.z,o.x,o.y,o.z),w.nextPosition.values.push(d.x,d.y,d.z),w.nextPosition.values.push(d.x,d.y,d.z),w.nextPosition.values.push(d.x,d.y,d.z),w.nextPosition.values.push(d.x,d.y,d.z),i.Cartesian3.negate(u,u),i.Cartesian3.add(M,u,d),E.position.values.push(d.x,d.y,d.z),E.position.values.push(d.x,d.y,d.z),E.position.values.push(P.x,P.y,P.z,P.x,P.y,P.z),E.prevPosition.values.push(d.x,d.y,d.z),E.prevPosition.values.push(d.x,d.y,d.z),E.prevPosition.values.push(d.x,d.y,d.z),E.prevPosition.values.push(d.x,d.y,d.z),E.nextPosition.values.push(P.x,P.y,P.z,P.x,P.y,P.z),E.nextPosition.values.push(l[3*t],l[3*t+1],l[3*t+2]),E.nextPosition.values.push(l[3*t+3],l[3*t+4],l[3*t+5]);const z=n.Cartesian2.fromArray(p,2*e,Te),D=Math.abs(z.y);w.expandAndWidth.values.push(-1,D,1,D),w.expandAndWidth.values.push(-1,-D,1,-D),E.expandAndWidth.values.push(-1,D,1,D),E.expandAndWidth.values.push(-1,-D,1,-D);let G=i.Cartesian3.magnitudeSquared(i.Cartesian3.subtract(M,o,Se));if(G/=i.Cartesian3.magnitudeSquared(i.Cartesian3.subtract(P,o,Se)),r.defined(y)){const i=n.Cartesian4.fromArray(y,4*e,Le),r=n.Cartesian4.fromArray(y,4*t,Le),o=a.CesiumMath.lerp(i.x,r.x,G),u=a.CesiumMath.lerp(i.y,r.y,G),c=a.CesiumMath.lerp(i.z,r.z,G),l=a.CesiumMath.lerp(i.w,r.w,G);for(v=4*e;v<4*e+8;++v)w.color.values.push(y[v]);for(w.color.values.push(o,u,c,l),w.color.values.push(o,u,c,l),E.color.values.push(o,u,c,l),E.color.values.push(o,u,c,l),v=4*t;v<4*t+8;++v)E.color.values.push(y[v])}if(r.defined(f)){const i=n.Cartesian2.fromArray(f,2*e,Te),r=n.Cartesian2.fromArray(f,2*(h+3),xe),o=a.CesiumMath.lerp(i.x,r.x,G);for(v=2*e;v<2*e+4;++v)w.st.values.push(f[v]);for(w.st.values.push(o,i.y),w.st.values.push(o,r.y),E.st.values.push(o,i.y),E.st.values.push(o,r.y),v=2*t;v<2*t+4;++v)E.st.values.push(f[v])}T=w.position.values.length/3-4,O.push(T,T+2,T+1),O.push(T+1,T+2,T+3),T=E.position.values.length/3-4,N.push(T,T+2,T+1),N.push(T+1,T+2,T+3)}else{let e,t;for(o.y<0?(e=C.attributes,t=C.indices):(e=m.attributes,t=m.indices),e.position.values.push(o.x,o.y,o.z),e.position.values.push(o.x,o.y,o.z),e.position.values.push(P.x,P.y,P.z),e.position.values.push(P.x,P.y,P.z),v=3*h;v<3*h+12;++v)e.prevPosition.values.push(c[v]),e.nextPosition.values.push(l[v]);for(v=2*h;v<2*h+8;++v)e.expandAndWidth.values.push(p[v]),r.defined(f)&&e.st.values.push(f[v]);if(r.defined(y))for(v=4*h;v<4*h+16;++v)e.color.values.push(y[v]);T=e.position.values.length/3-4,t.push(T,T+2,T+1),t.push(T+1,T+2,T+3)}}x&&(Ne(C),Ne(m)),ne(e,C,m)}(e);break;case l.GeometryType.TRIANGLES:me(e);break;case l.GeometryType.LINES:ge(e)}else Y(t),t.primitiveType===l.PrimitiveType.TRIANGLES?me(e):t.primitiveType===l.PrimitiveType.LINES&&ge(e);return e};var De=T;e.GeometryPipeline=De}));