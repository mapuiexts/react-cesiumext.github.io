/*! For license information please see createCorridorGeometry.js.LICENSE.txt */
define(["./arrayRemoveDuplicates-63c6b4d8","./Transforms-c450597e","./Matrix2-21f90abf","./RuntimeError-cef79f54","./ComponentDatatype-4028c72d","./PolylineVolumeGeometryLibrary-12682ca2","./CorridorGeometryLibrary-17a0dde1","./defaultValue-4607806f","./GeometryAttribute-3c090c07","./GeometryAttributes-acac33d2","./GeometryOffsetAttribute-3e5f3e97","./IndexDatatype-20e78e57","./PolygonPipeline-13d40849","./VertexFormat-75e8069c","./_commonjsHelpers-a32ac251","./combine-fc59ba59","./WebGLConstants-f100e3dd","./EllipsoidTangentPlane-69b6e1fd","./AxisAlignedBoundingBox-cd3761c7","./IntersectionTests-ef65540c","./Plane-1c5eb32d","./PolylinePipeline-2aac2bf9","./EllipsoidGeodesic-b1c7082b","./EllipsoidRhumbLine-bf1c0ab0"],(function(t,e,r,a,i,o,n,s,l,d,u,c,m,f,y,p,g,h,C,b,A,_,w,v){"use strict";const T=new r.Cartesian3,G=new r.Cartesian3,E=new r.Cartesian3,V=new r.Cartesian3,x=new r.Cartesian3,L=new r.Cartesian3,P=new r.Cartesian3,F=new r.Cartesian3;function N(t,e){for(let r=0;r<t.length;r++)t[r]=e.scaleToGeodeticSurface(t[r],t[r]);return t}function D(t,e,a,i,o,s){const l=t.normals,d=t.tangents,u=t.bitangents,c=r.Cartesian3.normalize(r.Cartesian3.cross(a,e,P),P);s.normal&&n.CorridorGeometryLibrary.addAttribute(l,e,i,o),s.tangent&&n.CorridorGeometryLibrary.addAttribute(d,c,i,o),s.bitangent&&n.CorridorGeometryLibrary.addAttribute(u,a,i,o)}function M(t,e,a){const o=t.positions,u=t.corners,m=t.endPositions,f=t.lefts,y=t.normals,p=new d.GeometryAttributes;let g,h,C,b=0,A=0,_=0;for(h=0;h<o.length;h+=2)C=o[h].length-3,b+=C,_+=2*C,A+=o[h+1].length-3;for(b+=3,A+=3,h=0;h<u.length;h++){g=u[h];const t=u[h].leftPositions;s.defined(t)?(C=t.length,b+=C,_+=C):(C=u[h].rightPositions.length,A+=C,_+=C)}const w=s.defined(m);let v;w&&(v=m[0].length-3,b+=v,A+=v,v/=3,_+=6*v);const x=b+A,S=new Float64Array(x),R={normals:e.normal?new Float32Array(x):void 0,tangents:e.tangent?new Float32Array(x):void 0,bitangents:e.bitangent?new Float32Array(x):void 0};let k,z,B,U,Y,j,J=0,K=x-1,Q=T,X=G;const Z=v/2,$=c.IndexDatatype.createTypedArray(x/3,_);let tt=0;if(w){j=E,Y=V;const t=m[0];for(Q=r.Cartesian3.fromArray(y,0,Q),X=r.Cartesian3.fromArray(f,0,X),h=0;h<Z;h++)j=r.Cartesian3.fromArray(t,3*(Z-1-h),j),Y=r.Cartesian3.fromArray(t,3*(Z+h),Y),n.CorridorGeometryLibrary.addAttribute(S,Y,J),n.CorridorGeometryLibrary.addAttribute(S,j,void 0,K),D(R,Q,X,J,K,e),z=J/3,U=z+1,k=(K-2)/3,B=k-1,$[tt++]=k,$[tt++]=z,$[tt++]=B,$[tt++]=B,$[tt++]=z,$[tt++]=U,J+=3,K-=3}let et,rt,at=0,it=0,ot=o[at++],nt=o[at++];for(S.set(ot,J),S.set(nt,K-nt.length+1),X=r.Cartesian3.fromArray(f,it,X),C=nt.length-3,h=0;h<C;h+=3)et=a.geodeticSurfaceNormal(r.Cartesian3.fromArray(ot,h,P),P),rt=a.geodeticSurfaceNormal(r.Cartesian3.fromArray(nt,C-h,F),F),Q=r.Cartesian3.normalize(r.Cartesian3.add(et,rt,Q),Q),D(R,Q,X,J,K,e),z=J/3,U=z+1,k=(K-2)/3,B=k-1,$[tt++]=k,$[tt++]=z,$[tt++]=B,$[tt++]=B,$[tt++]=z,$[tt++]=U,J+=3,K-=3;for(et=a.geodeticSurfaceNormal(r.Cartesian3.fromArray(ot,C,P),P),rt=a.geodeticSurfaceNormal(r.Cartesian3.fromArray(nt,C,F),F),Q=r.Cartesian3.normalize(r.Cartesian3.add(et,rt,Q),Q),it+=3,h=0;h<u.length;h++){let t;g=u[h];const i=g.leftPositions,l=g.rightPositions;let d,c,m=L,p=E,b=V;if(Q=r.Cartesian3.fromArray(y,it,Q),s.defined(i)){for(D(R,Q,X,void 0,K,e),K-=3,d=U,c=B,t=0;t<i.length/3;t++)m=r.Cartesian3.fromArray(i,3*t,m),$[tt++]=d,$[tt++]=c-t-1,$[tt++]=c-t,n.CorridorGeometryLibrary.addAttribute(S,m,void 0,K),p=r.Cartesian3.fromArray(S,3*(c-t-1),p),b=r.Cartesian3.fromArray(S,3*d,b),X=r.Cartesian3.normalize(r.Cartesian3.subtract(p,b,X),X),D(R,Q,X,void 0,K,e),K-=3;m=r.Cartesian3.fromArray(S,3*d,m),p=r.Cartesian3.subtract(r.Cartesian3.fromArray(S,3*c,p),m,p),b=r.Cartesian3.subtract(r.Cartesian3.fromArray(S,3*(c-t),b),m,b),X=r.Cartesian3.normalize(r.Cartesian3.add(p,b,X),X),D(R,Q,X,J,void 0,e),J+=3}else{for(D(R,Q,X,J,void 0,e),J+=3,d=B,c=U,t=0;t<l.length/3;t++)m=r.Cartesian3.fromArray(l,3*t,m),$[tt++]=d,$[tt++]=c+t,$[tt++]=c+t+1,n.CorridorGeometryLibrary.addAttribute(S,m,J),p=r.Cartesian3.fromArray(S,3*d,p),b=r.Cartesian3.fromArray(S,3*(c+t),b),X=r.Cartesian3.normalize(r.Cartesian3.subtract(p,b,X),X),D(R,Q,X,J,void 0,e),J+=3;m=r.Cartesian3.fromArray(S,3*d,m),p=r.Cartesian3.subtract(r.Cartesian3.fromArray(S,3*(c+t),p),m,p),b=r.Cartesian3.subtract(r.Cartesian3.fromArray(S,3*c,b),m,b),X=r.Cartesian3.normalize(r.Cartesian3.negate(r.Cartesian3.add(b,p,X),X),X),D(R,Q,X,void 0,K,e),K-=3}for(ot=o[at++],nt=o[at++],ot.splice(0,3),nt.splice(nt.length-3,3),S.set(ot,J),S.set(nt,K-nt.length+1),C=nt.length-3,it+=3,X=r.Cartesian3.fromArray(f,it,X),t=0;t<nt.length;t+=3)et=a.geodeticSurfaceNormal(r.Cartesian3.fromArray(ot,t,P),P),rt=a.geodeticSurfaceNormal(r.Cartesian3.fromArray(nt,C-t,F),F),Q=r.Cartesian3.normalize(r.Cartesian3.add(et,rt,Q),Q),D(R,Q,X,J,K,e),U=J/3,z=U-1,B=(K-2)/3,k=B+1,$[tt++]=k,$[tt++]=z,$[tt++]=B,$[tt++]=B,$[tt++]=z,$[tt++]=U,J+=3,K-=3;J-=3,K+=3}if(Q=r.Cartesian3.fromArray(y,y.length-3,Q),D(R,Q,X,J,K,e),w){J+=3,K-=3,j=E,Y=V;const t=m[1];for(h=0;h<Z;h++)j=r.Cartesian3.fromArray(t,3*(v-h-1),j),Y=r.Cartesian3.fromArray(t,3*h,Y),n.CorridorGeometryLibrary.addAttribute(S,j,void 0,K),n.CorridorGeometryLibrary.addAttribute(S,Y,J),D(R,Q,X,J,K,e),U=J/3,z=U-1,B=(K-2)/3,k=B+1,$[tt++]=k,$[tt++]=z,$[tt++]=B,$[tt++]=B,$[tt++]=z,$[tt++]=U,J+=3,K-=3}if(p.position=new l.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:S}),e.st){const t=new Float32Array(x/3*2);let e,r,a=0;if(w){b/=3,A/=3;const o=Math.PI/(v+1);let n;r=1/(b-v+1),e=1/(A-v+1);const s=v/2;for(h=s+1;h<v+1;h++)n=i.CesiumMath.PI_OVER_TWO+o*h,t[a++]=e*(1+Math.cos(n)),t[a++]=.5*(1+Math.sin(n));for(h=1;h<A-v+1;h++)t[a++]=h*e,t[a++]=0;for(h=v;h>s;h--)n=i.CesiumMath.PI_OVER_TWO-h*o,t[a++]=1-e*(1+Math.cos(n)),t[a++]=.5*(1+Math.sin(n));for(h=s;h>0;h--)n=i.CesiumMath.PI_OVER_TWO-o*h,t[a++]=1-r*(1+Math.cos(n)),t[a++]=.5*(1+Math.sin(n));for(h=b-v;h>0;h--)t[a++]=h*r,t[a++]=1;for(h=1;h<s+1;h++)n=i.CesiumMath.PI_OVER_TWO+o*h,t[a++]=r*(1+Math.cos(n)),t[a++]=.5*(1+Math.sin(n))}else{for(b/=3,A/=3,r=1/(b-1),e=1/(A-1),h=0;h<A;h++)t[a++]=h*e,t[a++]=0;for(h=b;h>0;h--)t[a++]=(h-1)*r,t[a++]=1}p.st=new l.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:t})}return e.normal&&(p.normal=new l.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:R.normals})),e.tangent&&(p.tangent=new l.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:R.tangents})),e.bitangent&&(p.bitangent=new l.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:R.bitangents})),{attributes:p,indices:$}}function O(t,e,r){r[e++]=t[0],r[e++]=t[1],r[e++]=t[2];for(let a=3;a<t.length;a+=3){const i=t[a],o=t[a+1],n=t[a+2];r[e++]=i,r[e++]=o,r[e++]=n,r[e++]=i,r[e++]=o,r[e++]=n}return r[e++]=t[0],r[e++]=t[1],r[e++]=t[2],r}function I(t,e){const a=new f.VertexFormat({position:e.position,normal:e.normal||e.bitangent||t.shadowVolume,tangent:e.tangent,bitangent:e.normal||e.bitangent,st:e.st}),o=t.ellipsoid,d=M(n.CorridorGeometryLibrary.computePositions(t),a,o),y=t.height,p=t.extrudedHeight;let g=d.attributes;const h=d.indices;let C=g.position.values,b=C.length;const A=new Float64Array(6*b);let _=new Float64Array(b);_.set(C);let w,v=new Float64Array(4*b);C=m.PolygonPipeline.scaleToGeodeticHeight(C,y,o),v=O(C,0,v),_=m.PolygonPipeline.scaleToGeodeticHeight(_,p,o),v=O(_,2*b,v),A.set(C),A.set(_,b),A.set(v,2*b),g.position.values=A,g=function(t,e){if(!(e.normal||e.tangent||e.bitangent||e.st))return t;const a=t.position.values;let i,o;(e.normal||e.bitangent)&&(i=t.normal.values,o=t.bitangent.values);const s=t.position.values.length/18,l=3*s,d=2*s,u=2*l;let c;if(e.normal||e.bitangent||e.tangent){const s=e.normal?new Float32Array(6*l):void 0,d=e.tangent?new Float32Array(6*l):void 0,m=e.bitangent?new Float32Array(6*l):void 0;let f=T,y=G,p=E,g=V,h=x,C=L,b=u;for(c=0;c<l;c+=3){const t=b+u;f=r.Cartesian3.fromArray(a,c,f),y=r.Cartesian3.fromArray(a,c+l,y),p=r.Cartesian3.fromArray(a,(c+3)%l,p),y=r.Cartesian3.subtract(y,f,y),p=r.Cartesian3.subtract(p,f,p),g=r.Cartesian3.normalize(r.Cartesian3.cross(y,p,g),g),e.normal&&(n.CorridorGeometryLibrary.addAttribute(s,g,t),n.CorridorGeometryLibrary.addAttribute(s,g,t+3),n.CorridorGeometryLibrary.addAttribute(s,g,b),n.CorridorGeometryLibrary.addAttribute(s,g,b+3)),(e.tangent||e.bitangent)&&(C=r.Cartesian3.fromArray(i,c,C),e.bitangent&&(n.CorridorGeometryLibrary.addAttribute(m,C,t),n.CorridorGeometryLibrary.addAttribute(m,C,t+3),n.CorridorGeometryLibrary.addAttribute(m,C,b),n.CorridorGeometryLibrary.addAttribute(m,C,b+3)),e.tangent&&(h=r.Cartesian3.normalize(r.Cartesian3.cross(C,g,h),h),n.CorridorGeometryLibrary.addAttribute(d,h,t),n.CorridorGeometryLibrary.addAttribute(d,h,t+3),n.CorridorGeometryLibrary.addAttribute(d,h,b),n.CorridorGeometryLibrary.addAttribute(d,h,b+3))),b+=6}if(e.normal){for(s.set(i),c=0;c<l;c+=3)s[c+l]=-i[c],s[c+l+1]=-i[c+1],s[c+l+2]=-i[c+2];t.normal.values=s}else t.normal=void 0;if(e.bitangent?(m.set(o),m.set(o,l),t.bitangent.values=m):t.bitangent=void 0,e.tangent){const e=t.tangent.values;d.set(e),d.set(e,l),t.tangent.values=d}}if(e.st){const e=t.st.values,r=new Float32Array(6*d);r.set(e),r.set(e,d);let a=2*d;for(let t=0;t<2;t++){for(r[a++]=e[0],r[a++]=e[1],c=2;c<d;c+=2){const t=e[c],i=e[c+1];r[a++]=t,r[a++]=i,r[a++]=t,r[a++]=i}r[a++]=e[0],r[a++]=e[1]}t.st.values=r}return t}(g,e);const P=b/3;if(t.shadowVolume){const t=g.normal.values;b=t.length;let r=new Float32Array(6*b);for(w=0;w<b;w++)t[w]=-t[w];r.set(t,b),r=O(t,4*b,r),g.extrudeDirection=new l.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:r}),e.normal||(g.normal=void 0)}if(s.defined(t.offsetAttribute)){let e=new Uint8Array(6*P);if(t.offsetAttribute===u.GeometryOffsetAttribute.TOP)e=e.fill(1,0,P).fill(1,2*P,4*P);else{const r=t.offsetAttribute===u.GeometryOffsetAttribute.NONE?0:1;e=e.fill(r)}g.applyOffset=new l.GeometryAttribute({componentDatatype:i.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}const F=h.length,S=P+P,R=c.IndexDatatype.createTypedArray(A.length/3,2*F+3*S);R.set(h);let k,z,B,U,Y=F;for(w=0;w<F;w+=3){const t=h[w],e=h[w+1],r=h[w+2];R[Y++]=r+P,R[Y++]=e+P,R[Y++]=t+P}for(w=0;w<S;w+=2)k=w+S,z=k+S,B=k+1,U=z+1,R[Y++]=k,R[Y++]=z,R[Y++]=B,R[Y++]=B,R[Y++]=z,R[Y++]=U;return{attributes:g,indices:R}}const S=new r.Cartesian3,R=new r.Cartesian3,k=new r.Cartographic;function H(t,e,a,i,o,n){const s=r.Cartesian3.subtract(e,t,S);r.Cartesian3.normalize(s,s);const l=a.geodeticSurfaceNormal(t,R),d=r.Cartesian3.cross(s,l,S);r.Cartesian3.multiplyByScalar(d,i,d);let u=o.latitude,c=o.longitude,m=n.latitude,f=n.longitude;r.Cartesian3.add(t,d,R),a.cartesianToCartographic(R,k);let y=k.latitude,p=k.longitude;u=Math.min(u,y),c=Math.min(c,p),m=Math.max(m,y),f=Math.max(f,p),r.Cartesian3.subtract(t,d,R),a.cartesianToCartographic(R,k),y=k.latitude,p=k.longitude,u=Math.min(u,y),c=Math.min(c,p),m=Math.max(m,y),f=Math.max(f,p),o.latitude=u,o.longitude=c,n.latitude=m,n.longitude=f}const z=new r.Cartesian3,B=new r.Cartesian3,U=new r.Cartographic,Y=new r.Cartographic;function W(e,a,i,n,l){e=N(e,a);const d=t.arrayRemoveDuplicates(e,r.Cartesian3.equalsEpsilon),u=d.length;if(u<2||i<=0)return new r.Rectangle;const c=.5*i;let m,f;if(U.latitude=Number.POSITIVE_INFINITY,U.longitude=Number.POSITIVE_INFINITY,Y.latitude=Number.NEGATIVE_INFINITY,Y.longitude=Number.NEGATIVE_INFINITY,n===o.CornerType.ROUNDED){const t=d[0];r.Cartesian3.subtract(t,d[1],z),r.Cartesian3.normalize(z,z),r.Cartesian3.multiplyByScalar(z,c,z),r.Cartesian3.add(t,z,B),a.cartesianToCartographic(B,k),m=k.latitude,f=k.longitude,U.latitude=Math.min(U.latitude,m),U.longitude=Math.min(U.longitude,f),Y.latitude=Math.max(Y.latitude,m),Y.longitude=Math.max(Y.longitude,f)}for(let t=0;t<u-1;++t)H(d[t],d[t+1],a,c,U,Y);const y=d[u-1];r.Cartesian3.subtract(y,d[u-2],z),r.Cartesian3.normalize(z,z),r.Cartesian3.multiplyByScalar(z,c,z),r.Cartesian3.add(y,z,B),H(y,B,a,c,U,Y),n===o.CornerType.ROUNDED&&(a.cartesianToCartographic(B,k),m=k.latitude,f=k.longitude,U.latitude=Math.min(U.latitude,m),U.longitude=Math.min(U.longitude,f),Y.latitude=Math.max(Y.latitude,m),Y.longitude=Math.max(Y.longitude,f));const p=s.defined(l)?l:new r.Rectangle;return p.north=Y.latitude,p.south=U.latitude,p.east=Y.longitude,p.west=U.longitude,p}function q(t){const e=(t=s.defaultValue(t,s.defaultValue.EMPTY_OBJECT)).positions,a=t.width,n=s.defaultValue(t.height,0),l=s.defaultValue(t.extrudedHeight,n);this._positions=e,this._ellipsoid=r.Ellipsoid.clone(s.defaultValue(t.ellipsoid,r.Ellipsoid.WGS84)),this._vertexFormat=f.VertexFormat.clone(s.defaultValue(t.vertexFormat,f.VertexFormat.DEFAULT)),this._width=a,this._height=Math.max(n,l),this._extrudedHeight=Math.min(n,l),this._cornerType=s.defaultValue(t.cornerType,o.CornerType.ROUNDED),this._granularity=s.defaultValue(t.granularity,i.CesiumMath.RADIANS_PER_DEGREE),this._shadowVolume=s.defaultValue(t.shadowVolume,!1),this._workerName="createCorridorGeometry",this._offsetAttribute=t.offsetAttribute,this._rectangle=void 0,this.packedLength=1+e.length*r.Cartesian3.packedLength+r.Ellipsoid.packedLength+f.VertexFormat.packedLength+7}q.pack=function(t,e,a){a=s.defaultValue(a,0);const i=t._positions,o=i.length;e[a++]=o;for(let t=0;t<o;++t,a+=r.Cartesian3.packedLength)r.Cartesian3.pack(i[t],e,a);return r.Ellipsoid.pack(t._ellipsoid,e,a),a+=r.Ellipsoid.packedLength,f.VertexFormat.pack(t._vertexFormat,e,a),a+=f.VertexFormat.packedLength,e[a++]=t._width,e[a++]=t._height,e[a++]=t._extrudedHeight,e[a++]=t._cornerType,e[a++]=t._granularity,e[a++]=t._shadowVolume?1:0,e[a]=s.defaultValue(t._offsetAttribute,-1),e};const j=r.Ellipsoid.clone(r.Ellipsoid.UNIT_SPHERE),J=new f.VertexFormat,K={positions:void 0,ellipsoid:j,vertexFormat:J,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,shadowVolume:void 0,offsetAttribute:void 0};return q.unpack=function(t,e,a){e=s.defaultValue(e,0);const i=t[e++],o=new Array(i);for(let a=0;a<i;++a,e+=r.Cartesian3.packedLength)o[a]=r.Cartesian3.unpack(t,e);const n=r.Ellipsoid.unpack(t,e,j);e+=r.Ellipsoid.packedLength;const l=f.VertexFormat.unpack(t,e,J);e+=f.VertexFormat.packedLength;const d=t[e++],u=t[e++],c=t[e++],m=t[e++],y=t[e++],p=1===t[e++],g=t[e];return s.defined(a)?(a._positions=o,a._ellipsoid=r.Ellipsoid.clone(n,a._ellipsoid),a._vertexFormat=f.VertexFormat.clone(l,a._vertexFormat),a._width=d,a._height=u,a._extrudedHeight=c,a._cornerType=m,a._granularity=y,a._shadowVolume=p,a._offsetAttribute=-1===g?void 0:g,a):(K.positions=o,K.width=d,K.height=u,K.extrudedHeight=c,K.cornerType=m,K.granularity=y,K.shadowVolume=p,K.offsetAttribute=-1===g?void 0:g,new q(K))},q.computeRectangle=function(t,e){const a=(t=s.defaultValue(t,s.defaultValue.EMPTY_OBJECT)).positions,i=t.width;return W(a,s.defaultValue(t.ellipsoid,r.Ellipsoid.WGS84),i,s.defaultValue(t.cornerType,o.CornerType.ROUNDED),e)},q.createGeometry=function(a){let o=a._positions;const d=a._width,c=a._ellipsoid;o=N(o,c);const f=t.arrayRemoveDuplicates(o,r.Cartesian3.equalsEpsilon);if(f.length<2||d<=0)return;const y=a._height,p=a._extrudedHeight,g=!i.CesiumMath.equalsEpsilon(y,p,0,i.CesiumMath.EPSILON2),h=a._vertexFormat,C={ellipsoid:c,positions:f,width:d,cornerType:a._cornerType,granularity:a._granularity,saveAttributes:!0};let b;if(g)C.height=y,C.extrudedHeight=p,C.shadowVolume=a._shadowVolume,C.offsetAttribute=a._offsetAttribute,b=I(C,h);else if(b=M(n.CorridorGeometryLibrary.computePositions(C),h,c),b.attributes.position.values=m.PolygonPipeline.scaleToGeodeticHeight(b.attributes.position.values,y,c),s.defined(a._offsetAttribute)){const t=a._offsetAttribute===u.GeometryOffsetAttribute.NONE?0:1,e=b.attributes.position.values.length,r=new Uint8Array(e/3).fill(t);b.attributes.applyOffset=new l.GeometryAttribute({componentDatatype:i.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:r})}const A=b.attributes,_=e.BoundingSphere.fromVertices(A.position.values,void 0,3);return h.position||(b.attributes.position.values=void 0),new l.Geometry({attributes:A,indices:b.indices,primitiveType:l.PrimitiveType.TRIANGLES,boundingSphere:_,offsetAttribute:a._offsetAttribute})},q.createShadowVolume=function(t,e,r){const a=t._granularity,i=t._ellipsoid,o=e(a,i),n=r(a,i);return new q({positions:t._positions,width:t._width,cornerType:t._cornerType,ellipsoid:i,granularity:a,extrudedHeight:o,height:n,vertexFormat:f.VertexFormat.POSITION_ONLY,shadowVolume:!0})},Object.defineProperties(q.prototype,{rectangle:{get:function(){return s.defined(this._rectangle)||(this._rectangle=W(this._positions,this._ellipsoid,this._width,this._cornerType)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return[0,0,0,1,1,0]}}}),function(t,e){return s.defined(e)&&(t=q.unpack(t,e)),t._ellipsoid=r.Ellipsoid.clone(t._ellipsoid),q.createGeometry(t)}}));