define(["exports","./Matrix3-a348023f","./Math-e97915da","./Transforms-01e95659"],(function(a,t,e,n){"use strict";const i={},r=new t.Cartesian3,s=new t.Cartesian3,o=new n.Quaternion,l=new t.Matrix3;function c(a,e,i,C,y,u,m,h,x,M){const f=a+e;t.Cartesian3.multiplyByScalar(C,Math.cos(f),r),t.Cartesian3.multiplyByScalar(i,Math.sin(f),s),t.Cartesian3.add(r,s,r);let z=Math.cos(a);z*=z;let _=Math.sin(a);_*=_;const d=u/Math.sqrt(m*z+y*_)/h;return n.Quaternion.fromAxisAngle(r,d,o),t.Matrix3.fromQuaternion(o,l),t.Matrix3.multiplyByVector(l,x,M),t.Cartesian3.normalize(M,M),t.Cartesian3.multiplyByScalar(M,h,M),M}const C=new t.Cartesian3,y=new t.Cartesian3,u=new t.Cartesian3,m=new t.Cartesian3;i.raisePositionsToHeight=function(a,e,n){const i=e.ellipsoid,r=e.height,s=e.extrudedHeight,o=n?a.length/3*2:a.length/3,l=new Float64Array(3*o),h=a.length,x=n?h:0;for(let e=0;e<h;e+=3){const o=e+1,h=e+2,M=t.Cartesian3.fromArray(a,e,C);i.scaleToGeodeticSurface(M,M);const f=t.Cartesian3.clone(M,y),z=i.geodeticSurfaceNormal(M,m),_=t.Cartesian3.multiplyByScalar(z,r,u);t.Cartesian3.add(M,_,M),n&&(t.Cartesian3.multiplyByScalar(z,s,_),t.Cartesian3.add(f,_,f),l[e+x]=f.x,l[o+x]=f.y,l[h+x]=f.z),l[e]=M.x,l[o]=M.y,l[h]=M.z}return l};const h=new t.Cartesian3,x=new t.Cartesian3,M=new t.Cartesian3;i.computeEllipsePositions=function(a,n,i){const r=a.semiMinorAxis,s=a.semiMajorAxis,o=a.rotation,l=a.center,m=8*a.granularity,f=r*r,z=s*s,_=s*r,d=t.Cartesian3.magnitude(l),O=t.Cartesian3.normalize(l,h);let p=t.Cartesian3.cross(t.Cartesian3.UNIT_Z,l,x);p=t.Cartesian3.normalize(p,p);const w=t.Cartesian3.cross(O,p,M);let P=1+Math.ceil(e.CesiumMath.PI_OVER_TWO/m);const T=e.CesiumMath.PI_OVER_TWO/(P-1);let I=e.CesiumMath.PI_OVER_TWO-P*T;I<0&&(P-=Math.ceil(Math.abs(I)/T));const g=n?new Array(P*(P+2)*2*3):void 0;let E=0,V=C,A=y;const R=4*P*3;let W=R-1,S=0;const B=i?new Array(R):void 0;let v,Q,b,G,H;for(I=e.CesiumMath.PI_OVER_TWO,V=c(I,o,w,p,f,_,z,d,O,V),n&&(g[E++]=V.x,g[E++]=V.y,g[E++]=V.z),i&&(B[W--]=V.z,B[W--]=V.y,B[W--]=V.x),I=e.CesiumMath.PI_OVER_TWO-T,v=1;v<P+1;++v){if(V=c(I,o,w,p,f,_,z,d,O,V),A=c(Math.PI-I,o,w,p,f,_,z,d,O,A),n){for(g[E++]=V.x,g[E++]=V.y,g[E++]=V.z,b=2*v+2,Q=1;Q<b-1;++Q)G=Q/(b-1),H=t.Cartesian3.lerp(V,A,G,u),g[E++]=H.x,g[E++]=H.y,g[E++]=H.z;g[E++]=A.x,g[E++]=A.y,g[E++]=A.z}i&&(B[W--]=V.z,B[W--]=V.y,B[W--]=V.x,B[S++]=A.x,B[S++]=A.y,B[S++]=A.z),I=e.CesiumMath.PI_OVER_TWO-(v+1)*T}for(v=P;v>1;--v){if(I=e.CesiumMath.PI_OVER_TWO-(v-1)*T,V=c(-I,o,w,p,f,_,z,d,O,V),A=c(I+Math.PI,o,w,p,f,_,z,d,O,A),n){for(g[E++]=V.x,g[E++]=V.y,g[E++]=V.z,b=2*(v-1)+2,Q=1;Q<b-1;++Q)G=Q/(b-1),H=t.Cartesian3.lerp(V,A,G,u),g[E++]=H.x,g[E++]=H.y,g[E++]=H.z;g[E++]=A.x,g[E++]=A.y,g[E++]=A.z}i&&(B[W--]=V.z,B[W--]=V.y,B[W--]=V.x,B[S++]=A.x,B[S++]=A.y,B[S++]=A.z)}I=e.CesiumMath.PI_OVER_TWO,V=c(-I,o,w,p,f,_,z,d,O,V);const N={};return n&&(g[E++]=V.x,g[E++]=V.y,g[E++]=V.z,N.positions=g,N.numPts=P),i&&(B[W--]=V.z,B[W--]=V.y,B[W--]=V.x,N.outerPositions=B),N};var f=i;a.EllipseGeometryLibrary=f}));