/*! For license information please see createSimplePolylineGeometry.js.LICENSE.txt */
define(["./defaultValue-4607806f","./Matrix2-21f90abf","./ArcType-f5af12f9","./Transforms-c450597e","./Color-9a6f77d5","./ComponentDatatype-4028c72d","./RuntimeError-cef79f54","./GeometryAttribute-3c090c07","./GeometryAttributes-acac33d2","./IndexDatatype-20e78e57","./PolylinePipeline-2aac2bf9","./_commonjsHelpers-a32ac251","./combine-fc59ba59","./WebGLConstants-f100e3dd","./EllipsoidGeodesic-b1c7082b","./EllipsoidRhumbLine-bf1c0ab0","./IntersectionTests-ef65540c","./Plane-1c5eb32d"],(function(e,o,t,l,r,n,i,a,s,c,p,f,d,y,u,h,C,m){"use strict";function T(e,o,t,l,n,i,a){const s=p.PolylinePipeline.numberOfPoints(e,o,n);let c;const f=t.red,d=t.green,y=t.blue,u=t.alpha,h=l.red,C=l.green,m=l.blue,b=l.alpha;if(r.Color.equals(t,l)){for(c=0;c<s;c++)i[a++]=r.Color.floatToByte(f),i[a++]=r.Color.floatToByte(d),i[a++]=r.Color.floatToByte(y),i[a++]=r.Color.floatToByte(u);return a}const _=(h-f)/s,P=(C-d)/s,B=(m-y)/s,A=(b-u)/s;let E=a;for(c=0;c<s;c++)i[E++]=r.Color.floatToByte(f+c*_),i[E++]=r.Color.floatToByte(d+c*P),i[E++]=r.Color.floatToByte(y+c*B),i[E++]=r.Color.floatToByte(u+c*A);return E}function g(l){const i=(l=e.defaultValue(l,e.defaultValue.EMPTY_OBJECT)).positions,a=l.colors,s=e.defaultValue(l.colorsPerVertex,!1);this._positions=i,this._colors=a,this._colorsPerVertex=s,this._arcType=e.defaultValue(l.arcType,t.ArcType.GEODESIC),this._granularity=e.defaultValue(l.granularity,n.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=e.defaultValue(l.ellipsoid,o.Ellipsoid.WGS84),this._workerName="createSimplePolylineGeometry";let c=1+i.length*o.Cartesian3.packedLength;c+=e.defined(a)?1+a.length*r.Color.packedLength:1,this.packedLength=c+o.Ellipsoid.packedLength+3}g.pack=function(t,l,n){let i;n=e.defaultValue(n,0);const a=t._positions;let s=a.length;for(l[n++]=s,i=0;i<s;++i,n+=o.Cartesian3.packedLength)o.Cartesian3.pack(a[i],l,n);const c=t._colors;for(s=e.defined(c)?c.length:0,l[n++]=s,i=0;i<s;++i,n+=r.Color.packedLength)r.Color.pack(c[i],l,n);return o.Ellipsoid.pack(t._ellipsoid,l,n),n+=o.Ellipsoid.packedLength,l[n++]=t._colorsPerVertex?1:0,l[n++]=t._arcType,l[n]=t._granularity,l},g.unpack=function(t,l,n){let i;l=e.defaultValue(l,0);let a=t[l++];const s=new Array(a);for(i=0;i<a;++i,l+=o.Cartesian3.packedLength)s[i]=o.Cartesian3.unpack(t,l);a=t[l++];const c=a>0?new Array(a):void 0;for(i=0;i<a;++i,l+=r.Color.packedLength)c[i]=r.Color.unpack(t,l);const p=o.Ellipsoid.unpack(t,l);l+=o.Ellipsoid.packedLength;const f=1===t[l++],d=t[l++],y=t[l];return e.defined(n)?(n._positions=s,n._colors=c,n._ellipsoid=p,n._colorsPerVertex=f,n._arcType=d,n._granularity=y,n):new g({positions:s,colors:c,ellipsoid:p,colorsPerVertex:f,arcType:d,granularity:y})};const b=new Array(2),_=new Array(2),P={positions:b,height:_,ellipsoid:void 0,minDistance:void 0,granularity:void 0};return g.createGeometry=function(i){const f=i._positions,d=i._colors,y=i._colorsPerVertex,u=i._arcType,h=i._granularity,C=i._ellipsoid,m=n.CesiumMath.chordLength(h,C.maximumRadius),B=e.defined(d)&&!y;let A;const E=f.length;let k,G,D,L,w=0;if(u===t.ArcType.GEODESIC||u===t.ArcType.RHUMB){let o,l,i;u===t.ArcType.GEODESIC?(o=n.CesiumMath.chordLength(h,C.maximumRadius),l=p.PolylinePipeline.numberOfPoints,i=p.PolylinePipeline.generateArc):(o=h,l=p.PolylinePipeline.numberOfPointsRhumbLine,i=p.PolylinePipeline.generateRhumbArc);const a=p.PolylinePipeline.extractHeights(f,C),s=P;if(u===t.ArcType.GEODESIC?s.minDistance=m:s.granularity=h,s.ellipsoid=C,B){let t=0;for(A=0;A<E-1;A++)t+=l(f[A],f[A+1],o)+1;k=new Float64Array(3*t),D=new Uint8Array(4*t),s.positions=b,s.height=_;let n=0;for(A=0;A<E-1;++A){b[0]=f[A],b[1]=f[A+1],_[0]=a[A],_[1]=a[A+1];const o=i(s);if(e.defined(d)){const e=o.length/3;L=d[A];for(let o=0;o<e;++o)D[n++]=r.Color.floatToByte(L.red),D[n++]=r.Color.floatToByte(L.green),D[n++]=r.Color.floatToByte(L.blue),D[n++]=r.Color.floatToByte(L.alpha)}k.set(o,w),w+=o.length}}else if(s.positions=f,s.height=a,k=new Float64Array(i(s)),e.defined(d)){for(D=new Uint8Array(k.length/3*4),A=0;A<E-1;++A)w=T(f[A],f[A+1],d[A],d[A+1],m,D,w);const e=d[E-1];D[w++]=r.Color.floatToByte(e.red),D[w++]=r.Color.floatToByte(e.green),D[w++]=r.Color.floatToByte(e.blue),D[w++]=r.Color.floatToByte(e.alpha)}}else{G=B?2*E-2:E,k=new Float64Array(3*G),D=e.defined(d)?new Uint8Array(4*G):void 0;let t=0,l=0;for(A=0;A<E;++A){const n=f[A];if(B&&A>0&&(o.Cartesian3.pack(n,k,t),t+=3,L=d[A-1],D[l++]=r.Color.floatToByte(L.red),D[l++]=r.Color.floatToByte(L.green),D[l++]=r.Color.floatToByte(L.blue),D[l++]=r.Color.floatToByte(L.alpha)),B&&A===E-1)break;o.Cartesian3.pack(n,k,t),t+=3,e.defined(d)&&(L=d[A],D[l++]=r.Color.floatToByte(L.red),D[l++]=r.Color.floatToByte(L.green),D[l++]=r.Color.floatToByte(L.blue),D[l++]=r.Color.floatToByte(L.alpha))}}const V=new s.GeometryAttributes;V.position=new a.GeometryAttribute({componentDatatype:n.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:k}),e.defined(d)&&(V.color=new a.GeometryAttribute({componentDatatype:n.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:4,values:D,normalize:!0})),G=k.length/3;const x=2*(G-1),S=c.IndexDatatype.createTypedArray(G,x);let I=0;for(A=0;A<G-1;++A)S[I++]=A,S[I++]=A+1;return new a.Geometry({attributes:V,indices:S,primitiveType:a.PrimitiveType.LINES,boundingSphere:l.BoundingSphere.fromPoints(f)})},function(t,l){return e.defined(l)&&(t=g.unpack(t,l)),t._ellipsoid=o.Ellipsoid.clone(t._ellipsoid),g.createGeometry(t)}}));