define(["./createTaskProcessorWorker","./defaultValue-f6d5e6da","./WebMercatorProjection-db7467f4","./Matrix3-b2351961","./Math-355606c6"],(function(e,t,n,r,o){"use strict";let i;function a(e,t,n,r){return r[e+t*n]}function s(e,t,n){const r=n.nativeExtent;let o=(e-r.west)/(r.east-r.west)*(n.width-1),i=(t-r.south)/(r.north-r.south)*(n.height-1);const l=Math.floor(o);let b=Math.floor(i);o-=l,i-=b;const h=l<n.width?l+1:l;let p=b<n.height?b+1:b;b=n.height-1-b,p=n.height-1-p;let g=function(e,t,n,r,o,i){return(n*(1-e)+r*e)*(1-t)+(o*(1-e)+i*e)*t}(o,i,a(l,b,n.width,n.buffer),a(h,b,n.width,n.buffer),a(l,p,n.width,n.buffer),a(h,p,n.width,n.buffer));return g=g*n.scale+n.offset,g}function u(e,t,o){for(let i=0;i<o.length;i++){const l=o[i].nativeExtent;let b=new r.Cartesian3;if("WebMercator"===o[i].projectionType){const l=o[i].projection._ellipsoid._radii;b=new n.WebMercatorProjection(new r.Ellipsoid(l.x,l.y,l.z)).project(new r.Cartographic(e,t,0))}else b.x=e,b.y=t;if(b.x>l.west&&b.x<l.east&&b.y>l.south&&b.y<l.north)return s(b.x,b.y,o[i])}return 0}function c(e,n,r,o){const b=new Uint8Array(e,0,5);return b[0]==="D".charCodeAt()&&b[1]==="R".charCodeAt()&&b[2]==="A".charCodeAt()&&b[3]==="C".charCodeAt()&&b[4]==="O".charCodeAt()?function(e){const n=i,r=new n.DecoderBuffer,o=new Uint8Array(e);r.Init(o,o.length);const l=new n.Decoder,b=l.GetEncodedGeometryType(r),h=new n.MetadataQuerier;let p,g;b===n.TRIANGULAR_MESH&&(p=new n.Mesh,g=l.DecodeBufferToMesh(r,p));const m={vertexCount:[0],featureCount:0};if(t.defined(g)&&g.ok()&&0!==p.ptr){const e=p.num_faces(),r=p.num_attributes(),o=p.num_points();m.indices=new Uint32Array(3*e);const i=m.indices;m.vertexCount[0]=o,m.scale_x=1,m.scale_y=1;const b=new n.DracoInt32Array(3);for(let t=0;t<e;++t)l.GetFaceFromMesh(p,t,b),i[3*t]=b.GetValue(0),i[3*t+1]=b.GetValue(1),i[3*t+2]=b.GetValue(2);n.destroy(b);for(let e=0;e<r;++e){const r=l.GetAttribute(p,e),i=f(n,l,p,r,o),b=r.attribute_type();let g="unknown";b===n.POSITION?g="positions":b===n.NORMAL?g="normals":b===n.COLOR?g="colors":b===n.TEX_COORD&&(g="uv0s");const A=l.GetAttributeMetadata(p,e);if(0!==A.ptr){const e=h.NumEntries(A);for(let t=0;t<e;++t){const e=h.GetEntryName(A,t);"i3s-scale_x"===e?m.scale_x=h.GetDoubleEntry(A,"i3s-scale_x"):"i3s-scale_y"===e?m.scale_y=h.GetDoubleEntry(A,"i3s-scale_y"):"i3s-attribute-type"===e&&(g=h.GetStringEntry(A,"i3s-attribute-type"))}}t.defined(m[g])&&console.log("Attribute already exists",g),m[g]=i,"feature-index"===g&&m.featureCount++}n.destroy(p)}return n.destroy(h),n.destroy(l),m}(e):function(e,n,r,o){const i={vertexCount:0},b=new DataView(e);try{let h=0;if(i.vertexCount=b.getUint32(h,1),h+=4,i.featureCount=b.getUint32(h,1),h+=4,t.defined(r))for(let n=0;n<r.attributes.length;n++)t.defined(l[r.attributes[n]])?h=l[r.attributes[n]](i,e,h):console.error("Unknown decoder for",r.attributes[n]);else{let r=n.ordering,b=n.featureAttributeOrder;t.defined(o)&&t.defined(o.geometryData)&&t.defined(o.geometryData[0])&&t.defined(o.geometryData[0].params)&&(r=Object.keys(o.geometryData[0].params.vertexAttributes),b=Object.keys(o.geometryData[0].params.featureAttributes));for(let n=0;n<r.length;n++){const o=l[r[n]];t.defined(o)||console.log(r[n]),h=o(i,e,h)}for(let n=0;n<b.length;n++){const r=l[b[n]];t.defined(r)||console.log(b[n]),h=r(i,e,h)}}}catch(e){console.error(e)}return i.scale_x=1,i.scale_y=1,i}(e,n,r,o)}function f(e,n,r,o,i){const l=o.num_components()*i;let b;const h=[function(){},function(){b=new e.DracoInt8Array(l),n.GetAttributeInt8ForAllPoints(r,o,b)||console.error("Bad stream");const t=new Int8Array(l);for(let e=0;e<l;++e)t[e]=b.GetValue(e);return t},function(){b=new e.DracoInt8Array(l),n.GetAttributeUInt8ForAllPoints(r,o,b)||console.error("Bad stream");const t=new Uint8Array(l);for(let e=0;e<l;++e)t[e]=b.GetValue(e);return t},function(){b=new e.DracoInt16Array(l),n.GetAttributeInt16ForAllPoints(r,o,b)||console.error("Bad stream");const t=new Int16Array(l);for(let e=0;e<l;++e)t[e]=b.GetValue(e);return t},function(){b=new e.DracoInt16Array(l),n.GetAttributeUInt16ForAllPoints(r,o,b)||console.error("Bad stream");const t=new Uint16Array(l);for(let e=0;e<l;++e)t[e]=b.GetValue(e);return t},function(){b=new e.DracoInt32Array(l),n.GetAttributeInt32ForAllPoints(r,o,b)||console.error("Bad stream");const t=new Int32Array(l);for(let e=0;e<l;++e)t[e]=b.GetValue(e);return t},function(){b=new e.DracoInt32Array(l),n.GetAttributeUInt32ForAllPoints(r,o,b)||console.error("Bad stream");const t=new Uint32Array(l);for(let e=0;e<l;++e)t[e]=b.GetValue(e);return t},function(){},function(){},function(){b=new e.DracoFloat32Array(l),n.GetAttributeFloatForAllPoints(r,o,b)||console.error("Bad stream");const t=new Float32Array(l);for(let e=0;e<l;++e)t[e]=b.GetValue(e);return t},function(){},function(){b=new e.DracoUInt8Array(l),n.GetAttributeUInt8ForAllPoints(r,o,b)||console.error("Bad stream");const t=new Uint8Array(l);for(let e=0;e<l;++e)t[e]=b.GetValue(e);return t}],p=h[o.data_type()]();return t.defined(b)&&e.destroy(b),p}const l={position:function(e,t,n){const r=3*e.vertexCount;return e.positions=new Float32Array(t,n,r),n+4*r},normal:function(e,t,n){const r=3*e.vertexCount;return e.normals=new Float32Array(t,n,r),n+4*r},uv0:function(e,t,n){const r=2*e.vertexCount;return e.uv0s=new Float32Array(t,n,r),n+4*r},color:function(e,t,n){const r=4*e.vertexCount;return e.colors=new Uint8Array(t,n,r),n+r},featureId:function(e,t,n){return n+8*e.featureCount},id:function(e,t,n){return n+8*e.featureCount},faceRange:function(e,t,n){const r=2*e.featureCount;return e.faceRange=new Uint32Array(t,n,r),n+4*r},uvRegion:function(e,t,n){const r=4*e.vertexCount;return e["uv-region"]=new Uint16Array(t,n,r),n+2*r},region:function(e,t,n){const r=4*e.vertexCount;return e["uv-region"]=new Uint16Array(t,n,r),n+2*r}};function d(e){const n=c(e.binaryData,e.schema,e.bufferInfo,e.featureData);t.defined(e.geoidDataList)&&e.geoidDataList.length>0&&function(e,t,n,r,i,l,b){const h=u(i.longitude,i.latitude,l);for(let b=0;b<e;++b){const e=u(i.longitude+o.CesiumMath.toRadians(n*t[3*b]),i.latitude+o.CesiumMath.toRadians(r*t[3*b+1]),l);t[3*b+2]+=e-h}}(n.vertexCount,n.positions,n.scale_x,n.scale_y,e.cartographicCenter,e.geoidDataList),function(e,n,i,l,b,h,p,g,m){if(0===e||!t.defined(n)||0===n.length)return;const A=new r.Ellipsoid(Math.sqrt(p.x),Math.sqrt(p.y),Math.sqrt(p.z));for(let p=0;p<e;++p){const e=3*p,w=e+1,I=e+2,C=new r.Cartographic;C.longitude=l.longitude+o.CesiumMath.toRadians(g*n[e]),C.latitude=l.latitude+o.CesiumMath.toRadians(m*n[w]),C.height=l.height+n[I];const x={};A.cartographicToCartesian(C,x),x.x-=b.x,x.y-=b.y,x.z-=b.z;const L={};if(r.Matrix3.multiplyByVector(h,x,L),n[e]=L.x,n[w]=L.y,n[I]=L.z,t.defined(i)){const t=new r.Cartesian3(i[e],i[w],i[I]),n={};r.Matrix3.multiplyByVector(h,t,n),i[e]=n.x,i[w]=n.y,i[I]=n.z}}}(n.vertexCount,n.positions,n.normals,e.cartographicCenter,e.cartesianCenter,e.parentRotation,e.ellipsoidRadiiSquare,n.scale_x,n.scale_y),t.defined(n.uv0s)&&t.defined(n["uv-region"])&&function(e,t,n){for(let r=0;r<e;++r){const e=n[4*r]/65535,o=n[4*r+1]/65535,i=(n[4*r+2]-n[4*r])/65535,l=(n[4*r+3]-n[4*r+1])/65535;t[2*r]*=i,t[2*r]+=e,t[2*r+1]*=l,t[2*r+1]+=o}}(n.vertexCount,n.uv0s,n["uv-region"]);const i=function(e,n,r,o,i,l){if(0===e||!t.defined(r)||0===r.length)return{buffers:[],bufferViews:[],accessors:[],meshes:[],nodes:[],nodesInScene:[]};const b=[],h=[],p=[],g=[],m=[],A=[];t.defined(n)&&(e=n.length);const w=new Uint32Array(e);if(t.defined(n))for(let t=0;t<e;++t)w[t]=n[t];else for(let t=0;t<e;++t)w[t]=t;const I=new Blob([w],{type:"application/binary"}),C=URL.createObjectURL(I),x=e,L=r.subarray(0,3*x),R=new Blob([L],{type:"application/binary"}),O=URL.createObjectURL(R);let _=Number.POSITIVE_INFINITY,v=Number.NEGATIVE_INFINITY,G=Number.POSITIVE_INFINITY,M=Number.NEGATIVE_INFINITY,U=Number.POSITIVE_INFINITY,V=Number.NEGATIVE_INFINITY;for(let e=0;e<L.length/3;e++)_=Math.min(_,L[3*e+0]),v=Math.max(v,L[3*e+0]),G=Math.min(G,L[3*e+1]),M=Math.max(M,L[3*e+1]),U=Math.min(U,L[3*e+2]),V=Math.max(V,L[3*e+2]);const D=o?o.subarray(0,3*x):void 0;let N;if(t.defined(D)){const e=new Blob([D],{type:"application/binary"});N=URL.createObjectURL(e)}const T=i?i.subarray(0,2*x):void 0;let E;if(t.defined(T)){const e=new Blob([T],{type:"application/binary"});E=URL.createObjectURL(e)}const F=t.defined(l)?l.subarray(0,4*x):void 0;let B;if(t.defined(F)){const e=new Blob([F],{type:"application/binary"});B=URL.createObjectURL(e)}let P=0,j=0,S=0,k=0,z=0;const Y={POSITION:0};return b.push({uri:O,byteLength:L.byteLength}),h.push({buffer:0,byteOffset:0,byteLength:L.byteLength,target:34962}),p.push({bufferView:0,byteOffset:0,componentType:5126,count:e,type:"VEC3",max:[_,G,U],min:[v,M,V]}),t.defined(N)&&(++z,P=z,Y.NORMAL=P,b.push({uri:N,byteLength:D.byteLength}),h.push({buffer:P,byteOffset:0,byteLength:D.byteLength,target:34962}),p.push({bufferView:P,byteOffset:0,componentType:5126,count:e,type:"VEC3"})),t.defined(E)&&(++z,j=z,Y.TEXCOORD_0=j,b.push({uri:E,byteLength:T.byteLength}),h.push({buffer:j,byteOffset:0,byteLength:T.byteLength,target:34962}),p.push({bufferView:j,byteOffset:0,componentType:5126,count:e,type:"VEC2"})),t.defined(B)&&(++z,S=z,Y.COLOR_0=S,b.push({uri:B,byteLength:F.byteLength}),h.push({buffer:S,byteOffset:0,byteLength:F.byteLength,target:34962}),p.push({bufferView:S,byteOffset:0,componentType:5121,normalized:!0,count:e,type:"VEC4"})),++z,k=z,b.push({uri:C,byteLength:w.byteLength}),h.push({buffer:k,byteOffset:0,byteLength:w.byteLength,target:34963}),p.push({bufferView:k,byteOffset:0,componentType:5125,count:e,type:"SCALAR"}),g.push({primitives:[{attributes:Y,indices:k,material:0}]}),A.push(0),m.push({mesh:0}),{buffers:b,bufferViews:h,accessors:p,meshes:g,nodes:m,nodesInScene:A}}(n.vertexCount,n.indices,n.positions,n.normals,n.uv0s,n.colors),l={};if(t.defined(n["feature-index"]))l.positions=n.positions,l.indices=n.indices,l.featureIndex=n["feature-index"],l.cartesianCenter=e.cartesianCenter,l.parentRotation=e.parentRotation;else if(t.defined(n.faceRange)){l.positions=n.positions,l.indices=n.indices,l.sourceURL=e.url,l.cartesianCenter=e.cartesianCenter,l.parentRotation=e.parentRotation,l.featureIndex=new Array(n.positions.length);for(let e=0;e<n.faceRange.length-1;e+=2){const t=e/2,r=n.faceRange[e],o=n.faceRange[e+1];for(let e=r;e<=o;e++)l.featureIndex[3*e]=t,l.featureIndex[3*e+1]=t,l.featureIndex[3*e+2]=t}}return i._customAttributes=l,{meshData:i}}function y(t){i=t,self.onmessage=e(d),self.postMessage(!0)}return function(e){const n=e.data.webAssemblyConfig;if(t.defined(n))return require([n.modulePath],(function(e){t.defined(n.wasmBinaryFile)?(t.defined(e)||(e=self.DracoDecoderModule),e(n).then((function(e){y(e)}))):y(e())}))}}));