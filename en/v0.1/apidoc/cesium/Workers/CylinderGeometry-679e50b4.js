/*! For license information please see CylinderGeometry-679e50b4.js.LICENSE.txt */
define(["exports","./Transforms-d3d3b2a9","./Matrix2-73789715","./ComponentDatatype-e7fbe225","./CylinderGeometryLibrary-24ad1484","./defaultValue-97284df2","./RuntimeError-4f8ec8a2","./GeometryAttribute-fd1d7e90","./GeometryAttributes-734a3446","./GeometryOffsetAttribute-59b14f45","./IndexDatatype-65271ba3","./VertexFormat-9886cb81"],(function(t,e,n,a,o,r,i,s,u,m,l,c){"use strict";const d=new n.Cartesian2,f=new n.Cartesian3,p=new n.Cartesian3,y=new n.Cartesian3,b=new n.Cartesian3;function A(t){const e=(t=r.defaultValue(t,r.defaultValue.EMPTY_OBJECT)).length,n=t.topRadius,a=t.bottomRadius,o=r.defaultValue(t.vertexFormat,c.VertexFormat.DEFAULT),i=r.defaultValue(t.slices,128);this._length=e,this._topRadius=n,this._bottomRadius=a,this._vertexFormat=c.VertexFormat.clone(o),this._slices=i,this._offsetAttribute=t.offsetAttribute,this._workerName="createCylinderGeometry"}A.packedLength=c.VertexFormat.packedLength+5,A.pack=function(t,e,n){return n=r.defaultValue(n,0),c.VertexFormat.pack(t._vertexFormat,e,n),n+=c.VertexFormat.packedLength,e[n++]=t._length,e[n++]=t._topRadius,e[n++]=t._bottomRadius,e[n++]=t._slices,e[n]=r.defaultValue(t._offsetAttribute,-1),e};const x=new c.VertexFormat,g={vertexFormat:x,length:void 0,topRadius:void 0,bottomRadius:void 0,slices:void 0,offsetAttribute:void 0};let _;A.unpack=function(t,e,n){e=r.defaultValue(e,0);const a=c.VertexFormat.unpack(t,e,x);e+=c.VertexFormat.packedLength;const o=t[e++],i=t[e++],s=t[e++],u=t[e++],m=t[e];return r.defined(n)?(n._vertexFormat=c.VertexFormat.clone(a,n._vertexFormat),n._length=o,n._topRadius=i,n._bottomRadius=s,n._slices=u,n._offsetAttribute=-1===m?void 0:m,n):(g.length=o,g.topRadius=i,g.bottomRadius=s,g.slices=u,g.offsetAttribute=-1===m?void 0:m,new A(g))},A.createGeometry=function(t){let i=t._length;const c=t._topRadius,x=t._bottomRadius,g=t._vertexFormat,_=t._slices;if(i<=0||c<0||x<0||0===c&&0===x)return;const h=_+_,F=_+h,v=h+h,C=o.CylinderGeometryLibrary.computePositions(i,c,x,_,!0),w=g.st?new Float32Array(2*v):void 0,G=g.normal?new Float32Array(3*v):void 0,R=g.tangent?new Float32Array(3*v):void 0,V=g.bitangent?new Float32Array(3*v):void 0;let D;const T=g.normal||g.tangent||g.bitangent;if(T){const t=g.tangent||g.bitangent;let e=0,o=0,r=0;const s=Math.atan2(x-c,i),u=f;u.z=Math.sin(s);const m=Math.cos(s);let l=y,d=p;for(D=0;D<_;D++){const i=D/_*a.CesiumMath.TWO_PI,s=m*Math.cos(i),c=m*Math.sin(i);T&&(u.x=s,u.y=c,t&&(l=n.Cartesian3.normalize(n.Cartesian3.cross(n.Cartesian3.UNIT_Z,u,l),l)),g.normal&&(G[e++]=u.x,G[e++]=u.y,G[e++]=u.z,G[e++]=u.x,G[e++]=u.y,G[e++]=u.z),g.tangent&&(R[o++]=l.x,R[o++]=l.y,R[o++]=l.z,R[o++]=l.x,R[o++]=l.y,R[o++]=l.z),g.bitangent&&(d=n.Cartesian3.normalize(n.Cartesian3.cross(u,l,d),d),V[r++]=d.x,V[r++]=d.y,V[r++]=d.z,V[r++]=d.x,V[r++]=d.y,V[r++]=d.z))}for(D=0;D<_;D++)g.normal&&(G[e++]=0,G[e++]=0,G[e++]=-1),g.tangent&&(R[o++]=1,R[o++]=0,R[o++]=0),g.bitangent&&(V[r++]=0,V[r++]=-1,V[r++]=0);for(D=0;D<_;D++)g.normal&&(G[e++]=0,G[e++]=0,G[e++]=1),g.tangent&&(R[o++]=1,R[o++]=0,R[o++]=0),g.bitangent&&(V[r++]=0,V[r++]=1,V[r++]=0)}const O=12*_-12,L=l.IndexDatatype.createTypedArray(v,O);let P=0,E=0;for(D=0;D<_-1;D++)L[P++]=E,L[P++]=E+2,L[P++]=E+3,L[P++]=E,L[P++]=E+3,L[P++]=E+1,E+=2;for(L[P++]=h-2,L[P++]=0,L[P++]=1,L[P++]=h-2,L[P++]=1,L[P++]=h-1,D=1;D<_-1;D++)L[P++]=h+D+1,L[P++]=h+D,L[P++]=h;for(D=1;D<_-1;D++)L[P++]=F,L[P++]=F+D,L[P++]=F+D+1;let M=0;if(g.st){const t=Math.max(c,x);for(D=0;D<v;D++){const e=n.Cartesian3.fromArray(C,3*D,b);w[M++]=(e.x+t)/(2*t),w[M++]=(e.y+t)/(2*t)}}const k=new u.GeometryAttributes;g.position&&(k.position=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:C})),g.normal&&(k.normal=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:G})),g.tangent&&(k.tangent=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:R})),g.bitangent&&(k.bitangent=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:V})),g.st&&(k.st=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:w})),d.x=.5*i,d.y=Math.max(x,c);const z=new e.BoundingSphere(n.Cartesian3.ZERO,n.Cartesian2.magnitude(d));if(r.defined(t._offsetAttribute)){i=C.length;const e=t._offsetAttribute===m.GeometryOffsetAttribute.NONE?0:1,n=new Uint8Array(i/3).fill(e);k.applyOffset=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}return new s.Geometry({attributes:k,indices:L,primitiveType:s.PrimitiveType.TRIANGLES,boundingSphere:z,offsetAttribute:t._offsetAttribute})},A.getUnitCylinder=function(){return r.defined(_)||(_=A.createGeometry(new A({topRadius:1,bottomRadius:1,length:1,vertexFormat:c.VertexFormat.POSITION_ONLY}))),_},t.CylinderGeometry=A}));