/*! For license information please see createCorridorOutlineGeometry.js.LICENSE.txt */
define(["./arrayRemoveDuplicates-63c6b4d8","./Transforms-c450597e","./Matrix2-21f90abf","./RuntimeError-cef79f54","./ComponentDatatype-4028c72d","./PolylineVolumeGeometryLibrary-12682ca2","./CorridorGeometryLibrary-17a0dde1","./defaultValue-4607806f","./GeometryAttribute-3c090c07","./GeometryAttributes-acac33d2","./GeometryOffsetAttribute-3e5f3e97","./IndexDatatype-20e78e57","./PolygonPipeline-13d40849","./_commonjsHelpers-a32ac251","./combine-fc59ba59","./WebGLConstants-f100e3dd","./EllipsoidTangentPlane-69b6e1fd","./AxisAlignedBoundingBox-cd3761c7","./IntersectionTests-ef65540c","./Plane-1c5eb32d","./PolylinePipeline-2aac2bf9","./EllipsoidGeodesic-b1c7082b","./EllipsoidRhumbLine-bf1c0ab0"],(function(e,t,i,r,o,n,s,a,l,d,u,p,c,f,h,y,g,b,m,A,_,E,C){"use strict";const G=new i.Cartesian3,T=new i.Cartesian3,P=new i.Cartesian3;function v(e,t){const r=[],u=e.positions,c=e.corners,f=e.endPositions,h=new d.GeometryAttributes;let y,g,b,m=0,A=0,_=0;for(g=0;g<u.length;g+=2)b=u[g].length-3,m+=b,_+=b/3*4,A+=u[g+1].length-3;for(m+=3,A+=3,g=0;g<c.length;g++){y=c[g];const e=c[g].leftPositions;a.defined(e)?(b=e.length,m+=b,_+=b/3*2):(b=c[g].rightPositions.length,A+=b,_+=b/3*2)}const E=a.defined(f);let C;E&&(C=f[0].length-3,m+=C,A+=C,C/=3,_+=4*C);const L=m+A,D=new Float64Array(L);let x,k,V,H,N,O,I=0,S=L-1;const B=C/2,M=p.IndexDatatype.createTypedArray(L/3,_+4);let R=0;if(M[R++]=I/3,M[R++]=(S-2)/3,E){r.push(I/3),O=G,N=T;const e=f[0];for(g=0;g<B;g++)O=i.Cartesian3.fromArray(e,3*(B-1-g),O),N=i.Cartesian3.fromArray(e,3*(B+g),N),s.CorridorGeometryLibrary.addAttribute(D,N,I),s.CorridorGeometryLibrary.addAttribute(D,O,void 0,S),k=I/3,H=k+1,x=(S-2)/3,V=x-1,M[R++]=x,M[R++]=V,M[R++]=k,M[R++]=H,I+=3,S-=3}let U=0,F=u[U++],Y=u[U++];for(D.set(F,I),D.set(Y,S-Y.length+1),b=Y.length-3,r.push(I/3,(S-2)/3),g=0;g<b;g+=3)k=I/3,H=k+1,x=(S-2)/3,V=x-1,M[R++]=x,M[R++]=V,M[R++]=k,M[R++]=H,I+=3,S-=3;for(g=0;g<c.length;g++){let e;y=c[g];const o=y.leftPositions,l=y.rightPositions;let d,p=P;if(a.defined(o)){for(S-=3,d=V,r.push(H),e=0;e<o.length/3;e++)p=i.Cartesian3.fromArray(o,3*e,p),M[R++]=d-e-1,M[R++]=d-e,s.CorridorGeometryLibrary.addAttribute(D,p,void 0,S),S-=3;r.push(d-Math.floor(o.length/6)),t===n.CornerType.BEVELED&&r.push((S-2)/3+1),I+=3}else{for(I+=3,d=H,r.push(V),e=0;e<l.length/3;e++)p=i.Cartesian3.fromArray(l,3*e,p),M[R++]=d+e,M[R++]=d+e+1,s.CorridorGeometryLibrary.addAttribute(D,p,I),I+=3;r.push(d+Math.floor(l.length/6)),t===n.CornerType.BEVELED&&r.push(I/3-1),S-=3}for(F=u[U++],Y=u[U++],F.splice(0,3),Y.splice(Y.length-3,3),D.set(F,I),D.set(Y,S-Y.length+1),b=Y.length-3,e=0;e<Y.length;e+=3)H=I/3,k=H-1,V=(S-2)/3,x=V+1,M[R++]=x,M[R++]=V,M[R++]=k,M[R++]=H,I+=3,S-=3;I-=3,S+=3,r.push(I/3,(S-2)/3)}if(E){I+=3,S-=3,O=G,N=T;const e=f[1];for(g=0;g<B;g++)O=i.Cartesian3.fromArray(e,3*(C-g-1),O),N=i.Cartesian3.fromArray(e,3*g,N),s.CorridorGeometryLibrary.addAttribute(D,O,void 0,S),s.CorridorGeometryLibrary.addAttribute(D,N,I),H=I/3,k=H-1,V=(S-2)/3,x=V+1,M[R++]=x,M[R++]=V,M[R++]=k,M[R++]=H,I+=3,S-=3;r.push(I/3)}else r.push(I/3,(S-2)/3);return M[R++]=I/3,M[R++]=(S-2)/3,h.position=new l.GeometryAttribute({componentDatatype:o.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:D}),{attributes:h,indices:M,wallIndices:r}}function w(e){const t=(e=a.defaultValue(e,a.defaultValue.EMPTY_OBJECT)).positions,r=e.width,s=a.defaultValue(e.height,0),l=a.defaultValue(e.extrudedHeight,s);this._positions=t,this._ellipsoid=i.Ellipsoid.clone(a.defaultValue(e.ellipsoid,i.Ellipsoid.WGS84)),this._width=r,this._height=Math.max(s,l),this._extrudedHeight=Math.min(s,l),this._cornerType=a.defaultValue(e.cornerType,n.CornerType.ROUNDED),this._granularity=a.defaultValue(e.granularity,o.CesiumMath.RADIANS_PER_DEGREE),this._offsetAttribute=e.offsetAttribute,this._workerName="createCorridorOutlineGeometry",this.packedLength=1+t.length*i.Cartesian3.packedLength+i.Ellipsoid.packedLength+6}w.pack=function(e,t,r){r=a.defaultValue(r,0);const o=e._positions,n=o.length;t[r++]=n;for(let e=0;e<n;++e,r+=i.Cartesian3.packedLength)i.Cartesian3.pack(o[e],t,r);return i.Ellipsoid.pack(e._ellipsoid,t,r),r+=i.Ellipsoid.packedLength,t[r++]=e._width,t[r++]=e._height,t[r++]=e._extrudedHeight,t[r++]=e._cornerType,t[r++]=e._granularity,t[r]=a.defaultValue(e._offsetAttribute,-1),t};const L=i.Ellipsoid.clone(i.Ellipsoid.UNIT_SPHERE),D={positions:void 0,ellipsoid:L,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,offsetAttribute:void 0};return w.unpack=function(e,t,r){t=a.defaultValue(t,0);const o=e[t++],n=new Array(o);for(let r=0;r<o;++r,t+=i.Cartesian3.packedLength)n[r]=i.Cartesian3.unpack(e,t);const s=i.Ellipsoid.unpack(e,t,L);t+=i.Ellipsoid.packedLength;const l=e[t++],d=e[t++],u=e[t++],p=e[t++],c=e[t++],f=e[t];return a.defined(r)?(r._positions=n,r._ellipsoid=i.Ellipsoid.clone(s,r._ellipsoid),r._width=l,r._height=d,r._extrudedHeight=u,r._cornerType=p,r._granularity=c,r._offsetAttribute=-1===f?void 0:f,r):(D.positions=n,D.width=l,D.height=d,D.extrudedHeight=u,D.cornerType=p,D.granularity=c,D.offsetAttribute=-1===f?void 0:f,new w(D))},w.createGeometry=function(r){let n=r._positions;const d=r._width,f=r._ellipsoid;n=function(e,t){for(let i=0;i<e.length;i++)e[i]=t.scaleToGeodeticSurface(e[i],e[i]);return e}(n,f);const h=e.arrayRemoveDuplicates(n,i.Cartesian3.equalsEpsilon);if(h.length<2||d<=0)return;const y=r._height,g=r._extrudedHeight,b=!o.CesiumMath.equalsEpsilon(y,g,0,o.CesiumMath.EPSILON2),m={ellipsoid:f,positions:h,width:d,cornerType:r._cornerType,granularity:r._granularity,saveAttributes:!1};let A;if(b)m.height=y,m.extrudedHeight=g,m.offsetAttribute=r._offsetAttribute,A=function(e){const t=e.ellipsoid,i=v(s.CorridorGeometryLibrary.computePositions(e),e.cornerType),r=i.wallIndices,n=e.height,d=e.extrudedHeight,f=i.attributes,h=i.indices;let y=f.position.values,g=y.length,b=new Float64Array(g);b.set(y);const m=new Float64Array(2*g);if(y=c.PolygonPipeline.scaleToGeodeticHeight(y,n,t),b=c.PolygonPipeline.scaleToGeodeticHeight(b,d,t),m.set(y),m.set(b,g),f.position.values=m,g/=3,a.defined(e.offsetAttribute)){let t=new Uint8Array(2*g);if(e.offsetAttribute===u.GeometryOffsetAttribute.TOP)t=t.fill(1,0,g);else{const i=e.offsetAttribute===u.GeometryOffsetAttribute.NONE?0:1;t=t.fill(i)}f.applyOffset=new l.GeometryAttribute({componentDatatype:o.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}let A;const _=h.length,E=p.IndexDatatype.createTypedArray(m.length/3,2*(_+r.length));E.set(h);let C,G,T=_;for(A=0;A<_;A+=2){const e=h[A],t=h[A+1];E[T++]=e+g,E[T++]=t+g}for(A=0;A<r.length;A++)C=r[A],G=C+g,E[T++]=C,E[T++]=G;return{attributes:f,indices:E}}(m);else if(A=v(s.CorridorGeometryLibrary.computePositions(m),m.cornerType),A.attributes.position.values=c.PolygonPipeline.scaleToGeodeticHeight(A.attributes.position.values,y,f),a.defined(r._offsetAttribute)){const e=A.attributes.position.values.length,t=r._offsetAttribute===u.GeometryOffsetAttribute.NONE?0:1,i=new Uint8Array(e/3).fill(t);A.attributes.applyOffset=new l.GeometryAttribute({componentDatatype:o.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}const _=A.attributes,E=t.BoundingSphere.fromVertices(_.position.values,void 0,3);return new l.Geometry({attributes:_,indices:A.indices,primitiveType:l.PrimitiveType.LINES,boundingSphere:E,offsetAttribute:r._offsetAttribute})},function(e,t){return a.defined(t)&&(e=w.unpack(e,t)),e._ellipsoid=i.Ellipsoid.clone(e._ellipsoid),w.createGeometry(e)}}));