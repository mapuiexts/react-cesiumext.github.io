define(["./defaultValue-0a909f67","./Matrix3-a348023f","./ArcType-ce2e50ab","./BoundingRectangle-e6c89457","./Transforms-01e95659","./Matrix2-7146c9ca","./ComponentDatatype-77274976","./EllipsoidGeodesic-f4dd0b26","./EllipsoidTangentPlane-6308603a","./GeometryAttribute-f5d71750","./GeometryInstance-99908f4f","./GeometryOffsetAttribute-04332ce7","./GeometryPipeline-049a5b67","./IndexDatatype-2149f06c","./Math-e97915da","./PolygonGeometryLibrary-364ec499","./PolygonPipeline-f5f5011c","./VertexFormat-ab2e00e6","./combine-ca22a614","./RuntimeError-06c93819","./WebGLConstants-a8cc3e8c","./AxisAlignedBoundingBox-65ccb1a5","./IntersectionTests-0bb04fde","./Plane-8575e17c","./AttributeCompression-50c9aeba","./EncodedCartesian3-0fb84db0","./arrayRemoveDuplicates-e9673044","./EllipsoidRhumbLine-9b24aab2","./GeometryAttributes-f06a2792"],(function(e,t,o,r,i,n,a,s,l,c,u,p,y,d,m,g,h,f,b,_,P,C,x,w,T,I,A,v,E){"use strict";const G=new t.Cartographic,O=new t.Cartographic;function L(e,t,o,r){const i=r.cartesianToCartographic(e,G).height,n=r.cartesianToCartographic(t,O);n.height=i,r.cartographicToCartesian(n,t);const a=r.cartesianToCartographic(o,O);a.height=i-100,r.cartographicToCartesian(a,o)}const V=new r.BoundingRectangle,H=new t.Cartesian3,D=new t.Cartesian3,N=new t.Cartesian3,F=new t.Cartesian3,R=new t.Cartesian3,M=new t.Cartesian3;let S=new t.Cartesian3,B=new t.Cartesian3,k=new t.Cartesian3;const z=new n.Cartesian2,W=new n.Cartesian2,Y=new t.Cartesian3,U=new i.Quaternion,j=new t.Matrix3,Q=new t.Matrix3;function q(o){const r=o.vertexFormat,s=o.geometry,l=o.shadowVolume,u=s.attributes.position.values,y=e.defined(s.attributes.st)?s.attributes.st.values:void 0;let d=u.length;const g=o.wall,h=o.top||g,f=o.bottom||g;if(r.st||r.normal||r.tangent||r.bitangent||l){const p=o.boundingRectangle,b=o.tangentPlane,_=o.ellipsoid,P=o.stRotation,C=o.perPositionHeight,x=z;x.x=p.x,x.y=p.y;const w=r.st?new Float32Array(d/3*2):void 0;let T;r.normal&&(T=C&&h&&!g?s.attributes.normal.values:new Float32Array(d));const I=r.tangent?new Float32Array(d):void 0,A=r.bitangent?new Float32Array(d):void 0,v=l?new Float32Array(d):void 0;let E=0,G=0,O=D,V=N,K=F,Z=!0,J=j,X=Q;if(0!==P){let e=i.Quaternion.fromAxisAngle(b._plane.normal,P,U);J=t.Matrix3.fromQuaternion(e,J),e=i.Quaternion.fromAxisAngle(b._plane.normal,-P,U),X=t.Matrix3.fromQuaternion(e,X)}else J=t.Matrix3.clone(t.Matrix3.IDENTITY,J),X=t.Matrix3.clone(t.Matrix3.IDENTITY,X);let ee=0,oe=0;h&&f&&(ee=d/2,oe=d/3,d/=2);for(let i=0;i<d;i+=3){const a=t.Cartesian3.fromArray(u,i,Y);if(r.st&&!e.defined(y)){let e=t.Matrix3.multiplyByVector(J,a,H);e=_.scaleToGeodeticSurface(e,e);const o=b.projectPointOntoPlane(e,W);n.Cartesian2.subtract(o,x,o);const r=m.CesiumMath.clamp(o.x/p.width,0,1),i=m.CesiumMath.clamp(o.y/p.height,0,1);f&&(w[E+oe]=r,w[E+1+oe]=i),h&&(w[E]=r,w[E+1]=i),E+=2}if(r.normal||r.tangent||r.bitangent||l){const e=G+1,n=G+2;if(g){if(i+3<d){const e=t.Cartesian3.fromArray(u,i+3,R);if(Z){const o=t.Cartesian3.fromArray(u,i+d,M);C&&L(a,e,o,_),t.Cartesian3.subtract(e,a,e),t.Cartesian3.subtract(o,a,o),O=t.Cartesian3.normalize(t.Cartesian3.cross(o,e,O),O),Z=!1}t.Cartesian3.equalsEpsilon(e,a,m.CesiumMath.EPSILON10)&&(Z=!0)}(r.tangent||r.bitangent)&&(K=_.geodeticSurfaceNormal(a,K),r.tangent&&(V=t.Cartesian3.normalize(t.Cartesian3.cross(K,O,V),V)))}else O=_.geodeticSurfaceNormal(a,O),(r.tangent||r.bitangent)&&(C&&(S=t.Cartesian3.fromArray(T,G,S),B=t.Cartesian3.cross(t.Cartesian3.UNIT_Z,S,B),B=t.Cartesian3.normalize(t.Matrix3.multiplyByVector(X,B,B),B),r.bitangent&&(k=t.Cartesian3.normalize(t.Cartesian3.cross(S,B,k),k))),V=t.Cartesian3.cross(t.Cartesian3.UNIT_Z,O,V),V=t.Cartesian3.normalize(t.Matrix3.multiplyByVector(X,V,V),V),r.bitangent&&(K=t.Cartesian3.normalize(t.Cartesian3.cross(O,V,K),K)));r.normal&&(o.wall?(T[G+ee]=O.x,T[e+ee]=O.y,T[n+ee]=O.z):f&&(T[G+ee]=-O.x,T[e+ee]=-O.y,T[n+ee]=-O.z),(h&&!C||g)&&(T[G]=O.x,T[e]=O.y,T[n]=O.z)),l&&(g&&(O=_.geodeticSurfaceNormal(a,O)),v[G+ee]=-O.x,v[e+ee]=-O.y,v[n+ee]=-O.z),r.tangent&&(o.wall?(I[G+ee]=V.x,I[e+ee]=V.y,I[n+ee]=V.z):f&&(I[G+ee]=-V.x,I[e+ee]=-V.y,I[n+ee]=-V.z),h&&(C?(I[G]=B.x,I[e]=B.y,I[n]=B.z):(I[G]=V.x,I[e]=V.y,I[n]=V.z))),r.bitangent&&(f&&(A[G+ee]=K.x,A[e+ee]=K.y,A[n+ee]=K.z),h&&(C?(A[G]=k.x,A[e]=k.y,A[n]=k.z):(A[G]=K.x,A[e]=K.y,A[n]=K.z))),G+=3}}r.st&&!e.defined(y)&&(s.attributes.st=new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:w})),r.normal&&(s.attributes.normal=new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:T})),r.tangent&&(s.attributes.tangent=new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:I})),r.bitangent&&(s.attributes.bitangent=new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:A})),l&&(s.attributes.extrudeDirection=new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:v}))}if(o.extrude&&e.defined(o.offsetAttribute)){const e=u.length/3;let t=new Uint8Array(e);if(o.offsetAttribute===p.GeometryOffsetAttribute.TOP)h&&f||g?t=t.fill(1,0,e/2):h&&(t=t.fill(1));else{const e=o.offsetAttribute===p.GeometryOffsetAttribute.NONE?0:1;t=t.fill(e)}s.attributes.applyOffset=new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}return s}const K=new t.Cartographic,Z=new t.Cartographic,J={westOverIDL:0,eastOverIDL:0};let X=new s.EllipsoidGeodesic;function $(t,r,i,a,l){if(l=e.defaultValue(l,new n.Rectangle),!e.defined(t)||t.length<3)return l.west=0,l.north=0,l.south=0,l.east=0,l;if(i===o.ArcType.RHUMB)return n.Rectangle.fromCartesianArray(t,r,l);X.ellipsoid.equals(r)||(X=new s.EllipsoidGeodesic(void 0,void 0,r)),l.west=Number.POSITIVE_INFINITY,l.east=Number.NEGATIVE_INFINITY,l.south=Number.POSITIVE_INFINITY,l.north=Number.NEGATIVE_INFINITY,J.westOverIDL=Number.POSITIVE_INFINITY,J.eastOverIDL=Number.NEGATIVE_INFINITY;const c=1/m.CesiumMath.chordLength(a,r.maximumRadius),u=t.length;let p,y=r.cartesianToCartographic(t[0],Z),d=K;for(let e=1;e<u;e++)p=d,d=y,y=r.cartesianToCartographic(t[e],p),X.setEndPoints(d,y),te(X,c,l,J);return p=d,d=y,y=r.cartesianToCartographic(t[0],p),X.setEndPoints(d,y),te(X,c,l,J),l.east-l.west>J.eastOverIDL-J.westOverIDL&&(l.west=J.westOverIDL,l.east=J.eastOverIDL,l.east>m.CesiumMath.PI&&(l.east=l.east-m.CesiumMath.TWO_PI),l.west>m.CesiumMath.PI&&(l.west=l.west-m.CesiumMath.TWO_PI)),l}const ee=new t.Cartographic;function te(e,t,o,r){const i=e.surfaceDistance,n=Math.ceil(i*t),a=n>0?i/(n-1):Number.POSITIVE_INFINITY;let s=0;for(let t=0;t<n;t++){const t=e.interpolateUsingSurfaceDistance(s,ee);s+=a;const i=t.longitude,n=t.latitude;o.west=Math.min(o.west,i),o.east=Math.max(o.east,i),o.south=Math.min(o.south,n),o.north=Math.max(o.north,n);const l=i>=0?i:i+m.CesiumMath.TWO_PI;r.westOverIDL=Math.min(r.westOverIDL,l),r.eastOverIDL=Math.max(r.eastOverIDL,l)}}const oe=[];function ie(t,o,r,i,n,a,s,c,p,y){const m={walls:[]};let f;if(s||c){const n=g.PolygonGeometryLibrary.createGeometryFromPositions(t,o,r,i,a,p,y),l=n.attributes.position.values,h=n.indices;let b,_;if(s&&c){const t=l.concat(l);b=t.length/3,_=d.IndexDatatype.createTypedArray(b,2*h.length),_.set(h);const o=h.length,i=b/2;for(f=0;f<o;f+=3){const e=_[f]+i,t=_[f+1]+i,r=_[f+2]+i;_[f+o]=r,_[f+1+o]=t,_[f+2+o]=e}if(n.attributes.position.values=t,a&&p.normal){const e=n.attributes.normal.values;n.attributes.normal.values=new Float32Array(t.length),n.attributes.normal.values.set(e)}if(p.st&&e.defined(r)){const e=n.attributes.st.values;n.attributes.st.values=new Float32Array(2*b),n.attributes.st.values=e.concat(e)}n.indices=_}else if(c){for(b=l.length/3,_=d.IndexDatatype.createTypedArray(b,h.length),f=0;f<h.length;f+=3)_[f]=h[f+2],_[f+1]=h[f+1],_[f+2]=h[f];n.indices=_}m.topAndBottom=new u.GeometryInstance({geometry:n})}let b=n.outerRing,_=l.EllipsoidTangentPlane.fromPoints(b,t),P=_.projectPointsOntoPlane(b,oe),C=h.PolygonPipeline.computeWindingOrder2D(P);C===h.WindingOrder.CLOCKWISE&&(b=b.slice().reverse());let x=g.PolygonGeometryLibrary.computeWallGeometry(b,r,t,i,a,y);m.walls.push(new u.GeometryInstance({geometry:x}));const w=n.holes;for(f=0;f<w.length;f++){let e=w[f];_=l.EllipsoidTangentPlane.fromPoints(e,t),P=_.projectPointsOntoPlane(e,oe),C=h.PolygonPipeline.computeWindingOrder2D(P),C===h.WindingOrder.COUNTER_CLOCKWISE&&(e=e.slice().reverse()),x=g.PolygonGeometryLibrary.computeWallGeometry(e,r,t,i,a,y),m.walls.push(new u.GeometryInstance({geometry:x}))}return m}function re(r){const i=r.polygonHierarchy,a=e.defaultValue(r.vertexFormat,f.VertexFormat.DEFAULT),s=e.defaultValue(r.ellipsoid,t.Ellipsoid.WGS84),l=e.defaultValue(r.granularity,m.CesiumMath.RADIANS_PER_DEGREE),c=e.defaultValue(r.stRotation,0),u=r.textureCoordinates,p=e.defaultValue(r.perPositionHeight,!1),y=p&&e.defined(r.extrudedHeight);let d=e.defaultValue(r.height,0),h=e.defaultValue(r.extrudedHeight,d);if(!y){const e=Math.max(d,h);h=Math.min(d,h),d=e}this._vertexFormat=f.VertexFormat.clone(a),this._ellipsoid=t.Ellipsoid.clone(s),this._granularity=l,this._stRotation=c,this._height=d,this._extrudedHeight=h,this._closeTop=e.defaultValue(r.closeTop,!0),this._closeBottom=e.defaultValue(r.closeBottom,!0),this._polygonHierarchy=i,this._perPositionHeight=p,this._perPositionHeightExtrude=y,this._shadowVolume=e.defaultValue(r.shadowVolume,!1),this._workerName="createPolygonGeometry",this._offsetAttribute=r.offsetAttribute,this._arcType=e.defaultValue(r.arcType,o.ArcType.GEODESIC),this._rectangle=void 0,this._textureCoordinateRotationPoints=void 0,this._textureCoordinates=u,this.packedLength=g.PolygonGeometryLibrary.computeHierarchyPackedLength(i,t.Cartesian3)+t.Ellipsoid.packedLength+f.VertexFormat.packedLength+(u?g.PolygonGeometryLibrary.computeHierarchyPackedLength(u,n.Cartesian2):1)+12}re.fromPositions=function(t){return new re({polygonHierarchy:{positions:(t=e.defaultValue(t,e.defaultValue.EMPTY_OBJECT)).positions},height:t.height,extrudedHeight:t.extrudedHeight,vertexFormat:t.vertexFormat,stRotation:t.stRotation,ellipsoid:t.ellipsoid,granularity:t.granularity,perPositionHeight:t.perPositionHeight,closeTop:t.closeTop,closeBottom:t.closeBottom,offsetAttribute:t.offsetAttribute,arcType:t.arcType,textureCoordinates:t.textureCoordinates})},re.pack=function(o,r,i){return i=e.defaultValue(i,0),i=g.PolygonGeometryLibrary.packPolygonHierarchy(o._polygonHierarchy,r,i,t.Cartesian3),t.Ellipsoid.pack(o._ellipsoid,r,i),i+=t.Ellipsoid.packedLength,f.VertexFormat.pack(o._vertexFormat,r,i),i+=f.VertexFormat.packedLength,r[i++]=o._height,r[i++]=o._extrudedHeight,r[i++]=o._granularity,r[i++]=o._stRotation,r[i++]=o._perPositionHeightExtrude?1:0,r[i++]=o._perPositionHeight?1:0,r[i++]=o._closeTop?1:0,r[i++]=o._closeBottom?1:0,r[i++]=o._shadowVolume?1:0,r[i++]=e.defaultValue(o._offsetAttribute,-1),r[i++]=o._arcType,e.defined(o._textureCoordinates)?i=g.PolygonGeometryLibrary.packPolygonHierarchy(o._textureCoordinates,r,i,n.Cartesian2):r[i++]=-1,r[i++]=o.packedLength,r};const ne=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),ae=new f.VertexFormat,se={polygonHierarchy:{}};return re.unpack=function(o,r,i){r=e.defaultValue(r,0);const a=g.PolygonGeometryLibrary.unpackPolygonHierarchy(o,r,t.Cartesian3);r=a.startingIndex,delete a.startingIndex;const s=t.Ellipsoid.unpack(o,r,ne);r+=t.Ellipsoid.packedLength;const l=f.VertexFormat.unpack(o,r,ae);r+=f.VertexFormat.packedLength;const c=o[r++],u=o[r++],p=o[r++],y=o[r++],d=1===o[r++],m=1===o[r++],h=1===o[r++],b=1===o[r++],_=1===o[r++],P=o[r++],C=o[r++],x=-1===o[r]?void 0:g.PolygonGeometryLibrary.unpackPolygonHierarchy(o,r,n.Cartesian2);e.defined(x)?(r=x.startingIndex,delete x.startingIndex):r++;const w=o[r++];return e.defined(i)||(i=new re(se)),i._polygonHierarchy=a,i._ellipsoid=t.Ellipsoid.clone(s,i._ellipsoid),i._vertexFormat=f.VertexFormat.clone(l,i._vertexFormat),i._height=c,i._extrudedHeight=u,i._granularity=p,i._stRotation=y,i._perPositionHeightExtrude=d,i._perPositionHeight=m,i._closeTop=h,i._closeBottom=b,i._shadowVolume=_,i._offsetAttribute=-1===P?void 0:P,i._arcType=C,i._textureCoordinates=x,i.packedLength=w,i},re.computeRectangle=function(r,i){const n=e.defaultValue(r.granularity,m.CesiumMath.RADIANS_PER_DEGREE),a=e.defaultValue(r.arcType,o.ArcType.GEODESIC),s=r.polygonHierarchy,l=e.defaultValue(r.ellipsoid,t.Ellipsoid.WGS84);return $(s.positions,l,a,n,i)},re.createGeometry=function(t){const o=t._vertexFormat,r=t._ellipsoid,n=t._granularity,s=t._stRotation,f=t._polygonHierarchy,b=t._perPositionHeight,_=t._closeTop,P=t._closeBottom,C=t._arcType,x=t._textureCoordinates,w=e.defined(x);let T=f.positions;if(T.length<3)return;const I=l.EllipsoidTangentPlane.fromPoints(T,r),A=g.PolygonGeometryLibrary.polygonsFromHierarchy(f,w,I.projectPointsOntoPlane.bind(I),!b,r),v=A.hierarchy,E=A.polygons,G=w?g.PolygonGeometryLibrary.polygonsFromHierarchy(x,!0,(function(e){return e}),!1).polygons:void 0;if(0===v.length)return;T=v[0].outerRing;const O=g.PolygonGeometryLibrary.computeBoundingRectangle(I.plane.normal,I.projectPointOntoPlane.bind(I),T,s,V),H=[],D=t._height,N=t._extrudedHeight,F={perPositionHeight:b,vertexFormat:o,geometry:void 0,tangentPlane:I,boundingRectangle:O,ellipsoid:r,stRotation:s,textureCoordinates:void 0,bottom:!1,top:!0,wall:!1,extrude:!1,arcType:C};let R;if(t._perPositionHeightExtrude||!m.CesiumMath.equalsEpsilon(D,N,0,m.CesiumMath.EPSILON2))for(F.extrude=!0,F.top=_,F.bottom=P,F.shadowVolume=t._shadowVolume,F.offsetAttribute=t._offsetAttribute,R=0;R<E.length;R++){const e=ie(r,E[R],w?G[R]:void 0,n,v[R],b,_,P,o,C);let t;_&&P?(t=e.topAndBottom,F.geometry=g.PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(t.geometry,D,N,r,b)):_?(t=e.topAndBottom,t.geometry.attributes.position.values=h.PolygonPipeline.scaleToGeodeticHeight(t.geometry.attributes.position.values,D,r,!b),F.geometry=t.geometry):P&&(t=e.topAndBottom,t.geometry.attributes.position.values=h.PolygonPipeline.scaleToGeodeticHeight(t.geometry.attributes.position.values,N,r,!0),F.geometry=t.geometry),(_||P)&&(F.wall=!1,t.geometry=q(F),H.push(t));const i=e.walls;F.wall=!0;for(let e=0;e<i.length;e++){const t=i[e];F.geometry=g.PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(t.geometry,D,N,r,b),t.geometry=q(F),H.push(t)}}else for(R=0;R<E.length;R++){const i=new u.GeometryInstance({geometry:g.PolygonGeometryLibrary.createGeometryFromPositions(r,E[R],w?G[R]:void 0,n,b,o,C)});if(i.geometry.attributes.position.values=h.PolygonPipeline.scaleToGeodeticHeight(i.geometry.attributes.position.values,D,r,!b),F.geometry=i.geometry,i.geometry=q(F),e.defined(t._offsetAttribute)){const e=i.geometry.attributes.position.values.length,o=t._offsetAttribute===p.GeometryOffsetAttribute.NONE?0:1,r=new Uint8Array(e/3).fill(o);i.geometry.attributes.applyOffset=new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:r})}H.push(i)}const M=y.GeometryPipeline.combineInstances(H)[0];M.attributes.position.values=new Float64Array(M.attributes.position.values),M.indices=d.IndexDatatype.createTypedArray(M.attributes.position.values.length/3,M.indices);const S=M.attributes,B=i.BoundingSphere.fromVertices(S.position.values);return o.position||delete S.position,new c.Geometry({attributes:S,indices:M.indices,primitiveType:M.primitiveType,boundingSphere:B,offsetAttribute:t._offsetAttribute})},re.createShadowVolume=function(e,t,o){const r=e._granularity,i=e._ellipsoid,n=t(r,i),a=o(r,i);return new re({polygonHierarchy:e._polygonHierarchy,ellipsoid:i,stRotation:e._stRotation,granularity:r,perPositionHeight:!1,extrudedHeight:n,height:a,vertexFormat:f.VertexFormat.POSITION_ONLY,shadowVolume:!0,arcType:e._arcType})},Object.defineProperties(re.prototype,{rectangle:{get:function(){if(!e.defined(this._rectangle)){const e=this._polygonHierarchy.positions;this._rectangle=$(e,this._ellipsoid,this._arcType,this._granularity)}return this._rectangle}},textureCoordinateRotationPoints:{get:function(){return e.defined(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(e){const t=-e._stRotation;if(0===t)return[0,0,0,1,1,0];const o=e._ellipsoid,r=e._polygonHierarchy.positions,i=e.rectangle;return c.Geometry._textureCoordinateRotationPoints(r,t,o,i)}(this)),this._textureCoordinateRotationPoints}}}),function(o,r){return e.defined(r)&&(o=re.unpack(o,r)),o._ellipsoid=t.Ellipsoid.clone(o._ellipsoid),re.createGeometry(o)}}));