/*! For license information please see createGroundPolylineGeometry.js.LICENSE.txt */
define(["./Transforms-d3d3b2a9","./Matrix2-73789715","./RuntimeError-4f8ec8a2","./defaultValue-97284df2","./ComponentDatatype-e7fbe225","./ArcType-de5d8777","./arrayRemoveDuplicates-6f91355d","./EllipsoidGeodesic-ed8a0e40","./EllipsoidRhumbLine-60f14314","./EncodedCartesian3-a9a8a281","./GeometryAttribute-fd1d7e90","./IntersectionTests-33ace2d6","./Plane-e916220d","./WebMercatorProjection-04ef6bc3","./_commonjsHelpers-3aae1032-65601a27","./combine-d11b1f00","./WebGLConstants-6da700a2"],(function(e,t,a,n,i,r,s,o,l,c,u,C,d,p,h,g,f){"use strict";function m(a){a=n.defaultValue(a,n.defaultValue.EMPTY_OBJECT),this._ellipsoid=n.defaultValue(a.ellipsoid,t.Ellipsoid.WGS84),this._rectangle=n.defaultValue(a.rectangle,t.Rectangle.MAX_VALUE),this._projection=new e.GeographicProjection(this._ellipsoid),this._numberOfLevelZeroTilesX=n.defaultValue(a.numberOfLevelZeroTilesX,2),this._numberOfLevelZeroTilesY=n.defaultValue(a.numberOfLevelZeroTilesY,1)}Object.defineProperties(m.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},rectangle:{get:function(){return this._rectangle}},projection:{get:function(){return this._projection}}}),m.prototype.getNumberOfXTilesAtLevel=function(e){return this._numberOfLevelZeroTilesX<<e},m.prototype.getNumberOfYTilesAtLevel=function(e){return this._numberOfLevelZeroTilesY<<e},m.prototype.rectangleToNativeRectangle=function(e,a){const r=i.CesiumMath.toDegrees(e.west),s=i.CesiumMath.toDegrees(e.south),o=i.CesiumMath.toDegrees(e.east),l=i.CesiumMath.toDegrees(e.north);return n.defined(a)?(a.west=r,a.south=s,a.east=o,a.north=l,a):new t.Rectangle(r,s,o,l)},m.prototype.tileXYToNativeRectangle=function(e,t,a,n){const r=this.tileXYToRectangle(e,t,a,n);return r.west=i.CesiumMath.toDegrees(r.west),r.south=i.CesiumMath.toDegrees(r.south),r.east=i.CesiumMath.toDegrees(r.east),r.north=i.CesiumMath.toDegrees(r.north),r},m.prototype.tileXYToRectangle=function(e,a,i,r){const s=this._rectangle,o=this.getNumberOfXTilesAtLevel(i),l=this.getNumberOfYTilesAtLevel(i),c=s.width/o,u=e*c+s.west,C=(e+1)*c+s.west,d=s.height/l,p=s.north-a*d,h=s.north-(a+1)*d;return n.defined(r)||(r=new t.Rectangle(u,h,C,p)),r.west=u,r.south=h,r.east=C,r.north=p,r},m.prototype.positionToTileXY=function(e,a,r){const s=this._rectangle;if(!t.Rectangle.contains(s,e))return;const o=this.getNumberOfXTilesAtLevel(a),l=this.getNumberOfYTilesAtLevel(a),c=s.width/o,u=s.height/l;let C=e.longitude;s.east<s.west&&(C+=i.CesiumMath.TWO_PI);let d=(C-s.west)/c|0;d>=o&&(d=o-1);let p=(s.north-e.latitude)/u|0;return p>=l&&(p=l-1),n.defined(r)?(r.x=d,r.y=p,r):new t.Cartesian2(d,p)};const w=new t.Cartesian3,y=new t.Cartesian3,M=new t.Cartographic,T=new t.Cartesian3,E=new t.Cartesian3,_=new e.BoundingSphere,O=new m,P=[new t.Cartographic,new t.Cartographic,new t.Cartographic,new t.Cartographic],b=new t.Cartesian2,A={};function k(e){t.Cartographic.fromRadians(e.east,e.north,0,P[0]),t.Cartographic.fromRadians(e.west,e.north,0,P[1]),t.Cartographic.fromRadians(e.east,e.south,0,P[2]),t.Cartographic.fromRadians(e.west,e.south,0,P[3]);let a=0,n=0,i=0,r=0;const s=A._terrainHeightsMaxLevel;let o;for(o=0;o<=s;++o){let e=!1;for(let t=0;t<4;++t){const a=P[t];if(O.positionToTileXY(a,o,b),0===t)i=b.x,r=b.y;else if(i!==b.x||r!==b.y){e=!0;break}}if(e)break;a=i,n=r}if(0!==o)return{x:a,y:n,level:o>s?s:o-1}}A.initialize=function(){let t=A._initPromise;return n.defined(t)||(t=e.Resource.fetchJson(e.buildModuleUrl("Assets/approximateTerrainHeights.json")).then((function(e){A._terrainHeights=e})),A._initPromise=t),t},A.getMinimumMaximumHeights=function(e,a){a=n.defaultValue(a,t.Ellipsoid.WGS84);const i=k(e);let r=A._defaultMinTerrainHeight,s=A._defaultMaxTerrainHeight;if(n.defined(i)){const o=`${i.level}-${i.x}-${i.y}`,l=A._terrainHeights[o];n.defined(l)&&(r=l[0],s=l[1]),a.cartographicToCartesian(t.Rectangle.northeast(e,M),w),a.cartographicToCartesian(t.Rectangle.southwest(e,M),y),t.Cartesian3.midpoint(y,w,T);const c=a.scaleToGeodeticSurface(T,E);if(n.defined(c)){const e=t.Cartesian3.distance(T,c);r=Math.min(r,-e)}else r=A._defaultMinTerrainHeight}return r=Math.max(A._defaultMinTerrainHeight,r),{minimumTerrainHeight:r,maximumTerrainHeight:s}},A.getBoundingSphere=function(a,i){i=n.defaultValue(i,t.Ellipsoid.WGS84);const r=k(a);let s=A._defaultMaxTerrainHeight;if(n.defined(r)){const e=`${r.level}-${r.x}-${r.y}`,t=A._terrainHeights[e];n.defined(t)&&(s=t[1])}const o=e.BoundingSphere.fromRectangle3D(a,i,0);return e.BoundingSphere.fromRectangle3D(a,i,s,_),e.BoundingSphere.union(o,_,o)},A._terrainHeightsMaxLevel=6,A._defaultMaxTerrainHeight=9e3,A._defaultMinTerrainHeight=-1e5,A._terrainHeights=void 0,A._initPromise=void 0,Object.defineProperties(A,{initialized:{get:function(){return n.defined(A._terrainHeights)}}});const L=[e.GeographicProjection,p.WebMercatorProjection],S=L.length,x=Math.cos(i.CesiumMath.toRadians(30)),I=Math.cos(i.CesiumMath.toRadians(150));function N(e){const a=(e=n.defaultValue(e,n.defaultValue.EMPTY_OBJECT)).positions;this.width=n.defaultValue(e.width,1),this._positions=a,this.granularity=n.defaultValue(e.granularity,9999),this.loop=n.defaultValue(e.loop,!1),this.arcType=n.defaultValue(e.arcType,r.ArcType.GEODESIC),this._ellipsoid=t.Ellipsoid.WGS84,this._projectionIndex=0,this._workerName="createGroundPolylineGeometry",this._scene3DOnly=!1}Object.defineProperties(N.prototype,{packedLength:{get:function(){return 1+3*this._positions.length+1+1+1+t.Ellipsoid.packedLength+1+1}}}),N.setProjectionAndEllipsoid=function(e,t){let a=0;for(let e=0;e<S;e++)if(t instanceof L[e]){a=e;break}e._projectionIndex=a,e._ellipsoid=t.ellipsoid};const R=new t.Cartesian3,D=new t.Cartesian3,v=new t.Cartesian3;function z(e,a,n,i,r){const s=F(i,e,0,R),o=F(i,e,n,D),l=F(i,a,0,v),c=q(o,s,D),u=q(l,s,v);return t.Cartesian3.cross(u,c,r),t.Cartesian3.normalize(r,r)}const H=new t.Cartographic,j=new t.Cartesian3,B=new t.Cartesian3,V=new t.Cartesian3;function G(e,a,n,i,s,c,u,C,d,p,h){if(0===s)return;let g;c===r.ArcType.GEODESIC?g=new o.EllipsoidGeodesic(e,a,u):c===r.ArcType.RHUMB&&(g=new l.EllipsoidRhumbLine(e,a,u));const f=g.surfaceDistance;if(f<s)return;const w=z(e,a,i,u,V),y=Math.ceil(f/s),M=f/y;let T=M;const E=y-1;let _=C.length;for(let e=0;e<E;e++){const e=g.interpolateUsingSurfaceDistance(T,H),a=F(u,e,n,j),r=F(u,e,i,B);t.Cartesian3.pack(w,C,_),t.Cartesian3.pack(a,d,_),t.Cartesian3.pack(r,p,_),h.push(e.latitude),h.push(e.longitude),_+=3,T+=M}}const Y=new t.Cartographic;function F(e,a,n,i){return t.Cartographic.clone(a,Y),Y.height=n,t.Cartographic.toCartesian(Y,e,i)}function q(e,a,n){return t.Cartesian3.subtract(e,a,n),t.Cartesian3.normalize(n,n),n}function X(e,a,n,i){return i=q(e,a,i),i=t.Cartesian3.cross(i,n,i),i=t.Cartesian3.normalize(i,i),t.Cartesian3.cross(n,i,i)}N.pack=function(e,a,i){let r=n.defaultValue(i,0);const s=e._positions,o=s.length;a[r++]=o;for(let e=0;e<o;++e){const n=s[e];t.Cartesian3.pack(n,a,r),r+=3}return a[r++]=e.granularity,a[r++]=e.loop?1:0,a[r++]=e.arcType,t.Ellipsoid.pack(e._ellipsoid,a,r),r+=t.Ellipsoid.packedLength,a[r++]=e._projectionIndex,a[r++]=e._scene3DOnly?1:0,a},N.unpack=function(e,a,i){let r=n.defaultValue(a,0);const s=e[r++],o=new Array(s);for(let a=0;a<s;a++)o[a]=t.Cartesian3.unpack(e,r),r+=3;const l=e[r++],c=1===e[r++],u=e[r++],C=t.Ellipsoid.unpack(e,r);r+=t.Ellipsoid.packedLength;const d=e[r++],p=1===e[r++];return n.defined(i)||(i=new N({positions:o})),i._positions=o,i.granularity=l,i.loop=c,i.arcType=u,i._ellipsoid=C,i._projectionIndex=d,i._scene3DOnly=p,i};const W=new t.Cartesian3,U=new t.Cartesian3,Z=new t.Cartesian3,$=new t.Cartesian3;function J(e,a,n,r,s){const o=q(n,a,$),l=X(e,a,o,W),c=X(r,a,o,U);if(i.CesiumMath.equalsEpsilon(t.Cartesian3.dot(l,c),-1,i.CesiumMath.EPSILON5))return s=t.Cartesian3.cross(o,l,s),t.Cartesian3.normalize(s,s);s=t.Cartesian3.add(c,l,s),s=t.Cartesian3.normalize(s,s);const u=t.Cartesian3.cross(o,s,Z);return t.Cartesian3.dot(c,u)<0&&(s=t.Cartesian3.negate(s,s)),s}const Q=d.Plane.fromPointNormal(t.Cartesian3.ZERO,t.Cartesian3.UNIT_Y),K=new t.Cartesian3,ee=new t.Cartesian3,te=new t.Cartesian3,ae=new t.Cartesian3,ne=new t.Cartesian3,ie=new t.Cartesian3,re=new t.Cartographic,se=new t.Cartographic,oe=new t.Cartographic;N.createGeometry=function(a){const o=!a._scene3DOnly;let d=a.loop;const p=a._ellipsoid,h=a.granularity,g=a.arcType,f=new L[a._projectionIndex](p),w=1e3;let y,M;const T=a._positions,E=T.length;let _,O,P,b;2===E&&(d=!1);const S=new l.EllipsoidRhumbLine(void 0,void 0,p);let I,R,D;const v=[T[0]];for(M=0;M<E-1;M++)_=T[M],O=T[M+1],I=C.IntersectionTests.lineSegmentPlane(_,O,Q,ie),!n.defined(I)||t.Cartesian3.equalsEpsilon(I,_,i.CesiumMath.EPSILON7)||t.Cartesian3.equalsEpsilon(I,O,i.CesiumMath.EPSILON7)||(a.arcType===r.ArcType.GEODESIC?v.push(t.Cartesian3.clone(I)):a.arcType===r.ArcType.RHUMB&&(D=p.cartesianToCartographic(I,re).longitude,P=p.cartesianToCartographic(_,re),b=p.cartesianToCartographic(O,se),S.setEndPoints(P,b),R=S.findIntersectionWithLongitude(D,oe),I=p.cartographicToCartesian(R,ie),!n.defined(I)||t.Cartesian3.equalsEpsilon(I,_,i.CesiumMath.EPSILON7)||t.Cartesian3.equalsEpsilon(I,O,i.CesiumMath.EPSILON7)||v.push(t.Cartesian3.clone(I)))),v.push(O);d&&(_=T[E-1],O=T[0],I=C.IntersectionTests.lineSegmentPlane(_,O,Q,ie),!n.defined(I)||t.Cartesian3.equalsEpsilon(I,_,i.CesiumMath.EPSILON7)||t.Cartesian3.equalsEpsilon(I,O,i.CesiumMath.EPSILON7)||(a.arcType===r.ArcType.GEODESIC?v.push(t.Cartesian3.clone(I)):a.arcType===r.ArcType.RHUMB&&(D=p.cartesianToCartographic(I,re).longitude,P=p.cartesianToCartographic(_,re),b=p.cartesianToCartographic(O,se),S.setEndPoints(P,b),R=S.findIntersectionWithLongitude(D,oe),I=p.cartographicToCartesian(R,ie),!n.defined(I)||t.Cartesian3.equalsEpsilon(I,_,i.CesiumMath.EPSILON7)||t.Cartesian3.equalsEpsilon(I,O,i.CesiumMath.EPSILON7)||v.push(t.Cartesian3.clone(I)))));let H=v.length,j=new Array(H);for(M=0;M<H;M++){const e=t.Cartographic.fromCartesian(v[M],p);e.height=0,j[M]=e}if(j=s.arrayRemoveDuplicates(j,t.Cartographic.equalsEpsilon),H=j.length,H<2)return;const B=[],V=[],Y=[],W=[];let U=K,Z=ee,$=te,le=ae,ce=ne;const ue=j[0],de=j[1];for(U=F(p,j[H-1],0,U),le=F(p,de,0,le),Z=F(p,ue,0,Z),$=F(p,ue,w,$),ce=d?J(U,Z,$,le,ce):z(ue,de,w,p,ce),t.Cartesian3.pack(ce,V,0),t.Cartesian3.pack(Z,Y,0),t.Cartesian3.pack($,W,0),B.push(ue.latitude),B.push(ue.longitude),G(ue,de,0,w,h,g,p,V,Y,W,B),M=1;M<H-1;++M){U=t.Cartesian3.clone(Z,U),Z=t.Cartesian3.clone(le,Z);const e=j[M];F(p,e,w,$),F(p,j[M+1],0,le),J(U,Z,$,le,ce),y=V.length,t.Cartesian3.pack(ce,V,y),t.Cartesian3.pack(Z,Y,y),t.Cartesian3.pack($,W,y),B.push(e.latitude),B.push(e.longitude),G(j[M],j[M+1],0,w,h,g,p,V,Y,W,B)}const pe=j[H-1],he=j[H-2];if(Z=F(p,pe,0,Z),$=F(p,pe,w,$),d){const e=j[0];U=F(p,he,0,U),le=F(p,e,0,le),ce=J(U,Z,$,le,ce)}else ce=z(he,pe,w,p,ce);if(y=V.length,t.Cartesian3.pack(ce,V,y),t.Cartesian3.pack(Z,Y,y),t.Cartesian3.pack($,W,y),B.push(pe.latitude),B.push(pe.longitude),d){for(G(pe,ue,0,w,h,g,p,V,Y,W,B),y=V.length,M=0;M<3;++M)V[y+M]=V[M],Y[y+M]=Y[M],W[y+M]=W[M];B.push(ue.latitude),B.push(ue.longitude)}return function(a,n,r,s,o,l,C){let d,p;const h=n._ellipsoid,g=r.length/3-1,f=8*g,w=4*f,y=36*g,M=f>65535?new Uint32Array(y):new Uint16Array(y),T=new Float64Array(3*f),E=new Float32Array(w),_=new Float32Array(w),O=new Float32Array(w),P=new Float32Array(w),b=new Float32Array(w);let L,S,I,R;C&&(L=new Float32Array(w),S=new Float32Array(w),I=new Float32Array(w),R=new Float32Array(2*f));const D=l.length/2;let v=0;const H=Ee;H.height=0;const j=_e;j.height=0;let B=Oe,V=Pe;if(C)for(p=0,d=1;d<D;d++)H.latitude=l[p],H.longitude=l[p+1],j.latitude=l[p+2],j.longitude=l[p+3],B=n.project(H,B),V=n.project(j,V),v+=t.Cartesian3.distance(B,V),p+=2;const Y=s.length/3;V=t.Cartesian3.unpack(s,0,V);let W,U=0;for(p=3,d=1;d<Y;d++)B=t.Cartesian3.clone(V,B),V=t.Cartesian3.unpack(s,p,V),U+=t.Cartesian3.distance(B,V),p+=3;p=3;let Z=0,$=0,Q=0,K=0,ee=!1,te=t.Cartesian3.unpack(r,0,ke),ae=t.Cartesian3.unpack(s,0,Pe),ne=t.Cartesian3.unpack(o,0,Le);a&&Ce(ne,t.Cartesian3.unpack(r,r.length-6,be),te,ae)&&(ne=t.Cartesian3.negate(ne,ne));let ie=0,re=0,se=0;for(d=0;d<g;d++){const e=t.Cartesian3.clone(te,be),a=t.Cartesian3.clone(ae,Oe);let u,d,g,f,w=t.Cartesian3.clone(ne,Ae);if(ee&&(w=t.Cartesian3.negate(w,w)),te=t.Cartesian3.unpack(r,p,ke),ae=t.Cartesian3.unpack(s,p,Pe),ne=t.Cartesian3.unpack(o,p,Le),ee=Ce(ne,e,te,ae),H.latitude=l[Z],H.longitude=l[Z+1],j.latitude=l[Z+2],j.longitude=l[Z+3],C){const e=Te(H,j);u=n.project(H,ze),d=n.project(j,Fe);const a=q(d,u,Ue);a.y=Math.abs(a.y),g=ve,f=Ge,0===e||t.Cartesian3.dot(a,t.Cartesian3.UNIT_Y)>x?(g=ge(n,H,w,u,ve),f=ge(n,j,ne,d,Ge)):1===e?(f=ge(n,j,ne,d,Ge),g.x=0,g.y=i.CesiumMath.sign(H.longitude-Math.abs(j.longitude)),g.z=0):(g=ge(n,H,w,u,ve),f.x=0,f.y=i.CesiumMath.sign(H.longitude-j.longitude),f.z=0)}const y=t.Cartesian3.distance(a,ae),M=c.EncodedCartesian3.fromCartesian(e,Ye),D=t.Cartesian3.subtract(te,e,He),B=t.Cartesian3.normalize(D,Be);let V=t.Cartesian3.subtract(a,e,je);V=t.Cartesian3.normalize(V,V);let Y=t.Cartesian3.cross(B,V,Be);Y=t.Cartesian3.normalize(Y,Y);let oe=t.Cartesian3.cross(V,w,Ve);oe=t.Cartesian3.normalize(oe,oe);let le=t.Cartesian3.subtract(ae,te,qe);le=t.Cartesian3.normalize(le,le);let ce=t.Cartesian3.cross(ne,le,Xe);ce=t.Cartesian3.normalize(ce,ce);const ue=y/U,de=ie/U;let pe,he,me,fe=0,ye=0,Ee=0;if(C){fe=t.Cartesian3.distance(u,d),pe=c.EncodedCartesian3.fromCartesian(u,We),he=t.Cartesian3.subtract(d,u,Ue),me=t.Cartesian3.normalize(he,Ze);const e=me.x;me.x=me.y,me.y=-e,ye=fe/v,Ee=re/v}for(W=0;W<8;W++){const e=K+4*W,a=$+2*W,n=e+3,i=W<4?1:-1,r=2===W||3===W||6===W||7===W?1:-1;t.Cartesian3.pack(M.high,E,e),E[n]=D.x,t.Cartesian3.pack(M.low,_,e),_[n]=D.y,t.Cartesian3.pack(oe,O,e),O[n]=D.z,t.Cartesian3.pack(ce,P,e),P[n]=ue*i,t.Cartesian3.pack(Y,b,e);let s=de*r;0===s&&r<0&&(s=9),b[n]=s,C&&(L[e]=pe.high.x,L[e+1]=pe.high.y,L[e+2]=pe.low.x,L[e+3]=pe.low.y,I[e]=-g.y,I[e+1]=g.x,I[e+2]=f.y,I[e+3]=-f.x,S[e]=he.x,S[e+1]=he.y,S[e+2]=me.x,S[e+3]=me.y,R[a]=ye*i,s=Ee*r,0===s&&r<0&&(s=9),R[a+1]=s)}const _e=Re,$e=De,Qe=xe,Ke=Ie,tt=t.Rectangle.fromCartographicArray(Ne,Se),at=A.getMinimumMaximumHeights(tt,h),nt=at.minimumTerrainHeight,it=at.maximumTerrainHeight;se+=nt,se+=it,we(e,a,nt,it,_e,Qe),we(te,ae,nt,it,$e,Ke);let rt=t.Cartesian3.multiplyByScalar(Y,i.CesiumMath.EPSILON5,Je);t.Cartesian3.add(_e,rt,_e),t.Cartesian3.add($e,rt,$e),t.Cartesian3.add(Qe,rt,Qe),t.Cartesian3.add(Ke,rt,Ke),Me(_e,$e),Me(Qe,Ke),t.Cartesian3.pack(_e,T,Q),t.Cartesian3.pack($e,T,Q+3),t.Cartesian3.pack(Ke,T,Q+6),t.Cartesian3.pack(Qe,T,Q+9),rt=t.Cartesian3.multiplyByScalar(Y,-2*i.CesiumMath.EPSILON5,Je),t.Cartesian3.add(_e,rt,_e),t.Cartesian3.add($e,rt,$e),t.Cartesian3.add(Qe,rt,Qe),t.Cartesian3.add(Ke,rt,Ke),Me(_e,$e),Me(Qe,Ke),t.Cartesian3.pack(_e,T,Q+12),t.Cartesian3.pack($e,T,Q+15),t.Cartesian3.pack(Ke,T,Q+18),t.Cartesian3.pack(Qe,T,Q+21),Z+=2,p+=3,$+=16,Q+=24,K+=32,ie+=y,re+=fe}p=0;let oe=0;for(d=0;d<g;d++){for(W=0;W<Ke;W++)M[p+W]=Qe[W]+oe;oe+=8,p+=Ke}const le=$e;e.BoundingSphere.fromVertices(r,t.Cartesian3.ZERO,3,le[0]),e.BoundingSphere.fromVertices(s,t.Cartesian3.ZERO,3,le[1]);const ce=e.BoundingSphere.fromBoundingSpheres(le);ce.radius+=se/(2*g);const ue={position:new u.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,normalize:!1,values:T}),startHiAndForwardOffsetX:et(E),startLoAndForwardOffsetY:et(_),startNormalAndForwardOffsetZ:et(O),endNormalAndTextureCoordinateNormalizationX:et(P),rightNormalAndTextureCoordinateNormalizationY:et(b)};return C&&(ue.startHiLo2D=et(L),ue.offsetAndRight2D=et(S),ue.startEndNormals2D=et(I),ue.texcoordNormalization2D=new u.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:2,normalize:!1,values:R})),new u.Geometry({attributes:ue,indices:M,boundingSphere:ce})}(d,f,Y,W,V,B,o)};const le=new t.Cartesian3,ce=new t.Matrix3,ue=new e.Quaternion;function Ce(a,n,r,s){const o=q(r,n,le),l=t.Cartesian3.dot(o,a);if(l>x||l<I){const n=q(s,r,$),o=l<I?i.CesiumMath.PI_OVER_TWO:-i.CesiumMath.PI_OVER_TWO,c=e.Quaternion.fromAxisAngle(n,o,ue),u=t.Matrix3.fromQuaternion(c,ce);return t.Matrix3.multiplyByVector(u,a,a),!0}return!1}const de=new t.Cartographic,pe=new t.Cartesian3,he=new t.Cartesian3;function ge(e,a,n,r,s){const o=t.Cartographic.toCartesian(a,e._ellipsoid,pe);let l=t.Cartesian3.add(o,n,he),c=!1;const u=e._ellipsoid;let C=u.cartesianToCartographic(l,de);Math.abs(a.longitude-C.longitude)>i.CesiumMath.PI_OVER_TWO&&(c=!0,l=t.Cartesian3.subtract(o,n,he),C=u.cartesianToCartographic(l,de)),C.height=0;const d=e.project(C,s);return(s=t.Cartesian3.subtract(d,r,s)).z=0,s=t.Cartesian3.normalize(s,s),c&&t.Cartesian3.negate(s,s),s}const me=new t.Cartesian3,fe=new t.Cartesian3;function we(e,a,n,i,r,s){const o=t.Cartesian3.subtract(a,e,me);t.Cartesian3.normalize(o,o);const l=n-0;let c=t.Cartesian3.multiplyByScalar(o,l,fe);t.Cartesian3.add(e,c,r);const u=i-1e3;c=t.Cartesian3.multiplyByScalar(o,u,fe),t.Cartesian3.add(a,c,s)}const ye=new t.Cartesian3;function Me(e,a){const n=d.Plane.getPointDistance(Q,e),r=d.Plane.getPointDistance(Q,a);let s=ye;i.CesiumMath.equalsEpsilon(n,0,i.CesiumMath.EPSILON2)?(s=q(a,e,s),t.Cartesian3.multiplyByScalar(s,i.CesiumMath.EPSILON2,s),t.Cartesian3.add(e,s,e)):i.CesiumMath.equalsEpsilon(r,0,i.CesiumMath.EPSILON2)&&(s=q(e,a,s),t.Cartesian3.multiplyByScalar(s,i.CesiumMath.EPSILON2,s),t.Cartesian3.add(a,s,a))}function Te(e,t){const a=Math.abs(e.longitude),n=Math.abs(t.longitude);if(i.CesiumMath.equalsEpsilon(a,i.CesiumMath.PI,i.CesiumMath.EPSILON11)){const n=i.CesiumMath.sign(t.longitude);return e.longitude=n*(a-i.CesiumMath.EPSILON11),1}if(i.CesiumMath.equalsEpsilon(n,i.CesiumMath.PI,i.CesiumMath.EPSILON11)){const a=i.CesiumMath.sign(e.longitude);return t.longitude=a*(n-i.CesiumMath.EPSILON11),2}return 0}const Ee=new t.Cartographic,_e=new t.Cartographic,Oe=new t.Cartesian3,Pe=new t.Cartesian3,be=new t.Cartesian3,ke=new t.Cartesian3,Ae=new t.Cartesian3,Le=new t.Cartesian3,Ne=[Ee,_e],Se=new t.Rectangle,xe=new t.Cartesian3,Ie=new t.Cartesian3,Re=new t.Cartesian3,De=new t.Cartesian3,ze=new t.Cartesian3,Fe=new t.Cartesian3,ve=new t.Cartesian3,Ge=new t.Cartesian3,He=new t.Cartesian3,je=new t.Cartesian3,qe=new t.Cartesian3,Be=new t.Cartesian3,Ve=new t.Cartesian3,Xe=new t.Cartesian3,Ye=new c.EncodedCartesian3,We=new c.EncodedCartesian3,Ue=new t.Cartesian3,Ze=new t.Cartesian3,Je=new t.Cartesian3,$e=[new e.BoundingSphere,new e.BoundingSphere],Qe=[0,2,1,0,3,2,0,7,3,0,4,7,0,5,4,0,1,5,5,7,4,5,6,7,5,2,6,5,1,2,3,6,2,3,7,6],Ke=Qe.length;function et(e){return new u.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:4,normalize:!1,values:e})}return N._projectNormal=ge,function(e,t){return A.initialize().then((function(){return n.defined(t)&&(e=N.unpack(e,t)),N.createGeometry(e)}))}}));