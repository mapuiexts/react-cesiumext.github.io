define(["./Transforms-01e95659","./Matrix2-7146c9ca","./Matrix3-a348023f","./defaultValue-0a909f67","./Math-e97915da","./ArcType-ce2e50ab","./arrayRemoveDuplicates-e9673044","./ComponentDatatype-77274976","./EllipsoidGeodesic-f4dd0b26","./EllipsoidRhumbLine-9b24aab2","./EncodedCartesian3-0fb84db0","./GeometryAttribute-f5d71750","./IntersectionTests-0bb04fde","./Plane-8575e17c","./WebMercatorProjection-f4deae14","./combine-ca22a614","./RuntimeError-06c93819","./WebGLConstants-a8cc3e8c"],(function(e,t,a,n,i,r,s,o,l,c,u,C,p,d,h,g,f,m){"use strict";function w(i){i=n.defaultValue(i,n.defaultValue.EMPTY_OBJECT),this._ellipsoid=n.defaultValue(i.ellipsoid,a.Ellipsoid.WGS84),this._rectangle=n.defaultValue(i.rectangle,t.Rectangle.MAX_VALUE),this._projection=new e.GeographicProjection(this._ellipsoid),this._numberOfLevelZeroTilesX=n.defaultValue(i.numberOfLevelZeroTilesX,2),this._numberOfLevelZeroTilesY=n.defaultValue(i.numberOfLevelZeroTilesY,1)}Object.defineProperties(w.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},rectangle:{get:function(){return this._rectangle}},projection:{get:function(){return this._projection}}}),w.prototype.getNumberOfXTilesAtLevel=function(e){return this._numberOfLevelZeroTilesX<<e},w.prototype.getNumberOfYTilesAtLevel=function(e){return this._numberOfLevelZeroTilesY<<e},w.prototype.rectangleToNativeRectangle=function(e,a){const r=i.CesiumMath.toDegrees(e.west),s=i.CesiumMath.toDegrees(e.south),o=i.CesiumMath.toDegrees(e.east),l=i.CesiumMath.toDegrees(e.north);return n.defined(a)?(a.west=r,a.south=s,a.east=o,a.north=l,a):new t.Rectangle(r,s,o,l)},w.prototype.tileXYToNativeRectangle=function(e,t,a,n){const r=this.tileXYToRectangle(e,t,a,n);return r.west=i.CesiumMath.toDegrees(r.west),r.south=i.CesiumMath.toDegrees(r.south),r.east=i.CesiumMath.toDegrees(r.east),r.north=i.CesiumMath.toDegrees(r.north),r},w.prototype.tileXYToRectangle=function(e,a,i,r){const s=this._rectangle,o=this.getNumberOfXTilesAtLevel(i),l=this.getNumberOfYTilesAtLevel(i),c=s.width/o,u=e*c+s.west,C=(e+1)*c+s.west,p=s.height/l,d=s.north-a*p,h=s.north-(a+1)*p;return n.defined(r)||(r=new t.Rectangle(u,h,C,d)),r.west=u,r.south=h,r.east=C,r.north=d,r},w.prototype.positionToTileXY=function(e,a,r){const s=this._rectangle;if(!t.Rectangle.contains(s,e))return;const o=this.getNumberOfXTilesAtLevel(a),l=this.getNumberOfYTilesAtLevel(a),c=s.width/o,u=s.height/l;let C=e.longitude;s.east<s.west&&(C+=i.CesiumMath.TWO_PI);let p=(C-s.west)/c|0;p>=o&&(p=o-1);let d=(s.north-e.latitude)/u|0;return d>=l&&(d=l-1),n.defined(r)?(r.x=p,r.y=d,r):new t.Cartesian2(p,d)};const y=new a.Cartesian3,M=new a.Cartesian3,E=new a.Cartographic,T=new a.Cartesian3,_=new a.Cartesian3,O=new e.BoundingSphere,b=new w,P=[new a.Cartographic,new a.Cartographic,new a.Cartographic,new a.Cartographic],A=new t.Cartesian2,k={};function L(e){a.Cartographic.fromRadians(e.east,e.north,0,P[0]),a.Cartographic.fromRadians(e.west,e.north,0,P[1]),a.Cartographic.fromRadians(e.east,e.south,0,P[2]),a.Cartographic.fromRadians(e.west,e.south,0,P[3]);let t=0,n=0,i=0,r=0;const s=k._terrainHeightsMaxLevel;let o;for(o=0;o<=s;++o){let e=!1;for(let t=0;t<4;++t){const a=P[t];if(b.positionToTileXY(a,o,A),0===t)i=A.x,r=A.y;else if(i!==A.x||r!==A.y){e=!0;break}}if(e)break;t=i,n=r}if(0!==o)return{x:t,y:n,level:o>s?s:o-1}}k.initialize=function(){let t=k._initPromise;return n.defined(t)||(t=e.Resource.fetchJson(e.buildModuleUrl("Assets/approximateTerrainHeights.json")).then((function(e){k._terrainHeights=e})),k._initPromise=t),t},k.getMinimumMaximumHeights=function(e,i){i=n.defaultValue(i,a.Ellipsoid.WGS84);const r=L(e);let s=k._defaultMinTerrainHeight,o=k._defaultMaxTerrainHeight;if(n.defined(r)){const l=`${r.level}-${r.x}-${r.y}`,c=k._terrainHeights[l];n.defined(c)&&(s=c[0],o=c[1]),i.cartographicToCartesian(t.Rectangle.northeast(e,E),y),i.cartographicToCartesian(t.Rectangle.southwest(e,E),M),a.Cartesian3.midpoint(M,y,T);const u=i.scaleToGeodeticSurface(T,_);if(n.defined(u)){const e=a.Cartesian3.distance(T,u);s=Math.min(s,-e)}else s=k._defaultMinTerrainHeight}return s=Math.max(k._defaultMinTerrainHeight,s),{minimumTerrainHeight:s,maximumTerrainHeight:o}},k.getBoundingSphere=function(t,i){i=n.defaultValue(i,a.Ellipsoid.WGS84);const r=L(t);let s=k._defaultMaxTerrainHeight;if(n.defined(r)){const e=`${r.level}-${r.x}-${r.y}`,t=k._terrainHeights[e];n.defined(t)&&(s=t[1])}const o=e.BoundingSphere.fromRectangle3D(t,i,0);return e.BoundingSphere.fromRectangle3D(t,i,s,O),e.BoundingSphere.union(o,O,o)},k._terrainHeightsMaxLevel=6,k._defaultMaxTerrainHeight=9e3,k._defaultMinTerrainHeight=-1e5,k._terrainHeights=void 0,k._initPromise=void 0,Object.defineProperties(k,{initialized:{get:function(){return n.defined(k._terrainHeights)}}});var S=k;const x=[e.GeographicProjection,h.WebMercatorProjection],I=x.length,N=Math.cos(i.CesiumMath.toRadians(30)),R=Math.cos(i.CesiumMath.toRadians(150));function D(e){const t=(e=n.defaultValue(e,n.defaultValue.EMPTY_OBJECT)).positions;this.width=n.defaultValue(e.width,1),this._positions=t,this.granularity=n.defaultValue(e.granularity,9999),this.loop=n.defaultValue(e.loop,!1),this.arcType=n.defaultValue(e.arcType,r.ArcType.GEODESIC),this._ellipsoid=a.Ellipsoid.WGS84,this._projectionIndex=0,this._workerName="createGroundPolylineGeometry",this._scene3DOnly=!1}Object.defineProperties(D.prototype,{packedLength:{get:function(){return 1+3*this._positions.length+1+1+1+a.Ellipsoid.packedLength+1+1}}}),D.setProjectionAndEllipsoid=function(e,t){let a=0;for(let e=0;e<I;e++)if(t instanceof x[e]){a=e;break}e._projectionIndex=a,e._ellipsoid=t.ellipsoid};const v=new a.Cartesian3,z=new a.Cartesian3,H=new a.Cartesian3;function B(e,t,n,i,r){const s=X(i,e,0,v),o=X(i,e,n,z),l=X(i,t,0,H),c=W(o,s,z),u=W(l,s,H);return a.Cartesian3.cross(u,c,r),a.Cartesian3.normalize(r,r)}const V=new a.Cartographic,j=new a.Cartesian3,G=new a.Cartesian3,Y=new a.Cartesian3;function F(e,t,n,i,s,o,u,C,p,d,h){if(0===s)return;let g;o===r.ArcType.GEODESIC?g=new l.EllipsoidGeodesic(e,t,u):o===r.ArcType.RHUMB&&(g=new c.EllipsoidRhumbLine(e,t,u));const f=g.surfaceDistance;if(f<s)return;const m=B(e,t,i,u,Y),y=Math.ceil(f/s),M=f/y;let E=M;const T=y-1;let _=C.length;for(let e=0;e<T;e++){const e=g.interpolateUsingSurfaceDistance(E,V),t=X(u,e,n,j),r=X(u,e,i,G);a.Cartesian3.pack(m,C,_),a.Cartesian3.pack(t,p,_),a.Cartesian3.pack(r,d,_),h.push(e.latitude),h.push(e.longitude),_+=3,E+=M}}const q=new a.Cartographic;function X(e,t,n,i){return a.Cartographic.clone(t,q),q.height=n,a.Cartographic.toCartesian(q,e,i)}function W(e,t,n){return a.Cartesian3.subtract(e,t,n),a.Cartesian3.normalize(n,n),n}function U(e,t,n,i){return i=W(e,t,i),i=a.Cartesian3.cross(i,n,i),i=a.Cartesian3.normalize(i,i),a.Cartesian3.cross(n,i,i)}D.pack=function(e,t,i){let r=n.defaultValue(i,0);const s=e._positions,o=s.length;t[r++]=o;for(let e=0;e<o;++e){const n=s[e];a.Cartesian3.pack(n,t,r),r+=3}return t[r++]=e.granularity,t[r++]=e.loop?1:0,t[r++]=e.arcType,a.Ellipsoid.pack(e._ellipsoid,t,r),r+=a.Ellipsoid.packedLength,t[r++]=e._projectionIndex,t[r++]=e._scene3DOnly?1:0,t},D.unpack=function(e,t,i){let r=n.defaultValue(t,0);const s=e[r++],o=new Array(s);for(let t=0;t<s;t++)o[t]=a.Cartesian3.unpack(e,r),r+=3;const l=e[r++],c=1===e[r++],u=e[r++],C=a.Ellipsoid.unpack(e,r);r+=a.Ellipsoid.packedLength;const p=e[r++],d=1===e[r++];return n.defined(i)||(i=new D({positions:o})),i._positions=o,i.granularity=l,i.loop=c,i.arcType=u,i._ellipsoid=C,i._projectionIndex=p,i._scene3DOnly=d,i};const Z=new a.Cartesian3,$=new a.Cartesian3,J=new a.Cartesian3,Q=new a.Cartesian3;function K(e,t,n,r,s){const o=W(n,t,Q),l=U(e,t,o,Z),c=U(r,t,o,$);if(i.CesiumMath.equalsEpsilon(a.Cartesian3.dot(l,c),-1,i.CesiumMath.EPSILON5))return s=a.Cartesian3.cross(o,l,s),a.Cartesian3.normalize(s,s);s=a.Cartesian3.add(c,l,s),s=a.Cartesian3.normalize(s,s);const u=a.Cartesian3.cross(o,s,J);return a.Cartesian3.dot(c,u)<0&&(s=a.Cartesian3.negate(s,s)),s}const ee=d.Plane.fromPointNormal(a.Cartesian3.ZERO,a.Cartesian3.UNIT_Y),te=new a.Cartesian3,ae=new a.Cartesian3,ne=new a.Cartesian3,ie=new a.Cartesian3,re=new a.Cartesian3,se=new a.Cartesian3,oe=new a.Cartographic,le=new a.Cartographic,ce=new a.Cartographic;D.createGeometry=function(l){const d=!l._scene3DOnly;let h=l.loop;const g=l._ellipsoid,f=l.granularity,m=l.arcType,y=new x[l._projectionIndex](g),M=1e3;let E,T;const _=l._positions,O=_.length;let b,P,A,k;2===O&&(h=!1);const I=new c.EllipsoidRhumbLine(void 0,void 0,g);let R,v,z;const H=[_[0]];for(T=0;T<O-1;T++)b=_[T],P=_[T+1],R=p.IntersectionTests.lineSegmentPlane(b,P,ee,se),!n.defined(R)||a.Cartesian3.equalsEpsilon(R,b,i.CesiumMath.EPSILON7)||a.Cartesian3.equalsEpsilon(R,P,i.CesiumMath.EPSILON7)||(l.arcType===r.ArcType.GEODESIC?H.push(a.Cartesian3.clone(R)):l.arcType===r.ArcType.RHUMB&&(z=g.cartesianToCartographic(R,oe).longitude,A=g.cartesianToCartographic(b,oe),k=g.cartesianToCartographic(P,le),I.setEndPoints(A,k),v=I.findIntersectionWithLongitude(z,ce),R=g.cartographicToCartesian(v,se),!n.defined(R)||a.Cartesian3.equalsEpsilon(R,b,i.CesiumMath.EPSILON7)||a.Cartesian3.equalsEpsilon(R,P,i.CesiumMath.EPSILON7)||H.push(a.Cartesian3.clone(R)))),H.push(P);h&&(b=_[O-1],P=_[0],R=p.IntersectionTests.lineSegmentPlane(b,P,ee,se),!n.defined(R)||a.Cartesian3.equalsEpsilon(R,b,i.CesiumMath.EPSILON7)||a.Cartesian3.equalsEpsilon(R,P,i.CesiumMath.EPSILON7)||(l.arcType===r.ArcType.GEODESIC?H.push(a.Cartesian3.clone(R)):l.arcType===r.ArcType.RHUMB&&(z=g.cartesianToCartographic(R,oe).longitude,A=g.cartesianToCartographic(b,oe),k=g.cartesianToCartographic(P,le),I.setEndPoints(A,k),v=I.findIntersectionWithLongitude(z,ce),R=g.cartographicToCartesian(v,se),!n.defined(R)||a.Cartesian3.equalsEpsilon(R,b,i.CesiumMath.EPSILON7)||a.Cartesian3.equalsEpsilon(R,P,i.CesiumMath.EPSILON7)||H.push(a.Cartesian3.clone(R)))));let V=H.length,j=new Array(V);for(T=0;T<V;T++){const e=a.Cartographic.fromCartesian(H[T],g);e.height=0,j[T]=e}if(j=s.arrayRemoveDuplicates(j,a.Cartographic.equalsEpsilon),V=j.length,V<2)return;const G=[],Y=[],q=[],Z=[];let $=te,J=ae,Q=ne,ue=ie,Ce=re;const pe=j[0],he=j[1];for($=X(g,j[V-1],0,$),ue=X(g,he,0,ue),J=X(g,pe,0,J),Q=X(g,pe,M,Q),Ce=h?K($,J,Q,ue,Ce):B(pe,he,M,g,Ce),a.Cartesian3.pack(Ce,Y,0),a.Cartesian3.pack(J,q,0),a.Cartesian3.pack(Q,Z,0),G.push(pe.latitude),G.push(pe.longitude),F(pe,he,0,M,f,m,g,Y,q,Z,G),T=1;T<V-1;++T){$=a.Cartesian3.clone(J,$),J=a.Cartesian3.clone(ue,J);const e=j[T];X(g,e,M,Q),X(g,j[T+1],0,ue),K($,J,Q,ue,Ce),E=Y.length,a.Cartesian3.pack(Ce,Y,E),a.Cartesian3.pack(J,q,E),a.Cartesian3.pack(Q,Z,E),G.push(e.latitude),G.push(e.longitude),F(j[T],j[T+1],0,M,f,m,g,Y,q,Z,G)}const ge=j[V-1],fe=j[V-2];if(J=X(g,ge,0,J),Q=X(g,ge,M,Q),h){const e=j[0];$=X(g,fe,0,$),ue=X(g,e,0,ue),Ce=K($,J,Q,ue,Ce)}else Ce=B(fe,ge,M,g,Ce);if(E=Y.length,a.Cartesian3.pack(Ce,Y,E),a.Cartesian3.pack(J,q,E),a.Cartesian3.pack(Q,Z,E),G.push(ge.latitude),G.push(ge.longitude),h){for(F(ge,pe,0,M,f,m,g,Y,q,Z,G),E=Y.length,T=0;T<3;++T)Y[E+T]=Y[T],q[E+T]=q[T],Z[E+T]=Z[T];G.push(pe.latitude),G.push(pe.longitude)}return function(n,r,s,l,c,p,d){let h,g;const f=r._ellipsoid,m=s.length/3-1,y=8*m,M=4*y,E=36*m,T=y>65535?new Uint32Array(E):new Uint16Array(E),_=new Float64Array(3*y),O=new Float32Array(M),b=new Float32Array(M),P=new Float32Array(M),A=new Float32Array(M),k=new Float32Array(M);let x,I,R,v;d&&(x=new Float32Array(M),I=new Float32Array(M),R=new Float32Array(M),v=new Float32Array(2*y));const z=p.length/2;let H=0;const V=Oe;V.height=0;const j=be;j.height=0;let G=Pe,Y=Le;if(d)for(g=0,h=1;h<z;h++)V.latitude=p[g],V.longitude=p[g+1],j.latitude=p[g+2],j.longitude=p[g+3],G=r.project(V,G),Y=r.project(j,Y),H+=a.Cartesian3.distance(G,Y),g+=2;const q=l.length/3;Y=a.Cartesian3.unpack(l,0,Y);let Z,$=0;for(g=3,h=1;h<q;h++)G=a.Cartesian3.clone(Y,G),Y=a.Cartesian3.unpack(l,g,Y),$+=a.Cartesian3.distance(G,Y),g+=3;g=3;let J=0,Q=0,ee=0,te=0,ae=!1,ne=a.Cartesian3.unpack(s,0,ke),ie=a.Cartesian3.unpack(l,0,Le),re=a.Cartesian3.unpack(c,0,De);n&&de(re,a.Cartesian3.unpack(s,s.length-6,Ae),ne,ie)&&(re=a.Cartesian3.negate(re,re));let se=0,oe=0,le=0;for(h=0;h<m;h++){const e=a.Cartesian3.clone(ne,Ae),n=a.Cartesian3.clone(ie,Pe);let o,C,h,m,y=a.Cartesian3.clone(re,Se);if(ae&&(y=a.Cartesian3.negate(y,y)),ne=a.Cartesian3.unpack(s,g,ke),ie=a.Cartesian3.unpack(l,g,Le),re=a.Cartesian3.unpack(c,g,De),ae=de(re,e,ne,ie),V.latitude=p[J],V.longitude=p[J+1],j.latitude=p[J+2],j.longitude=p[J+3],d){const e=_e(V,j);o=r.project(V,Be),C=r.project(j,ze);const t=W(C,o,$e);t.y=Math.abs(t.y),h=He,m=Ve,0===e||a.Cartesian3.dot(t,a.Cartesian3.UNIT_Y)>N?(h=me(r,V,y,o,He),m=me(r,j,re,C,Ve)):1===e?(m=me(r,j,re,C,Ve),h.x=0,h.y=i.CesiumMath.sign(V.longitude-Math.abs(j.longitude)),h.z=0):(h=me(r,V,y,o,He),m.x=0,m.y=i.CesiumMath.sign(V.longitude-j.longitude),m.z=0)}const M=a.Cartesian3.distance(n,ie),E=u.EncodedCartesian3.fromCartesian(e,Ue),T=a.Cartesian3.subtract(ne,e,je),z=a.Cartesian3.normalize(T,Fe);let G=a.Cartesian3.subtract(n,e,Ge);G=a.Cartesian3.normalize(G,G);let Y=a.Cartesian3.cross(z,G,Fe);Y=a.Cartesian3.normalize(Y,Y);let q=a.Cartesian3.cross(G,y,Ye);q=a.Cartesian3.normalize(q,q);let ce=a.Cartesian3.subtract(ie,ne,We);ce=a.Cartesian3.normalize(ce,ce);let ue=a.Cartesian3.cross(re,ce,qe);ue=a.Cartesian3.normalize(ue,ue);const Ce=M/$,pe=se/$;let he,ge,fe,we=0,ye=0,Te=0;if(d){we=a.Cartesian3.distance(o,C),he=u.EncodedCartesian3.fromCartesian(o,Ze),ge=a.Cartesian3.subtract(C,o,$e),fe=a.Cartesian3.normalize(ge,Ke);const e=fe.x;fe.x=fe.y,fe.y=-e,ye=we/H,Te=oe/H}for(Z=0;Z<8;Z++){const e=te+4*Z,t=Q+2*Z,n=e+3,i=Z<4?1:-1,r=2===Z||3===Z||6===Z||7===Z?1:-1;a.Cartesian3.pack(E.high,O,e),O[n]=T.x,a.Cartesian3.pack(E.low,b,e),b[n]=T.y,a.Cartesian3.pack(q,P,e),P[n]=T.z,a.Cartesian3.pack(ue,A,e),A[n]=Ce*i,a.Cartesian3.pack(Y,k,e);let s=pe*r;0===s&&r<0&&(s=9),k[n]=s,d&&(x[e]=he.high.x,x[e+1]=he.high.y,x[e+2]=he.low.x,x[e+3]=he.low.y,R[e]=-h.y,R[e+1]=h.x,R[e+2]=m.y,R[e+3]=-m.x,I[e]=ge.x,I[e+1]=ge.y,I[e+2]=fe.x,I[e+3]=fe.y,v[t]=ye*i,s=Te*r,0===s&&r<0&&(s=9),v[t+1]=s)}const Oe=Xe,be=ve,Qe=Ne,et=Re,tt=t.Rectangle.fromCartographicArray(xe,Ie),nt=S.getMinimumMaximumHeights(tt,f),it=nt.minimumTerrainHeight,rt=nt.maximumTerrainHeight;le+=it,le+=rt,Me(e,n,it,rt,Oe,Qe),Me(ne,ie,it,rt,be,et);let st=a.Cartesian3.multiplyByScalar(Y,i.CesiumMath.EPSILON5,Je);a.Cartesian3.add(Oe,st,Oe),a.Cartesian3.add(be,st,be),a.Cartesian3.add(Qe,st,Qe),a.Cartesian3.add(et,st,et),Ee(Oe,be),Ee(Qe,et),a.Cartesian3.pack(Oe,_,ee),a.Cartesian3.pack(be,_,ee+3),a.Cartesian3.pack(et,_,ee+6),a.Cartesian3.pack(Qe,_,ee+9),st=a.Cartesian3.multiplyByScalar(Y,-2*i.CesiumMath.EPSILON5,Je),a.Cartesian3.add(Oe,st,Oe),a.Cartesian3.add(be,st,be),a.Cartesian3.add(Qe,st,Qe),a.Cartesian3.add(et,st,et),Ee(Oe,be),Ee(Qe,et),a.Cartesian3.pack(Oe,_,ee+12),a.Cartesian3.pack(be,_,ee+15),a.Cartesian3.pack(et,_,ee+18),a.Cartesian3.pack(Qe,_,ee+21),J+=2,g+=3,Q+=16,ee+=24,te+=32,se+=M,oe+=we}g=0;let ce=0;for(h=0;h<m;h++){for(Z=0;Z<tt;Z++)T[g+Z]=et[Z]+ce;ce+=8,g+=tt}const ue=Qe;e.BoundingSphere.fromVertices(s,a.Cartesian3.ZERO,3,ue[0]),e.BoundingSphere.fromVertices(l,a.Cartesian3.ZERO,3,ue[1]);const Ce=e.BoundingSphere.fromBoundingSpheres(ue);Ce.radius+=le/(2*m);const pe={position:new C.GeometryAttribute({componentDatatype:o.ComponentDatatype.DOUBLE,componentsPerAttribute:3,normalize:!1,values:_}),startHiAndForwardOffsetX:at(O),startLoAndForwardOffsetY:at(b),startNormalAndForwardOffsetZ:at(P),endNormalAndTextureCoordinateNormalizationX:at(A),rightNormalAndTextureCoordinateNormalizationY:at(k)};return d&&(pe.startHiLo2D=at(x),pe.offsetAndRight2D=at(I),pe.startEndNormals2D=at(R),pe.texcoordNormalization2D=new C.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:2,normalize:!1,values:v})),new C.Geometry({attributes:pe,indices:T,boundingSphere:Ce})}(h,y,q,Z,Y,G,d)};const ue=new a.Cartesian3,Ce=new a.Matrix3,pe=new e.Quaternion;function de(t,n,r,s){const o=W(r,n,ue),l=a.Cartesian3.dot(o,t);if(l>N||l<R){const n=W(s,r,Q),o=l<R?i.CesiumMath.PI_OVER_TWO:-i.CesiumMath.PI_OVER_TWO,c=e.Quaternion.fromAxisAngle(n,o,pe),u=a.Matrix3.fromQuaternion(c,Ce);return a.Matrix3.multiplyByVector(u,t,t),!0}return!1}const he=new a.Cartographic,ge=new a.Cartesian3,fe=new a.Cartesian3;function me(e,t,n,r,s){const o=a.Cartographic.toCartesian(t,e._ellipsoid,ge);let l=a.Cartesian3.add(o,n,fe),c=!1;const u=e._ellipsoid;let C=u.cartesianToCartographic(l,he);Math.abs(t.longitude-C.longitude)>i.CesiumMath.PI_OVER_TWO&&(c=!0,l=a.Cartesian3.subtract(o,n,fe),C=u.cartesianToCartographic(l,he)),C.height=0;const p=e.project(C,s);return(s=a.Cartesian3.subtract(p,r,s)).z=0,s=a.Cartesian3.normalize(s,s),c&&a.Cartesian3.negate(s,s),s}const we=new a.Cartesian3,ye=new a.Cartesian3;function Me(e,t,n,i,r,s){const o=a.Cartesian3.subtract(t,e,we);a.Cartesian3.normalize(o,o);const l=n-0;let c=a.Cartesian3.multiplyByScalar(o,l,ye);a.Cartesian3.add(e,c,r);const u=i-1e3;c=a.Cartesian3.multiplyByScalar(o,u,ye),a.Cartesian3.add(t,c,s)}const Te=new a.Cartesian3;function Ee(e,t){const n=d.Plane.getPointDistance(ee,e),r=d.Plane.getPointDistance(ee,t);let s=Te;i.CesiumMath.equalsEpsilon(n,0,i.CesiumMath.EPSILON2)?(s=W(t,e,s),a.Cartesian3.multiplyByScalar(s,i.CesiumMath.EPSILON2,s),a.Cartesian3.add(e,s,e)):i.CesiumMath.equalsEpsilon(r,0,i.CesiumMath.EPSILON2)&&(s=W(e,t,s),a.Cartesian3.multiplyByScalar(s,i.CesiumMath.EPSILON2,s),a.Cartesian3.add(t,s,t))}function _e(e,t){const a=Math.abs(e.longitude),n=Math.abs(t.longitude);if(i.CesiumMath.equalsEpsilon(a,i.CesiumMath.PI,i.CesiumMath.EPSILON11)){const n=i.CesiumMath.sign(t.longitude);return e.longitude=n*(a-i.CesiumMath.EPSILON11),1}if(i.CesiumMath.equalsEpsilon(n,i.CesiumMath.PI,i.CesiumMath.EPSILON11)){const a=i.CesiumMath.sign(e.longitude);return t.longitude=a*(n-i.CesiumMath.EPSILON11),2}return 0}const Oe=new a.Cartographic,be=new a.Cartographic,Pe=new a.Cartesian3,Le=new a.Cartesian3,Ae=new a.Cartesian3,ke=new a.Cartesian3,Se=new a.Cartesian3,De=new a.Cartesian3,xe=[Oe,be],Ie=new t.Rectangle,Ne=new a.Cartesian3,Re=new a.Cartesian3,Xe=new a.Cartesian3,ve=new a.Cartesian3,Be=new a.Cartesian3,ze=new a.Cartesian3,He=new a.Cartesian3,Ve=new a.Cartesian3,je=new a.Cartesian3,Ge=new a.Cartesian3,We=new a.Cartesian3,Fe=new a.Cartesian3,Ye=new a.Cartesian3,qe=new a.Cartesian3,Ue=new u.EncodedCartesian3,Ze=new u.EncodedCartesian3,$e=new a.Cartesian3,Ke=new a.Cartesian3,Je=new a.Cartesian3,Qe=[new e.BoundingSphere,new e.BoundingSphere],et=[0,2,1,0,3,2,0,7,3,0,4,7,0,5,4,0,1,5,5,7,4,5,6,7,5,2,6,5,1,2,3,6,2,3,7,6],tt=et.length;function at(e){return new C.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:4,normalize:!1,values:e})}return D._projectNormal=me,function(e,t){return S.initialize().then((function(){return n.defined(t)&&(e=D.unpack(e,t)),D.createGeometry(e)}))}}));