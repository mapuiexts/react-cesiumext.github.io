define(["exports","./Matrix2-7a8e9daf","./Matrix3-b2351961","./defaultValue-f6d5e6da","./WebGLConstants-7f557f93","./Transforms-f17097e5"],(function(t,e,n,a,r,i){"use strict";var o=Object.freeze({NONE:0,TRIANGLES:1,LINES:2,POLYLINES:3});const s={POINTS:r.WebGLConstants.POINTS,LINES:r.WebGLConstants.LINES,LINE_LOOP:r.WebGLConstants.LINE_LOOP,LINE_STRIP:r.WebGLConstants.LINE_STRIP,TRIANGLES:r.WebGLConstants.TRIANGLES,TRIANGLE_STRIP:r.WebGLConstants.TRIANGLE_STRIP,TRIANGLE_FAN:r.WebGLConstants.TRIANGLE_FAN,isLines:function(t){return t===s.LINES||t===s.LINE_LOOP||t===s.LINE_STRIP},isTriangles:function(t){return t===s.TRIANGLES||t===s.TRIANGLE_STRIP||t===s.TRIANGLE_FAN},validate:function(t){return t===s.POINTS||t===s.LINES||t===s.LINE_LOOP||t===s.LINE_STRIP||t===s.TRIANGLES||t===s.TRIANGLE_STRIP||t===s.TRIANGLE_FAN}};var u=Object.freeze(s);function I(t){t=a.defaultValue(t,a.defaultValue.EMPTY_OBJECT),this.attributes=t.attributes,this.indices=t.indices,this.primitiveType=a.defaultValue(t.primitiveType,u.TRIANGLES),this.boundingSphere=t.boundingSphere,this.geometryType=a.defaultValue(t.geometryType,o.NONE),this.boundingSphereCV=t.boundingSphereCV,this.offsetAttribute=t.offsetAttribute}I.computeNumberOfVertices=function(t){let e=-1;for(const n in t.attributes)if(t.attributes.hasOwnProperty(n)&&a.defined(t.attributes[n])&&a.defined(t.attributes[n].values)){const a=t.attributes[n];e=a.values.length/a.componentsPerAttribute}return e};const N=new n.Cartographic,T=new n.Cartesian3,l=new e.Matrix4,c=[new n.Cartographic,new n.Cartographic,new n.Cartographic],L=[new e.Cartesian2,new e.Cartesian2,new e.Cartesian2],f=[new e.Cartesian2,new e.Cartesian2,new e.Cartesian2],E=new n.Cartesian3,p=new i.Quaternion,m=new e.Matrix4,y=new e.Matrix2;I._textureCoordinateRotationPoints=function(t,a,r,o){let s;const u=e.Rectangle.center(o,N),b=n.Cartographic.toCartesian(u,r,T),C=i.Transforms.eastNorthUpToFixedFrame(b,r,l),h=e.Matrix4.inverse(C,l),d=L,A=c;A[0].longitude=o.west,A[0].latitude=o.south,A[1].longitude=o.west,A[1].latitude=o.north,A[2].longitude=o.east,A[2].latitude=o.south;let x=E;for(s=0;s<3;s++)n.Cartographic.toCartesian(A[s],r,x),x=e.Matrix4.multiplyByPointAsVector(h,x,x),d[s].x=x.x,d[s].y=x.y;const S=i.Quaternion.fromAxisAngle(n.Cartesian3.UNIT_Z,-a,p),P=n.Matrix3.fromQuaternion(S,m),G=t.length;let R=Number.POSITIVE_INFINITY,_=Number.POSITIVE_INFINITY,O=Number.NEGATIVE_INFINITY,g=Number.NEGATIVE_INFINITY;for(s=0;s<G;s++)x=e.Matrix4.multiplyByPointAsVector(h,t[s],x),x=n.Matrix3.multiplyByVector(P,x,x),R=Math.min(R,x.x),_=Math.min(_,x.y),O=Math.max(O,x.x),g=Math.max(g,x.y);const w=e.Matrix2.fromRotation(a,y),V=f;V[0].x=R,V[0].y=_,V[1].x=R,V[1].y=g,V[2].x=O,V[2].y=_;const M=d[0],v=d[2].x-M.x,F=d[1].y-M.y;for(s=0;s<3;s++){const t=V[s];e.Matrix2.multiplyByVector(w,t,t),t.x=(t.x-M.x)/v,t.y=(t.y-M.y)/F}const W=V[0],Y=V[1],B=V[2],z=new Array(6);return e.Cartesian2.pack(W,z),e.Cartesian2.pack(Y,z,2),e.Cartesian2.pack(B,z,4),z},t.Geometry=I,t.GeometryAttribute=function(t){t=a.defaultValue(t,a.defaultValue.EMPTY_OBJECT),this.componentDatatype=t.componentDatatype,this.componentsPerAttribute=t.componentsPerAttribute,this.normalize=a.defaultValue(t.normalize,!1),this.values=t.values},t.GeometryType=o,t.PrimitiveType=u}));