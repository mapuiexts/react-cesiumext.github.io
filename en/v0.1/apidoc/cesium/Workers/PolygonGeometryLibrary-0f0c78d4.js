/*! For license information please see PolygonGeometryLibrary-0f0c78d4.js.LICENSE.txt */
define(["exports","./ArcType-de5d8777","./arrayRemoveDuplicates-6f91355d","./Matrix2-73789715","./ComponentDatatype-e7fbe225","./defaultValue-97284df2","./EllipsoidRhumbLine-60f14314","./GeometryAttribute-fd1d7e90","./GeometryAttributes-734a3446","./GeometryPipeline-a847e31f","./IndexDatatype-65271ba3","./PolygonPipeline-00dc0c6e","./Transforms-d3d3b2a9"],(function(e,t,n,i,o,r,a,s,c,l,u,h,d){"use strict";function p(){this._array=[],this._offset=0,this._length=0}Object.defineProperties(p.prototype,{length:{get:function(){return this._length}}}),p.prototype.enqueue=function(e){this._array.push(e),this._length++},p.prototype.dequeue=function(){if(0===this._length)return;const e=this._array;let t=this._offset;const n=e[t];return e[t]=void 0,t++,t>10&&2*t>e.length&&(this._array=e.slice(t),t=0),this._offset=t,this._length--,n},p.prototype.peek=function(){if(0!==this._length)return this._array[this._offset]},p.prototype.contains=function(e){return-1!==this._array.indexOf(e)},p.prototype.clear=function(){this._array.length=this._offset=this._length=0},p.prototype.sort=function(e){this._offset>0&&(this._array=this._array.slice(this._offset),this._offset=0),this._array.sort(e)};const f={computeHierarchyPackedLength:function(e,t){let n=0;const i=[e];for(;i.length>0;){const e=i.pop();if(!r.defined(e))continue;n+=2;const o=e.positions,a=e.holes;if(r.defined(o)&&o.length>0&&(n+=o.length*t.packedLength),r.defined(a)){const e=a.length;for(let t=0;t<e;++t)i.push(a[t])}}return n},packPolygonHierarchy:function(e,t,n,i){const o=[e];for(;o.length>0;){const e=o.pop();if(!r.defined(e))continue;const a=e.positions,s=e.holes;if(t[n++]=r.defined(a)?a.length:0,t[n++]=r.defined(s)?s.length:0,r.defined(a)){const e=a.length;for(let o=0;o<e;++o,n+=i.packedLength)i.pack(a[o],t,n)}if(r.defined(s)){const e=s.length;for(let t=0;t<e;++t)o.push(s[t])}}return n},unpackPolygonHierarchy:function(e,t,n){const i=e[t++],o=e[t++],r=new Array(i),a=o>0?new Array(o):void 0;for(let o=0;o<i;++o,t+=n.packedLength)r[o]=n.unpack(e,t);for(let i=0;i<o;++i)a[i]=f.unpackPolygonHierarchy(e,t,n),t=a[i].startingIndex,delete a[i].startingIndex;return{positions:r,holes:a,startingIndex:t}}},y=new i.Cartesian2;function g(e,t,n,o){return i.Cartesian2.subtract(t,e,y),i.Cartesian2.multiplyByScalar(y,n/o,y),i.Cartesian2.add(e,y,y),[y.x,y.y]}const m=new i.Cartesian3;function C(e,t,n,o){return i.Cartesian3.subtract(t,e,m),i.Cartesian3.multiplyByScalar(m,n/o,m),i.Cartesian3.add(e,m,m),[m.x,m.y,m.z]}f.subdivideLineCount=function(e,t,n){const r=i.Cartesian3.distance(e,t)/n,a=Math.max(0,Math.ceil(o.CesiumMath.log2(r)));return Math.pow(2,a)};const b=new i.Cartographic,T=new i.Cartographic,x=new i.Cartographic,w=new i.Cartesian3,v=new a.EllipsoidRhumbLine;f.subdivideRhumbLineCount=function(e,t,n,i){const r=e.cartesianToCartographic(t,b),s=e.cartesianToCartographic(n,T),c=new a.EllipsoidRhumbLine(r,s,e).surfaceDistance/i,l=Math.max(0,Math.ceil(o.CesiumMath.log2(c)));return Math.pow(2,l)},f.subdivideTexcoordLine=function(e,t,n,o,r,a){const s=f.subdivideLineCount(n,o,r),c=i.Cartesian2.distance(e,t),l=c/s,u=a;u.length=2*s;let h=0;for(let n=0;n<s;n++){const i=g(e,t,n*l,c);u[h++]=i[0],u[h++]=i[1]}return u},f.subdivideLine=function(e,t,n,o){const a=f.subdivideLineCount(e,t,n),s=i.Cartesian3.distance(e,t),c=s/a;r.defined(o)||(o=[]);const l=o;l.length=3*a;let u=0;for(let n=0;n<a;n++){const i=C(e,t,n*c,s);l[u++]=i[0],l[u++]=i[1],l[u++]=i[2]}return l},f.subdivideTexcoordRhumbLine=function(e,t,n,r,a,s,c){const l=n.cartesianToCartographic(r,b),u=n.cartesianToCartographic(a,T);v.setEndPoints(l,u);const h=v.surfaceDistance/s,d=Math.max(0,Math.ceil(o.CesiumMath.log2(h))),f=Math.pow(2,d),y=i.Cartesian2.distance(e,t),m=y/f,x=c;x.length=2*f;let w=0;for(let n=0;n<f;n++){const i=g(e,t,n*m,y);x[w++]=i[0],x[w++]=i[1]}return x},f.subdivideRhumbLine=function(e,t,n,i,s){const c=e.cartesianToCartographic(t,b),l=e.cartesianToCartographic(n,T),u=new a.EllipsoidRhumbLine(c,l,e),h=u.surfaceDistance/i,d=Math.max(0,Math.ceil(o.CesiumMath.log2(h))),f=Math.pow(2,d),y=u.surfaceDistance/f;r.defined(s)||(s=[]);const m=s;m.length=3*f;let v=0;for(let t=0;t<f;t++){const n=u.interpolateUsingSurfaceDistance(t*y,x),i=e.cartographicToCartesian(n,w);m[v++]=i.x,m[v++]=i.y,m[v++]=i.z}return m};const A=new i.Cartesian3,L=new i.Cartesian3,E=new i.Cartesian3,I=new i.Cartesian3;f.scaleToGeodeticHeightExtruded=function(e,t,n,o,a){o=r.defaultValue(o,i.Ellipsoid.WGS84);const s=A;let c=L;const l=E;let u=I;if(r.defined(e)&&r.defined(e.attributes)&&r.defined(e.attributes.position)){const r=e.attributes.position.values,h=r.length/2;for(let e=0;e<h;e+=3)i.Cartesian3.fromArray(r,e,l),o.geodeticSurfaceNormal(l,s),u=o.scaleToGeodeticSurface(l,u),c=i.Cartesian3.multiplyByScalar(s,n,c),c=i.Cartesian3.add(u,c,c),r[e+h]=c.x,r[e+1+h]=c.y,r[e+2+h]=c.z,a&&(u=i.Cartesian3.clone(l,u)),c=i.Cartesian3.multiplyByScalar(s,t,c),c=i.Cartesian3.add(u,c,c),r[e]=c.x,r[e+1]=c.y,r[e+2]=c.z}return e},f.polygonOutlinesFromHierarchy=function(e,t,o){const a=[],s=new p;let c,l,u;for(s.enqueue(e);0!==s.length;){const e=s.dequeue();let h=e.positions;if(t)for(u=h.length,c=0;c<u;c++)o.scaleToGeodeticSurface(h[c],h[c]);if(h=n.arrayRemoveDuplicates(h,i.Cartesian3.equalsEpsilon,!0),h.length<3)continue;const d=e.holes?e.holes.length:0;for(c=0;c<d;c++){const h=e.holes[c];let d=h.positions;if(t)for(u=d.length,l=0;l<u;++l)o.scaleToGeodeticSurface(d[l],d[l]);if(d=n.arrayRemoveDuplicates(d,i.Cartesian3.equalsEpsilon,!0),d.length<3)continue;a.push(d);let f=0;for(r.defined(h.holes)&&(f=h.holes.length),l=0;l<f;l++)s.enqueue(h.holes[l])}a.push(h)}return a},f.polygonsFromHierarchy=function(e,t,o,a,s){const c=[],l=[],u=new p;for(u.enqueue(e);0!==u.length;){const e=u.dequeue();let d=e.positions;const f=e.holes;let y,m;if(a)for(m=d.length,y=0;y<m;y++)s.scaleToGeodeticSurface(d[y],d[y]);if(t||(d=n.arrayRemoveDuplicates(d,i.Cartesian3.equalsEpsilon,!0)),d.length<3)continue;let b=o(d);if(!r.defined(b))continue;const T=[];let x=h.PolygonPipeline.computeWindingOrder2D(b);x===h.WindingOrder.CLOCKWISE&&(b.reverse(),d=d.slice().reverse());let w=d.slice();const v=r.defined(f)?f.length:0,A=[];let L;for(y=0;y<v;y++){const e=f[y];let c=e.positions;if(a)for(m=c.length,L=0;L<m;++L)s.scaleToGeodeticSurface(c[L],c[L]);if(t||(c=n.arrayRemoveDuplicates(c,i.Cartesian3.equalsEpsilon,!0)),c.length<3)continue;const l=o(c);if(!r.defined(l))continue;x=h.PolygonPipeline.computeWindingOrder2D(l),x===h.WindingOrder.CLOCKWISE&&(l.reverse(),c=c.slice().reverse()),A.push(c),T.push(w.length),w=w.concat(c),b=b.concat(l);let d=0;for(r.defined(e.holes)&&(d=e.holes.length),L=0;L<d;L++)u.enqueue(e.holes[L])}c.push({outerRing:d,holes:A}),l.push({positions:w,positions2D:b,holes:T})}return{hierarchy:c,polygons:l}};const P=new i.Cartesian2,D=new i.Cartesian3,M=new d.Quaternion,_=new i.Matrix3;f.computeBoundingRectangle=function(e,t,n,o,a){const s=d.Quaternion.fromAxisAngle(e,o,M),c=i.Matrix3.fromQuaternion(s,_);let l=Number.POSITIVE_INFINITY,u=Number.NEGATIVE_INFINITY,h=Number.POSITIVE_INFINITY,f=Number.NEGATIVE_INFINITY;const y=n.length;for(let e=0;e<y;++e){const o=i.Cartesian3.clone(n[e],D);i.Matrix3.multiplyByVector(c,o,o);const a=t(o,P);r.defined(a)&&(l=Math.min(l,a.x),u=Math.max(u,a.x),h=Math.min(h,a.y),f=Math.max(f,a.y))}return a.x=l,a.y=h,a.width=u-l,a.height=f-h,a},f.createGeometryFromPositions=function(e,n,a,c,u,d,f){let y=h.PolygonPipeline.triangulate(n.positions2D,n.holes);y.length<3&&(y=[0,1,2]);const m=n.positions,b=r.defined(a),T=b?a.positions:void 0;if(u){const e=m.length,t=new Array(3*e);let n=0;for(let i=0;i<e;i++){const e=m[i];t[n++]=e.x,t[n++]=e.y,t[n++]=e.z}const r={attributes:{position:new s.GeometryAttribute({componentDatatype:o.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:t})},indices:y,primitiveType:s.PrimitiveType.TRIANGLES};b&&(r.attributes.st=new s.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:i.Cartesian2.packArray(T)}));const a=new s.Geometry(r);return d.normal?l.GeometryPipeline.computeNormal(a):a}return f===t.ArcType.GEODESIC?h.PolygonPipeline.computeSubdivision(e,m,y,T,c):f===t.ArcType.RHUMB?h.PolygonPipeline.computeRhumbLineSubdivision(e,m,y,T,c):void 0};const G=[],S=[],R=new i.Cartesian3,N=new i.Cartesian3;f.computeWallGeometry=function(e,n,a,l,h,d){let y,m,b,T,x,w,v,A,L,E=e.length,I=0,P=0;const D=r.defined(n),M=D?n.positions:void 0;if(h)for(m=3*E*2,y=new Array(2*m),D&&(L=2*E*2,A=new Array(2*L)),b=0;b<E;b++)T=e[b],x=e[(b+1)%E],y[I]=y[I+m]=T.x,++I,y[I]=y[I+m]=T.y,++I,y[I]=y[I+m]=T.z,++I,y[I]=y[I+m]=x.x,++I,y[I]=y[I+m]=x.y,++I,y[I]=y[I+m]=x.z,++I,D&&(w=M[b],v=M[(b+1)%E],A[P]=A[P+L]=w.x,++P,A[P]=A[P+L]=w.y,++P,A[P]=A[P+L]=v.x,++P,A[P]=A[P+L]=v.y,++P);else{const n=o.CesiumMath.chordLength(l,a.maximumRadius);let i=0;if(d===t.ArcType.GEODESIC)for(b=0;b<E;b++)i+=f.subdivideLineCount(e[b],e[(b+1)%E],n);else if(d===t.ArcType.RHUMB)for(b=0;b<E;b++)i+=f.subdivideRhumbLineCount(a,e[b],e[(b+1)%E],n);for(m=3*(i+E),y=new Array(2*m),D&&(L=2*(i+E),A=new Array(2*L)),b=0;b<E;b++){let i,o;T=e[b],x=e[(b+1)%E],D&&(w=M[b],v=M[(b+1)%E]),d===t.ArcType.GEODESIC?(i=f.subdivideLine(T,x,n,S),D&&(o=f.subdivideTexcoordLine(w,v,T,x,n,G))):d===t.ArcType.RHUMB&&(i=f.subdivideRhumbLine(a,T,x,n,S),D&&(o=f.subdivideTexcoordRhumbLine(w,v,a,T,x,n,G)));const r=i.length;for(let e=0;e<r;++e,++I)y[I]=i[e],y[I+m]=i[e];if(y[I]=x.x,y[I+m]=x.x,++I,y[I]=x.y,y[I+m]=x.y,++I,y[I]=x.z,y[I+m]=x.z,++I,D){const e=o.length;for(let t=0;t<e;++t,++P)A[P]=o[t],A[P+L]=o[t];A[P]=v.x,A[P+L]=v.x,++P,A[P]=v.y,A[P+L]=v.y,++P}}}E=y.length;const _=u.IndexDatatype.createTypedArray(E/3,E-6*e.length);let O=0;for(E/=6,b=0;b<E;b++){const e=b,t=e+1,n=e+E,r=n+1;T=i.Cartesian3.fromArray(y,3*e,R),x=i.Cartesian3.fromArray(y,3*t,N),i.Cartesian3.equalsEpsilon(T,x,o.CesiumMath.EPSILON10,o.CesiumMath.EPSILON10)||(_[O++]=e,_[O++]=n,_[O++]=t,_[O++]=t,_[O++]=n,_[O++]=r)}const q={attributes:new c.GeometryAttributes({position:new s.GeometryAttribute({componentDatatype:o.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:y})}),indices:_,primitiveType:s.PrimitiveType.TRIANGLES};return D&&(q.attributes.st=new s.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:A})),new s.Geometry(q)},e.PolygonGeometryLibrary=f}));