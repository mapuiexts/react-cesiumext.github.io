/*! For license information please see GeometryPipeline-a847e31f.js.LICENSE.txt */
define(["exports","./AttributeCompression-5744d52e","./Matrix2-73789715","./RuntimeError-4f8ec8a2","./defaultValue-97284df2","./ComponentDatatype-e7fbe225","./Transforms-d3d3b2a9","./EncodedCartesian3-a9a8a281","./GeometryAttribute-fd1d7e90","./IndexDatatype-65271ba3","./IntersectionTests-33ace2d6","./Plane-e916220d"],(function(e,t,n,i,r,a,o,u,c,l,p,d){"use strict";const f=new n.Cartesian3,y=new n.Cartesian3,m=new n.Cartesian3,C={calculateACMR:function(e){const t=(e=r.defaultValue(e,r.defaultValue.EMPTY_OBJECT)).indices;let n=e.maximumIndex;const i=r.defaultValue(e.cacheSize,24),a=t.length;if(!r.defined(n)){n=0;let e=0,i=t[e];for(;e<a;)i>n&&(n=i),++e,i=t[e]}const o=[];for(let e=0;e<n+1;e++)o[e]=0;let u=i+1;for(let e=0;e<a;++e)u-o[t[e]]>i&&(o[t[e]]=u,++u);return(u-i+1)/(a/3)},tipsify:function(e){const t=(e=r.defaultValue(e,r.defaultValue.EMPTY_OBJECT)).indices,n=e.maximumIndex,i=r.defaultValue(e.cacheSize,24);let a;function s(e,t,n,i,r,o,u){let c,l=-1,p=-1,d=0;for(;d<n.length;){const e=n[d];i[e].numLiveTriangles&&(c=0,r-i[e].timeStamp+2*i[e].numLiveTriangles<=t&&(c=r-i[e].timeStamp),(c>p||-1===p)&&(p=c,l=e)),++d}return-1===l?function(e,t,n,i){for(;t.length>=1;){const n=t[t.length-1];if(t.splice(t.length-1,1),e[n].numLiveTriangles>0)return n}for(;a<i;){if(e[a].numLiveTriangles>0)return++a,a-1;++a}return-1}(i,o,0,u):l}const o=t.length;let u=0,c=0,l=t[c];const p=o;if(r.defined(n))u=n+1;else{for(;c<p;)l>u&&(u=l),++c,l=t[c];if(-1===u)return 0;++u}const d=[];let f;for(f=0;f<u;f++)d[f]={numLiveTriangles:0,timeStamp:0,vertexTriangles:[]};c=0;let y=0;for(;c<p;)d[t[c]].vertexTriangles.push(y),++d[t[c]].numLiveTriangles,d[t[c+1]].vertexTriangles.push(y),++d[t[c+1]].numLiveTriangles,d[t[c+2]].vertexTriangles.push(y),++d[t[c+2]].numLiveTriangles,++y,c+=3;let m=0,C=i+1;a=1;let g=[];const A=[];let T,x,S=0;const I=[],O=o/3,N=[];for(f=0;f<O;f++)N[f]=!1;let L,z;for(;-1!==m;){g=[],x=d[m],z=x.vertexTriangles.length;for(let e=0;e<z;++e)if(y=x.vertexTriangles[e],!N[y]){N[y]=!0,c=y+y+y;for(let e=0;e<3;++e)L=t[c],g.push(L),A.push(L),I[S]=L,++S,T=d[L],--T.numLiveTriangles,C-T.timeStamp>i&&(T.timeStamp=C,++C),++c}m=s(0,i,g,d,C,A,u)}return I}},g={};function h(e,t,n,i,r){e[t++]=n,e[t++]=i,e[t++]=i,e[t++]=r,e[t++]=r,e[t]=n}function v(e){const t={};for(const n in e)if(e.hasOwnProperty(n)&&r.defined(e[n])&&r.defined(e[n].values)){const i=e[n];t[n]=new c.GeometryAttribute({componentDatatype:i.componentDatatype,componentsPerAttribute:i.componentsPerAttribute,normalize:i.normalize,values:[]})}return t}function b(e,t,n){for(const i in t)if(t.hasOwnProperty(i)&&r.defined(t[i])&&r.defined(t[i].values)){const r=t[i];for(let t=0;t<r.componentsPerAttribute;++t)e[i].values.push(r.values[n*r.componentsPerAttribute+t])}}g.toWireframe=function(e){const t=e.indices;if(r.defined(t)){switch(e.primitiveType){case c.PrimitiveType.TRIANGLES:e.indices=function(e){const t=e.length,n=t/3*6,i=l.IndexDatatype.createTypedArray(t,n);let r=0;for(let n=0;n<t;n+=3,r+=6)h(i,r,e[n],e[n+1],e[n+2]);return i}(t);break;case c.PrimitiveType.TRIANGLE_STRIP:e.indices=function(e){const t=e.length;if(t>=3){const n=6*(t-2),i=l.IndexDatatype.createTypedArray(t,n);h(i,0,e[0],e[1],e[2]);let r=6;for(let n=3;n<t;++n,r+=6)h(i,r,e[n-1],e[n],e[n-2]);return i}return new Uint16Array}(t);break;case c.PrimitiveType.TRIANGLE_FAN:e.indices=function(e){if(e.length>0){const t=e.length-1,n=6*(t-1),i=l.IndexDatatype.createTypedArray(t,n),r=e[0];let a=0;for(let n=1;n<t;++n,a+=6)h(i,a,r,e[n],e[n+1]);return i}return new Uint16Array}(t)}e.primitiveType=c.PrimitiveType.LINES}return e},g.createLineSegmentsForVectors=function(e,t,n){t=r.defaultValue(t,"normal"),n=r.defaultValue(n,1e4);const i=e.attributes.position.values,u=e.attributes[t].values,l=i.length,p=new Float64Array(2*l);let d,f=0;for(let e=0;e<l;e+=3)p[f++]=i[e],p[f++]=i[e+1],p[f++]=i[e+2],p[f++]=i[e]+u[e]*n,p[f++]=i[e+1]+u[e+1]*n,p[f++]=i[e+2]+u[e+2]*n;const y=e.boundingSphere;return r.defined(y)&&(d=new o.BoundingSphere(y.center,y.radius+n)),new c.Geometry({attributes:{position:new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:p})},primitiveType:c.PrimitiveType.LINES,boundingSphere:d})},g.createAttributeLocations=function(e){const t=["position","positionHigh","positionLow","position3DHigh","position3DLow","position2DHigh","position2DLow","pickColor","normal","st","tangent","bitangent","extrudeDirection","compressedAttributes"],n=e.attributes,i={};let a,o=0;const u=t.length;for(a=0;a<u;++a){const e=t[a];r.defined(n[e])&&(i[e]=o++)}for(const e in n)n.hasOwnProperty(e)&&!r.defined(i[e])&&(i[e]=o++);return i},g.reorderForPreVertexCache=function(e){const t=c.Geometry.computeNumberOfVertices(e),n=e.indices;if(r.defined(n)){const i=new Int32Array(t);for(let e=0;e<t;e++)i[e]=-1;const o=n,u=o.length,c=l.IndexDatatype.createTypedArray(t,u);let p,d=0,f=0,y=0;for(;d<u;)p=i[o[d]],-1!==p?c[f]=p:(p=o[d],i[p]=y,c[f]=y,++y),++d,++f;e.indices=c;const m=e.attributes;for(const e in m)if(m.hasOwnProperty(e)&&r.defined(m[e])&&r.defined(m[e].values)){const n=m[e],r=n.values;let o=0;const u=n.componentsPerAttribute,c=a.ComponentDatatype.createTypedArray(n.componentDatatype,y*u);for(;o<t;){const e=i[o];if(-1!==e)for(let t=0;t<u;t++)c[u*e+t]=r[u*o+t];++o}n.values=c}}return e},g.reorderForPostVertexCache=function(e,t){const n=e.indices;if(e.primitiveType===c.PrimitiveType.TRIANGLES&&r.defined(n)){const i=n.length;let r=0;for(let e=0;e<i;e++)n[e]>r&&(r=n[e]);e.indices=C.tipsify({indices:n,maximumIndex:r,cacheSize:t})}return e},g.fitToUnsignedShortIndices=function(e){const t=[],n=c.Geometry.computeNumberOfVertices(e);if(r.defined(e.indices)&&n>=a.CesiumMath.SIXTY_FOUR_KILOBYTES){let n=[],i=[],o=0,u=v(e.attributes);const l=e.indices,p=l.length;let d;e.primitiveType===c.PrimitiveType.TRIANGLES?d=3:e.primitiveType===c.PrimitiveType.LINES?d=2:e.primitiveType===c.PrimitiveType.POINTS&&(d=1);for(let f=0;f<p;f+=d){for(let t=0;t<d;++t){const a=l[f+t];let c=n[a];r.defined(c)||(c=o++,n[a]=c,b(u,e.attributes,a)),i.push(c)}o+d>=a.CesiumMath.SIXTY_FOUR_KILOBYTES&&(t.push(new c.Geometry({attributes:u,indices:i,primitiveType:e.primitiveType,boundingSphere:e.boundingSphere,boundingSphereCV:e.boundingSphereCV})),n=[],i=[],o=0,u=v(e.attributes))}0!==i.length&&t.push(new c.Geometry({attributes:u,indices:i,primitiveType:e.primitiveType,boundingSphere:e.boundingSphere,boundingSphereCV:e.boundingSphereCV}))}else t.push(e);return t};const A=new n.Cartesian3,T=new n.Cartographic;g.projectTo2D=function(e,t,i,u,l){const p=e.attributes[t],d=(l=r.defined(l)?l:new o.GeographicProjection).ellipsoid,f=p.values,y=new Float64Array(f.length);let m=0;for(let e=0;e<f.length;e+=3){const t=n.Cartesian3.fromArray(f,e,A),i=d.cartesianToCartographic(t,T),r=l.project(i,A);y[m++]=r.x,y[m++]=r.y,y[m++]=r.z}return e.attributes[i]=p,e.attributes[u]=new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:y}),delete e.attributes[t],e};const x={high:0,low:0};g.encodeAttribute=function(e,t,n,i){const r=e.attributes[t],o=r.values,l=o.length,p=new Float32Array(l),d=new Float32Array(l);for(let e=0;e<l;++e)u.EncodedCartesian3.encode(o[e],x),p[e]=x.high,d[e]=x.low;const f=r.componentsPerAttribute;return e.attributes[n]=new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:f,values:p}),e.attributes[i]=new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:f,values:d}),delete e.attributes[t],e};let S=new n.Cartesian3;function P(e,t){if(r.defined(t)){const i=t.values,r=i.length;for(let t=0;t<r;t+=3)n.Cartesian3.unpack(i,t,S),n.Matrix4.multiplyByPoint(e,S,S),n.Cartesian3.pack(S,i,t)}}function w(e,t){if(r.defined(t)){const i=t.values,r=i.length;for(let t=0;t<r;t+=3)n.Cartesian3.unpack(i,t,S),n.Matrix3.multiplyByVector(e,S,S),S=n.Cartesian3.normalize(S,S),n.Cartesian3.pack(S,i,t)}}const I=new n.Matrix4,O=new n.Matrix3;g.transformToWorldCoordinates=function(e){const t=e.modelMatrix;if(n.Matrix4.equals(t,n.Matrix4.IDENTITY))return e;const i=e.geometry.attributes;P(t,i.position),P(t,i.prevPosition),P(t,i.nextPosition),(r.defined(i.normal)||r.defined(i.tangent)||r.defined(i.bitangent))&&(n.Matrix4.inverse(t,I),n.Matrix4.transpose(I,I),n.Matrix4.getMatrix3(I,O),w(O,i.normal),w(O,i.tangent),w(O,i.bitangent));const a=e.geometry.boundingSphere;return r.defined(a)&&(e.geometry.boundingSphere=o.BoundingSphere.transform(a,t,a)),e.modelMatrix=n.Matrix4.clone(n.Matrix4.IDENTITY),e};const N=new n.Cartesian3;function E(e,t){const i=e.length;let u,p,d,f;e[0].modelMatrix;const y=r.defined(e[0][t].indices),m=e[0][t].primitiveType,C=function(e,t){const n=e.length,i={},o=e[0][t].attributes;let u;for(u in o)if(o.hasOwnProperty(u)&&r.defined(o[u])&&r.defined(o[u].values)){const l=o[u];let p=l.values.length,d=!0;for(let i=1;i<n;++i){const n=e[i][t].attributes[u];if(!r.defined(n)||l.componentDatatype!==n.componentDatatype||l.componentsPerAttribute!==n.componentsPerAttribute||l.normalize!==n.normalize){d=!1;break}p+=n.values.length}d&&(i[u]=new c.GeometryAttribute({componentDatatype:l.componentDatatype,componentsPerAttribute:l.componentsPerAttribute,normalize:l.normalize,values:a.ComponentDatatype.createTypedArray(l.componentDatatype,p)}))}return i}(e,t);let g,A,T,x;for(u in C)if(C.hasOwnProperty(u))for(g=C[u].values,f=0,p=0;p<i;++p)for(A=e[p][t].attributes[u].values,T=A.length,d=0;d<T;++d)g[f++]=A[d];if(y){let n=0;for(p=0;p<i;++p)n+=e[p][t].indices.length;const r=c.Geometry.computeNumberOfVertices(new c.Geometry({attributes:C,primitiveType:c.PrimitiveType.POINTS})),a=l.IndexDatatype.createTypedArray(r,n);let o=0,u=0;for(p=0;p<i;++p){const n=e[p][t].indices,i=n.length;for(f=0;f<i;++f)a[o++]=u+n[f];u+=c.Geometry.computeNumberOfVertices(e[p][t])}x=a}let S,I=new n.Cartesian3,O=0;for(p=0;p<i;++p){if(S=e[p][t].boundingSphere,!r.defined(S)){I=void 0;break}n.Cartesian3.add(S.center,I,I)}if(r.defined(I))for(n.Cartesian3.divideByScalar(I,i,I),p=0;p<i;++p){S=e[p][t].boundingSphere;const i=n.Cartesian3.magnitude(n.Cartesian3.subtract(S.center,I,N))+S.radius;i>O&&(O=i)}return new c.Geometry({attributes:C,indices:x,primitiveType:m,boundingSphere:r.defined(I)?new o.BoundingSphere(I,O):void 0})}g.combineInstances=function(e){const t=[],n=[],i=e.length;for(let a=0;a<i;++a){const i=e[a];r.defined(i.geometry)?t.push(i):r.defined(i.westHemisphereGeometry)&&r.defined(i.eastHemisphereGeometry)&&n.push(i)}const a=[];return t.length>0&&a.push(E(t,"geometry")),n.length>0&&(a.push(E(n,"westHemisphereGeometry")),a.push(E(n,"eastHemisphereGeometry"))),a};const L=new n.Cartesian3,z=new n.Cartesian3,D=new n.Cartesian3,M=new n.Cartesian3;g.computeNormal=function(e){const t=e.indices,i=e.attributes,r=i.position.values,o=i.position.values.length/3,u=t.length,l=new Array(o),p=new Array(u/3),d=new Array(u);let f;for(f=0;f<o;f++)l[f]={indexOffset:0,count:0,currentCount:0};let y=0;for(f=0;f<u;f+=3){const e=t[f],i=t[f+1],a=t[f+2],o=3*e,u=3*i,c=3*a;z.x=r[o],z.y=r[o+1],z.z=r[o+2],D.x=r[u],D.y=r[u+1],D.z=r[u+2],M.x=r[c],M.y=r[c+1],M.z=r[c+2],l[e].count++,l[i].count++,l[a].count++,n.Cartesian3.subtract(D,z,D),n.Cartesian3.subtract(M,z,M),p[y]=n.Cartesian3.cross(D,M,new n.Cartesian3),y++}let m,C=0;for(f=0;f<o;f++)l[f].indexOffset+=C,C+=l[f].count;for(y=0,f=0;f<u;f+=3){m=l[t[f]];let e=m.indexOffset+m.currentCount;d[e]=y,m.currentCount++,m=l[t[f+1]],e=m.indexOffset+m.currentCount,d[e]=y,m.currentCount++,m=l[t[f+2]],e=m.indexOffset+m.currentCount,d[e]=y,m.currentCount++,y++}const g=new Float32Array(3*o);for(f=0;f<o;f++){const e=3*f;if(m=l[f],n.Cartesian3.clone(n.Cartesian3.ZERO,L),m.count>0){for(y=0;y<m.count;y++)n.Cartesian3.add(L,p[d[m.indexOffset+y]],L);n.Cartesian3.equalsEpsilon(n.Cartesian3.ZERO,L,a.CesiumMath.EPSILON10)&&n.Cartesian3.clone(p[d[m.indexOffset]],L)}n.Cartesian3.equalsEpsilon(n.Cartesian3.ZERO,L,a.CesiumMath.EPSILON10)&&(L.z=1),n.Cartesian3.normalize(L,L),g[e]=L.x,g[e+1]=L.y,g[e+2]=L.z}return e.attributes.normal=new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:g}),e};const G=new n.Cartesian3,R=new n.Cartesian3,V=new n.Cartesian3;g.computeTangentAndBitangent=function(e){e.attributes;const t=e.indices,i=e.attributes.position.values,r=e.attributes.normal.values,o=e.attributes.st.values,u=e.attributes.position.values.length/3,l=t.length,p=new Array(3*u);let d,f,y,m;for(d=0;d<p.length;d++)p[d]=0;for(d=0;d<l;d+=3){const e=t[d],n=t[d+1],r=t[d+2];f=3*e,y=3*n,m=3*r;const a=2*e,u=2*n,c=2*r,l=i[f],C=i[f+1],g=i[f+2],A=o[a],T=o[a+1],x=o[u+1]-T,S=o[c+1]-T,I=1/((o[u]-A)*S-(o[c]-A)*x),O=(S*(i[y]-l)-x*(i[m]-l))*I,N=(S*(i[y+1]-C)-x*(i[m+1]-C))*I,L=(S*(i[y+2]-g)-x*(i[m+2]-g))*I;p[f]+=O,p[f+1]+=N,p[f+2]+=L,p[y]+=O,p[y+1]+=N,p[y+2]+=L,p[m]+=O,p[m+1]+=N,p[m+2]+=L}const C=new Float32Array(3*u),g=new Float32Array(3*u);for(d=0;d<u;d++){f=3*d,y=f+1,m=f+2;const e=n.Cartesian3.fromArray(r,f,G),t=n.Cartesian3.fromArray(p,f,V),i=n.Cartesian3.dot(e,t);n.Cartesian3.multiplyByScalar(e,i,R),n.Cartesian3.normalize(n.Cartesian3.subtract(t,R,t),t),C[f]=t.x,C[y]=t.y,C[m]=t.z,n.Cartesian3.normalize(n.Cartesian3.cross(e,t,t),t),g[f]=t.x,g[y]=t.y,g[m]=t.z}return e.attributes.tangent=new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:C}),e.attributes.bitangent=new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:g}),e};const F=new n.Cartesian2,B=new n.Cartesian3,_=new n.Cartesian3,k=new n.Cartesian3;let Y=new n.Cartesian2;function q(e){switch(e.primitiveType){case c.PrimitiveType.TRIANGLE_FAN:return function(e){const t=c.Geometry.computeNumberOfVertices(e),n=l.IndexDatatype.createTypedArray(t,3*(t-2));n[0]=1,n[1]=0,n[2]=2;let i=3;for(let e=3;e<t;++e)n[i++]=e-1,n[i++]=0,n[i++]=e;return e.indices=n,e.primitiveType=c.PrimitiveType.TRIANGLES,e}(e);case c.PrimitiveType.TRIANGLE_STRIP:return function(e){const t=c.Geometry.computeNumberOfVertices(e),n=l.IndexDatatype.createTypedArray(t,3*(t-2));n[0]=0,n[1]=1,n[2]=2,t>3&&(n[3]=0,n[4]=2,n[5]=3);let i=6;for(let e=3;e<t-1;e+=2)n[i++]=e,n[i++]=e-1,n[i++]=e+1,e+2<t&&(n[i++]=e,n[i++]=e+1,n[i++]=e+2);return e.indices=n,e.primitiveType=c.PrimitiveType.TRIANGLES,e}(e);case c.PrimitiveType.TRIANGLES:return function(e){if(r.defined(e.indices))return e;const t=c.Geometry.computeNumberOfVertices(e),n=l.IndexDatatype.createTypedArray(t,t);for(let e=0;e<t;++e)n[e]=e;return e.indices=n,e}(e);case c.PrimitiveType.LINE_STRIP:return function(e){const t=c.Geometry.computeNumberOfVertices(e),n=l.IndexDatatype.createTypedArray(t,2*(t-1));n[0]=0,n[1]=1;let i=2;for(let e=2;e<t;++e)n[i++]=e-1,n[i++]=e;return e.indices=n,e.primitiveType=c.PrimitiveType.LINES,e}(e);case c.PrimitiveType.LINE_LOOP:return function(e){const t=c.Geometry.computeNumberOfVertices(e),n=l.IndexDatatype.createTypedArray(t,2*t);n[0]=0,n[1]=1;let i=2;for(let e=2;e<t;++e)n[i++]=e-1,n[i++]=e;return n[i++]=t-1,n[i]=0,e.indices=n,e.primitiveType=c.PrimitiveType.LINES,e}(e);case c.PrimitiveType.LINES:return function(e){if(r.defined(e.indices))return e;const t=c.Geometry.computeNumberOfVertices(e),n=l.IndexDatatype.createTypedArray(t,t);for(let e=0;e<t;++e)n[e]=e;return e.indices=n,e}(e)}return e}function U(e,t){Math.abs(e.y)<a.CesiumMath.EPSILON6&&(e.y=t?-a.CesiumMath.EPSILON6:a.CesiumMath.EPSILON6)}g.compressVertices=function(e){const i=e.attributes.extrudeDirection;let o,u;if(r.defined(i)){const r=i.values;u=r.length/3;const l=new Float32Array(2*u);let p=0;for(o=0;o<u;++o)n.Cartesian3.fromArray(r,3*o,B),n.Cartesian3.equals(B,n.Cartesian3.ZERO)?p+=2:(Y=t.AttributeCompression.octEncodeInRange(B,65535,Y),l[p++]=Y.x,l[p++]=Y.y);return e.attributes.compressedAttributes=new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:l}),delete e.attributes.extrudeDirection,e}const l=e.attributes.normal,p=e.attributes.st,d=r.defined(l),f=r.defined(p);if(!d&&!f)return e;const y=e.attributes.tangent,m=e.attributes.bitangent,C=r.defined(y),g=r.defined(m);let A,T,x,S;d&&(A=l.values),f&&(T=p.values),C&&(x=y.values),g&&(S=m.values),u=(d?A.length:T.length)/(d?3:2);let I=u,O=f&&d?2:1;O+=C||g?1:0,I*=O;const N=new Float32Array(I);let L=0;for(o=0;o<u;++o){f&&(n.Cartesian2.fromArray(T,2*o,F),N[L++]=t.AttributeCompression.compressTextureCoordinates(F));const e=3*o;d&&r.defined(x)&&r.defined(S)?(n.Cartesian3.fromArray(A,e,B),n.Cartesian3.fromArray(x,e,_),n.Cartesian3.fromArray(S,e,k),t.AttributeCompression.octPack(B,_,k,F),N[L++]=F.x,N[L++]=F.y):(d&&(n.Cartesian3.fromArray(A,e,B),N[L++]=t.AttributeCompression.octEncodeFloat(B)),C&&(n.Cartesian3.fromArray(x,e,B),N[L++]=t.AttributeCompression.octEncodeFloat(B)),g&&(n.Cartesian3.fromArray(S,e,B),N[L++]=t.AttributeCompression.octEncodeFloat(B)))}return e.attributes.compressedAttributes=new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:O,values:N}),d&&delete e.attributes.normal,f&&delete e.attributes.st,g&&delete e.attributes.bitangent,C&&delete e.attributes.tangent,e};const H=new n.Cartesian3;function Z(e,t,i,r){n.Cartesian3.add(e,n.Cartesian3.multiplyByScalar(n.Cartesian3.subtract(t,e,H),e.y/(e.y-t.y),H),i),n.Cartesian3.clone(i,r),U(i,!0),U(r,!1)}const W=new n.Cartesian3,X=new n.Cartesian3,j=new n.Cartesian3,J=new n.Cartesian3,ne={positions:new Array(7),indices:new Array(9)};function K(e,t,n){if(e.x>=0||t.x>=0||n.x>=0)return;!function(e,t,n){if(0!==e.y&&0!==t.y&&0!==n.y)return U(e,e.y<0),U(t,t.y<0),void U(n,n.y<0);const i=Math.abs(e.y),r=Math.abs(t.y),o=Math.abs(n.y);let u;u=i>r?i>o?a.CesiumMath.sign(e.y):a.CesiumMath.sign(n.y):r>o?a.CesiumMath.sign(t.y):a.CesiumMath.sign(n.y);const c=u<0;U(e,c),U(t,c),U(n,c)}(e,t,n);const i=e.y<0,r=t.y<0,o=n.y<0;let u=0;u+=i?1:0,u+=r?1:0,u+=o?1:0;const c=ne.indices;1===u?(c[1]=3,c[2]=4,c[5]=6,c[7]=6,c[8]=5,i?(Z(e,t,W,j),Z(e,n,X,J),c[0]=0,c[3]=1,c[4]=2,c[6]=1):r?(Z(t,n,W,j),Z(t,e,X,J),c[0]=1,c[3]=2,c[4]=0,c[6]=2):o&&(Z(n,e,W,j),Z(n,t,X,J),c[0]=2,c[3]=0,c[4]=1,c[6]=0)):2===u&&(c[2]=4,c[4]=4,c[5]=3,c[7]=5,c[8]=6,i?r?o||(Z(n,e,W,j),Z(n,t,X,J),c[0]=0,c[1]=1,c[3]=0,c[6]=2):(Z(t,n,W,j),Z(t,e,X,J),c[0]=2,c[1]=0,c[3]=2,c[6]=1):(Z(e,t,W,j),Z(e,n,X,J),c[0]=1,c[1]=2,c[3]=1,c[6]=0));const l=ne.positions;return l[0]=e,l[1]=t,l[2]=n,l.length=3,1!==u&&2!==u||(l[3]=W,l[4]=X,l[5]=j,l[6]=J,l.length=7),ne}function Q(e,t){const n=e.attributes;if(0===n.position.values.length)return;for(const e in n)if(n.hasOwnProperty(e)&&r.defined(n[e])&&r.defined(n[e].values)){const t=n[e];t.values=a.ComponentDatatype.createTypedArray(t.componentDatatype,t.values)}const i=c.Geometry.computeNumberOfVertices(e);return e.indices=l.IndexDatatype.createTypedArray(i,e.indices),t&&(e.boundingSphere=o.BoundingSphere.fromVertices(n.position.values)),e}function $(e){const t=e.attributes,n={};for(const e in t)if(t.hasOwnProperty(e)&&r.defined(t[e])&&r.defined(t[e].values)){const i=t[e];n[e]=new c.GeometryAttribute({componentDatatype:i.componentDatatype,componentsPerAttribute:i.componentsPerAttribute,normalize:i.normalize,values:[]})}return new c.Geometry({attributes:n,indices:[],primitiveType:e.primitiveType})}function ee(e,t,n){const i=r.defined(e.geometry.boundingSphere);t=Q(t,i),n=Q(n,i),r.defined(n)&&!r.defined(t)?e.geometry=n:!r.defined(n)&&r.defined(t)?e.geometry=t:(e.westHemisphereGeometry=t,e.eastHemisphereGeometry=n,e.geometry=void 0)}function te(e,t){const n=new e,i=new e,r=new e;return function(a,o,u,c,l,p,d,f){const y=e.fromArray(l,a*t,n),m=e.fromArray(l,o*t,i),C=e.fromArray(l,u*t,r);e.multiplyByScalar(y,c.x,y),e.multiplyByScalar(m,c.y,m),e.multiplyByScalar(C,c.z,C);const g=e.add(y,m,y);e.add(g,C,g),f&&e.normalize(g,g),e.pack(g,p,d*t)}}const ie=te(n.Cartesian4,4),re=te(n.Cartesian3,3),ae=te(n.Cartesian2,2),se=new n.Cartesian3,oe=new n.Cartesian3,ue=new n.Cartesian3,de=new n.Cartesian3;function ce(e,t,i,o,u,c,l,p,d,C,g,A,T,x,S,I){if(!(r.defined(c)||r.defined(l)||r.defined(p)||r.defined(d)||r.defined(C)||0!==x))return;const O=function(e,t,i,o,u){let c,l,p,d,C,g,A,T;if(r.defined(u)||(u=new n.Cartesian3),r.defined(t.z)){if(n.Cartesian3.equalsEpsilon(e,t,a.CesiumMath.EPSILON14))return n.Cartesian3.clone(n.Cartesian3.UNIT_X,u);if(n.Cartesian3.equalsEpsilon(e,i,a.CesiumMath.EPSILON14))return n.Cartesian3.clone(n.Cartesian3.UNIT_Y,u);if(n.Cartesian3.equalsEpsilon(e,o,a.CesiumMath.EPSILON14))return n.Cartesian3.clone(n.Cartesian3.UNIT_Z,u);c=n.Cartesian3.subtract(i,t,f),l=n.Cartesian3.subtract(o,t,y),p=n.Cartesian3.subtract(e,t,m),d=n.Cartesian3.dot(c,c),C=n.Cartesian3.dot(c,l),g=n.Cartesian3.dot(c,p),A=n.Cartesian3.dot(l,l),T=n.Cartesian3.dot(l,p)}else{if(n.Cartesian2.equalsEpsilon(e,t,a.CesiumMath.EPSILON14))return n.Cartesian3.clone(n.Cartesian3.UNIT_X,u);if(n.Cartesian2.equalsEpsilon(e,i,a.CesiumMath.EPSILON14))return n.Cartesian3.clone(n.Cartesian3.UNIT_Y,u);if(n.Cartesian2.equalsEpsilon(e,o,a.CesiumMath.EPSILON14))return n.Cartesian3.clone(n.Cartesian3.UNIT_Z,u);c=n.Cartesian2.subtract(i,t,f),l=n.Cartesian2.subtract(o,t,y),p=n.Cartesian2.subtract(e,t,m),d=n.Cartesian2.dot(c,c),C=n.Cartesian2.dot(c,l),g=n.Cartesian2.dot(c,p),A=n.Cartesian2.dot(l,l),T=n.Cartesian2.dot(l,p)}u.y=A*g-C*T,u.z=d*T-C*g;const x=d*A-C*C;if(0!==x)return u.y/=x,u.z/=x,u.x=1-u.y-u.z,u}(o,n.Cartesian3.fromArray(u,3*e,se),n.Cartesian3.fromArray(u,3*t,oe),n.Cartesian3.fromArray(u,3*i,ue),de);if(r.defined(O)){if(r.defined(c)&&re(e,t,i,O,c,A.normal.values,I,!0),r.defined(C)){const r=n.Cartesian3.fromArray(C,3*e,se),a=n.Cartesian3.fromArray(C,3*t,oe),o=n.Cartesian3.fromArray(C,3*i,ue);let u;n.Cartesian3.multiplyByScalar(r,O.x,r),n.Cartesian3.multiplyByScalar(a,O.y,a),n.Cartesian3.multiplyByScalar(o,O.z,o),n.Cartesian3.equals(r,n.Cartesian3.ZERO)&&n.Cartesian3.equals(a,n.Cartesian3.ZERO)&&n.Cartesian3.equals(o,n.Cartesian3.ZERO)?(u=se,u.x=0,u.y=0,u.z=0):(u=n.Cartesian3.add(r,a,r),n.Cartesian3.add(u,o,u),n.Cartesian3.normalize(u,u)),n.Cartesian3.pack(u,A.extrudeDirection.values,3*I)}if(r.defined(g)&&function(e,t,n,i,r,o,u){const c=r[e]*i.x,l=r[t]*i.y,p=r[n]*i.z;o[u]=c+l+p>a.CesiumMath.EPSILON6?1:0}(e,t,i,O,g,A.applyOffset.values,I),r.defined(l)&&re(e,t,i,O,l,A.tangent.values,I,!0),r.defined(p)&&re(e,t,i,O,p,A.bitangent.values,I,!0),r.defined(d)&&ae(e,t,i,O,d,A.st.values,I),x>0)for(let n=0;n<x;n++){const r=T[n];le(e,t,i,O,I,S[r],A[r])}}}function le(e,t,n,i,r,a,o){const u=a.componentsPerAttribute,c=a.values,l=o.values;switch(u){case 4:ie(e,t,n,i,c,l,r,!1);break;case 3:re(e,t,n,i,c,l,r,!1);break;case 2:ae(e,t,n,i,c,l,r,!1);break;default:l[r]=c[e]*i.x+c[t]*i.y+c[n]*i.z}}function pe(e,t,n,i,r,a){const o=e.position.values.length/3;if(-1!==r){const u=i[r],c=n[u];return-1===c?(n[u]=o,e.position.values.push(a.x,a.y,a.z),t.push(o),o):(t.push(c),c)}return e.position.values.push(a.x,a.y,a.z),t.push(o),o}const ye={position:!0,normal:!0,bitangent:!0,tangent:!0,st:!0,extrudeDirection:!0,applyOffset:!0};function fe(e){const t=e.geometry,i=t.attributes,a=i.position.values,o=r.defined(i.normal)?i.normal.values:void 0,u=r.defined(i.bitangent)?i.bitangent.values:void 0,c=r.defined(i.tangent)?i.tangent.values:void 0,l=r.defined(i.st)?i.st.values:void 0,p=r.defined(i.extrudeDirection)?i.extrudeDirection.values:void 0,d=r.defined(i.applyOffset)?i.applyOffset.values:void 0,f=t.indices,y=[];for(const e in i)i.hasOwnProperty(e)&&!ye[e]&&r.defined(i[e])&&y.push(e);const m=y.length,C=$(t),g=$(t);let A,T,x,S,I;const O=[];O.length=a.length/3;const N=[];for(N.length=a.length/3,I=0;I<O.length;++I)O[I]=-1,N[I]=-1;const L=f.length;for(I=0;I<L;I+=3){const e=f[I],t=f[I+1],L=f[I+2];let z=n.Cartesian3.fromArray(a,3*e),D=n.Cartesian3.fromArray(a,3*t),M=n.Cartesian3.fromArray(a,3*L);const G=K(z,D,M);if(r.defined(G)&&G.positions.length>3){const n=G.positions,r=G.indices,z=r.length;for(let D=0;D<z;++D){const z=r[D],M=n[z];M.y<0?(A=g.attributes,T=g.indices,x=O):(A=C.attributes,T=C.indices,x=N),S=pe(A,T,x,f,z<3?I+z:-1,M),ce(e,t,L,M,a,o,c,u,l,p,d,A,y,m,i,S)}}else r.defined(G)&&(z=G.positions[0],D=G.positions[1],M=G.positions[2]),z.y<0?(A=g.attributes,T=g.indices,x=O):(A=C.attributes,T=C.indices,x=N),S=pe(A,T,x,f,I,z),ce(e,t,L,z,a,o,c,u,l,p,d,A,y,m,i,S),S=pe(A,T,x,f,I+1,D),ce(e,t,L,D,a,o,c,u,l,p,d,A,y,m,i,S),S=pe(A,T,x,f,I+2,M),ce(e,t,L,M,a,o,c,u,l,p,d,A,y,m,i,S)}ee(e,g,C)}const me=d.Plane.fromPointNormal(n.Cartesian3.ZERO,n.Cartesian3.UNIT_Y),Ce=new n.Cartesian3,be=new n.Cartesian3;function he(e,t,i,o,u,c,l){if(!r.defined(l))return;const p=n.Cartesian3.fromArray(o,3*e,se);n.Cartesian3.equalsEpsilon(p,i,a.CesiumMath.EPSILON10)?c.applyOffset.values[u]=l[e]:c.applyOffset.values[u]=l[t]}function ve(e){const t=e.geometry,i=t.attributes,o=i.position.values,u=r.defined(i.applyOffset)?i.applyOffset.values:void 0,c=t.indices,l=$(t),d=$(t);let f;const y=c.length,m=[];m.length=o.length/3;const C=[];for(C.length=o.length/3,f=0;f<m.length;++f)m[f]=-1,C[f]=-1;for(f=0;f<y;f+=2){const e=c[f],t=c[f+1],i=n.Cartesian3.fromArray(o,3*e,se),y=n.Cartesian3.fromArray(o,3*t,oe);let g;Math.abs(i.y)<a.CesiumMath.EPSILON6&&(i.y<0?i.y=-a.CesiumMath.EPSILON6:i.y=a.CesiumMath.EPSILON6),Math.abs(y.y)<a.CesiumMath.EPSILON6&&(y.y<0?y.y=-a.CesiumMath.EPSILON6:y.y=a.CesiumMath.EPSILON6);let A=l.attributes,T=l.indices,x=C,S=d.attributes,I=d.indices,O=m;const N=p.IntersectionTests.lineSegmentPlane(i,y,me,ue);if(r.defined(N)){const r=n.Cartesian3.multiplyByScalar(n.Cartesian3.UNIT_Y,5*a.CesiumMath.EPSILON9,Ce);i.y<0&&(n.Cartesian3.negate(r,r),A=d.attributes,T=d.indices,x=m,S=l.attributes,I=l.indices,O=C);const p=n.Cartesian3.add(N,r,be);g=pe(A,T,x,c,f,i),he(e,t,i,o,g,A,u),g=pe(A,T,x,c,-1,p),he(e,t,p,o,g,A,u),n.Cartesian3.negate(r,r),n.Cartesian3.add(N,r,p),g=pe(S,I,O,c,-1,p),he(e,t,p,o,g,S,u),g=pe(S,I,O,c,f+1,y),he(e,t,y,o,g,S,u)}else{let n,r,a;i.y<0?(n=d.attributes,r=d.indices,a=m):(n=l.attributes,r=l.indices,a=C),g=pe(n,r,a,c,f,i),he(e,t,i,o,g,n,u),g=pe(n,r,a,c,f+1,y),he(e,t,y,o,g,n,u)}}ee(e,d,l)}const ge=new n.Cartesian2,Ae=new n.Cartesian2,Te=new n.Cartesian3,xe=new n.Cartesian3,Pe=new n.Cartesian3,we=new n.Cartesian3,Se=new n.Cartesian3,Ie=new n.Cartesian3,Ee=new n.Cartesian4;function Oe(e){const t=e.attributes,i=t.position.values,r=t.prevPosition.values,a=t.nextPosition.values,o=i.length;for(let e=0;e<o;e+=3){const t=n.Cartesian3.unpack(i,e,Te);if(t.x>0)continue;const u=n.Cartesian3.unpack(r,e,xe);(t.y<0&&u.y>0||t.y>0&&u.y<0)&&(e-3>0?(r[e]=i[e-3],r[e+1]=i[e-2],r[e+2]=i[e-1]):n.Cartesian3.pack(t,r,e));const c=n.Cartesian3.unpack(a,e,Pe);(t.y<0&&c.y>0||t.y>0&&c.y<0)&&(e+3<o?(a[e]=i[e+3],a[e+1]=i[e+4],a[e+2]=i[e+5]):n.Cartesian3.pack(t,a,e))}}const Ne=5*a.CesiumMath.EPSILON9,Le=a.CesiumMath.EPSILON6;g.splitLongitude=function(e){const t=e.geometry,i=t.boundingSphere;if(r.defined(i)&&(i.center.x-i.radius>0||o.BoundingSphere.intersectPlane(i,d.Plane.ORIGIN_ZX_PLANE)!==o.Intersect.INTERSECTING))return e;if(t.geometryType!==c.GeometryType.NONE)switch(t.geometryType){case c.GeometryType.POLYLINES:!function(e){const t=e.geometry,i=t.attributes,o=i.position.values,u=i.prevPosition.values,c=i.nextPosition.values,l=i.expandAndWidth.values,d=r.defined(i.st)?i.st.values:void 0,f=r.defined(i.color)?i.color.values:void 0,y=$(t),m=$(t);let C,g,A,T=!1;const x=o.length/3;for(C=0;C<x;C+=4){const e=C,t=C+2,i=n.Cartesian3.fromArray(o,3*e,Te),x=n.Cartesian3.fromArray(o,3*t,xe);if(Math.abs(i.y)<Le)for(i.y=Le*(x.y<0?-1:1),o[3*C+1]=i.y,o[3*(C+1)+1]=i.y,g=3*e;g<3*e+12;g+=3)u[g]=o[3*C],u[g+1]=o[3*C+1],u[g+2]=o[3*C+2];if(Math.abs(x.y)<Le)for(x.y=Le*(i.y<0?-1:1),o[3*(C+2)+1]=x.y,o[3*(C+3)+1]=x.y,g=3*e;g<3*e+12;g+=3)c[g]=o[3*(C+2)],c[g+1]=o[3*(C+2)+1],c[g+2]=o[3*(C+2)+2];let S=y.attributes,I=y.indices,O=m.attributes,N=m.indices;const L=p.IntersectionTests.lineSegmentPlane(i,x,me,we);if(r.defined(L)){T=!0;const o=n.Cartesian3.multiplyByScalar(n.Cartesian3.UNIT_Y,Ne,Se);i.y<0&&(n.Cartesian3.negate(o,o),S=m.attributes,I=m.indices,O=y.attributes,N=y.indices);const p=n.Cartesian3.add(L,o,Ie);S.position.values.push(i.x,i.y,i.z,i.x,i.y,i.z),S.position.values.push(p.x,p.y,p.z),S.position.values.push(p.x,p.y,p.z),S.prevPosition.values.push(u[3*e],u[3*e+1],u[3*e+2]),S.prevPosition.values.push(u[3*e+3],u[3*e+4],u[3*e+5]),S.prevPosition.values.push(i.x,i.y,i.z,i.x,i.y,i.z),S.nextPosition.values.push(p.x,p.y,p.z),S.nextPosition.values.push(p.x,p.y,p.z),S.nextPosition.values.push(p.x,p.y,p.z),S.nextPosition.values.push(p.x,p.y,p.z),n.Cartesian3.negate(o,o),n.Cartesian3.add(L,o,p),O.position.values.push(p.x,p.y,p.z),O.position.values.push(p.x,p.y,p.z),O.position.values.push(x.x,x.y,x.z,x.x,x.y,x.z),O.prevPosition.values.push(p.x,p.y,p.z),O.prevPosition.values.push(p.x,p.y,p.z),O.prevPosition.values.push(p.x,p.y,p.z),O.prevPosition.values.push(p.x,p.y,p.z),O.nextPosition.values.push(x.x,x.y,x.z,x.x,x.y,x.z),O.nextPosition.values.push(c[3*t],c[3*t+1],c[3*t+2]),O.nextPosition.values.push(c[3*t+3],c[3*t+4],c[3*t+5]);const z=n.Cartesian2.fromArray(l,2*e,ge),D=Math.abs(z.y);S.expandAndWidth.values.push(-1,D,1,D),S.expandAndWidth.values.push(-1,-D,1,-D),O.expandAndWidth.values.push(-1,D,1,D),O.expandAndWidth.values.push(-1,-D,1,-D);let M=n.Cartesian3.magnitudeSquared(n.Cartesian3.subtract(L,i,Pe));if(M/=n.Cartesian3.magnitudeSquared(n.Cartesian3.subtract(x,i,Pe)),r.defined(f)){const i=n.Cartesian4.fromArray(f,4*e,Ee),r=n.Cartesian4.fromArray(f,4*t,Ee),o=a.CesiumMath.lerp(i.x,r.x,M),u=a.CesiumMath.lerp(i.y,r.y,M),c=a.CesiumMath.lerp(i.z,r.z,M),l=a.CesiumMath.lerp(i.w,r.w,M);for(g=4*e;g<4*e+8;++g)S.color.values.push(f[g]);for(S.color.values.push(o,u,c,l),S.color.values.push(o,u,c,l),O.color.values.push(o,u,c,l),O.color.values.push(o,u,c,l),g=4*t;g<4*t+8;++g)O.color.values.push(f[g])}if(r.defined(d)){const i=n.Cartesian2.fromArray(d,2*e,ge),r=n.Cartesian2.fromArray(d,2*(C+3),Ae),o=a.CesiumMath.lerp(i.x,r.x,M);for(g=2*e;g<2*e+4;++g)S.st.values.push(d[g]);for(S.st.values.push(o,i.y),S.st.values.push(o,r.y),O.st.values.push(o,i.y),O.st.values.push(o,r.y),g=2*t;g<2*t+4;++g)O.st.values.push(d[g])}A=S.position.values.length/3-4,I.push(A,A+2,A+1),I.push(A+1,A+2,A+3),A=O.position.values.length/3-4,N.push(A,A+2,A+1),N.push(A+1,A+2,A+3)}else{let e,t;for(i.y<0?(e=m.attributes,t=m.indices):(e=y.attributes,t=y.indices),e.position.values.push(i.x,i.y,i.z),e.position.values.push(i.x,i.y,i.z),e.position.values.push(x.x,x.y,x.z),e.position.values.push(x.x,x.y,x.z),g=3*C;g<3*C+12;++g)e.prevPosition.values.push(u[g]),e.nextPosition.values.push(c[g]);for(g=2*C;g<2*C+8;++g)e.expandAndWidth.values.push(l[g]),r.defined(d)&&e.st.values.push(d[g]);if(r.defined(f))for(g=4*C;g<4*C+16;++g)e.color.values.push(f[g]);A=e.position.values.length/3-4,t.push(A,A+2,A+1),t.push(A+1,A+2,A+3)}}T&&(Oe(m),Oe(y)),ee(e,m,y)}(e);break;case c.GeometryType.TRIANGLES:fe(e);break;case c.GeometryType.LINES:ve(e)}else q(t),t.primitiveType===c.PrimitiveType.TRIANGLES?fe(e):t.primitiveType===c.PrimitiveType.LINES&&ve(e);return e},e.GeometryPipeline=g}));